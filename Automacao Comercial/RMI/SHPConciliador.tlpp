#INCLUDE "Protheus.ch"
#INCLUDE "TopConn.ch"

namespace totvs.protheus.retail.rmi.servicos.SHPConciliador


Static dDtFim     := cToD("")
Static dDtInicial := cToD("")
Static cTicket    := ""
Static oBuscaObj  := Nil
Static aAnexos    := {}

// Testa conciliador
//Exemplo para execução
//totvs.protheus.retail.rmi.servicos.SHPConciliador.u_Concteste()
User function Concteste(cEmpAmb as character,cFilAmb as character, cTicketJob as character, cDataIniJob as character, cDataFinalJob as character)
    SHPConciliador(cEmpAmb, cFilAmb, cTicketJob, cDataIniJob, cDataFinalJob)
Return

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} SHPConciliador
Função responsal pelo conciliador de dados entre sistemas.

@type       Class
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------
Function SHPConciliador(cEmpAmb as character,cFilAmb as character, cTicketJob as character, cDataIniJob as character, cDataFinalJob as character )
    Local nTimer := seconds()
    cSemaforo := "SHPConciliador" +"_"+ cEmpAmb

    RpcSetType(3)
    RpcSetEnv(cEmpAmb, cFilAmb, , ,"LOJ", "SHPConciliador")

    If !LockByName(cSemaforo, .T., .T.)
        LjGrvLog("Conciliador ->"+ ProcName(),"Conciliador já esta sendo utilizado por outra instância.")
        Return Nil
    EndIf

    LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando conciliador..  aguarde!")
    
    Controle(cTicketJob, cDataIniJob, cDataFinalJob)

    LjGrvLog("Conciliador ->"+ ProcName(), "Tempo total para execuçao do conciliador:["+ str(seconds()-nTimer,12,3) +"]") 
    UnLockByName(cSemaforo, .T., .T.)
Return

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} Controle
Static responsavel pelo controle, organiza e executa o fluxo do conciliador

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function Controle(cTicketJob as character, cDataIniJob as character, cDataFinalJob as character)
    Local aDadosLive     := {}   as Array
    Local aDadosProtheus := {}   as Array
    Local aDiferencasConsolidado as Array
    Local aDadosConector         as Array
    Local aSaltos                as Array
    Local aEmails                as Array
    Local cDiretorio     := ""   as character
    Local cAssunto       := ""   as character
    Local cCorpo         := ""   as character
    Local cConsolidado   := ""   as character
    Local nEmail         := 0    as numeric

    oBuscaObj := RmiBusLiveObj():New()

    // -- Confirmação é um processo de busca, porem é necessario na conferencia, para não ser necessario incluir um novo processo mudo o tipo para q ele seja setado corretamente
    oBuscaObj:cTipo := "1" // -- Busca processo do tipo Envia
    oBuscaObj:SetaProcesso("CONFERENCIA")
    oBuscaObj:cTipo := "2" 

    If oBuscaObj:OCONFPROCE:hasProperty("data_conferencia") .And. STOD(oBuscaObj:OCONFPROCE["data_conferencia"]) < Date()

        oBuscaObj:cToken := ""
        oBuscaObj:PreExecucao()

        If oBuscaObj:OCONFPROCE:hasProperty("diretorio_resultado") .And. !Empty(oBuscaObj:OCONFPROCE["diretorio_resultado"])
            cDiretorio := oBuscaObj:OCONFPROCE["diretorio_resultado"]
        EndIf 

        LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando busca dos dados do TVFR no connector... Aguarde!")
        
        aDadosConector := ObterDadosLive({cTicketJob,cDataIniJob,cDataFinalJob})
        LjGrvLog("Conciliador ->"+ ProcName(),"Finalizando busca dos dados do TVFR no connector...")
        LjGrvLog("Conciliador ->"+ ProcName(),"Quantidade de itens retornados:[" + cValtoChar(Len(aDadosConector)) + "]")


        If Len(aDadosConector) > 0
        
            //Obtem e organiza os dados recebidos pelo LIVE
            LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando Processamento dos registros TVFR... Aguarde!")
            aDadosLive := DadosLive(aDadosConector)
            LjGrvLog("Conciliador ->"+ ProcName(),"Finalizando processamento dos Registros TVFR...")

            
            If aDadosLive[4]
                
                //Obtem e organiza os dados recebidos pelo Protheus
                LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando busca dos registros no Protheus... Aguarde!")
                aDadosProtheus := dadosProtheus(aDadosLive[3])
                LjGrvLog("Conciliador ->"+ ProcName(),"Finalizando busca dos registros no Protheus...")


                LjGrvLog("Conciliador ->"+ ProcName(),"Analisando Salto de numeração... Aguarde!")
                aSaltos := AnalisaSaltoNumeracao(aDadosProtheus[3])
                LjGrvLog("Conciliador ->"+ ProcName()," Finalizando analise de salto de numeração")


                //Obtem e organiza os dados recebidos pelo Protheus
                LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando comparação... Aguarde!")
                aDiferencasConsolidado := ComparaDados(aDadosProtheus, aDadosLive)
                LjGrvLog("Conciliador ->"+ ProcName(),"Finalizando Comparação")

                LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando busca de informações consolidadas... Aguarde!")
                If oBuscaObj:OCONFPROCE:hasProperty("diretorio_query") .And. !Empty(oBuscaObj:OCONFPROCE["diretorio_query"])
                    cConsolidado := Consolidado(aDiferencasConsolidado,oBuscaObj:OCONFPROCE["diretorio_query"])
                Else
                    LjGrvLog("Conciliador ->"+ ProcName(),"Tag: [diretorio_query] não existe ou vazia, não será gerado consolidado no corpo do e-mail! ")    
                EndIf 
                LjGrvLog("Conciliador ->"+ ProcName(),"Finalizando busca de informações consolidadas",cConsolidado)


                //Remove erros conhecidos   
                LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando removendo erros conhecidos do salto... Aguarde!")
                aSaltos := RemoveErrosdoSalto(aSaltos,aDiferencasConsolidado)
                LjGrvLog("Conciliador ->"+ ProcName(),"Finalizando removendo erros conhecidos do salto")


                LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando Gerando/Gravando CSV de Salto de numeração... Aguarde!")
                SalvarCsv(GerarCsv(aSaltos),"SaltoNumeracao",cDiretorio)
                LjGrvLog("Conciliador ->"+ ProcName(),"Finalizando Gerando/Gravando CSV de Salto de numeração")


                LjGrvLog("Conciliador ->"+ ProcName(),"Iniciando busca dos registros no Protheus... Aguarde!")
                SalvarCsv(GerarCsv(aDiferencasConsolidado),,cDiretorio)
                LjGrvLog("Conciliador ->"+ ProcName(),"Finalizando gerando/Gravando CSV de resultado...")

                If oBuscaObj:OCONFPROCE:hasProperty("emails") .And. Valtype(oBuscaObj:OCONFPROCE["emails"]) == "A" .And. Len(oBuscaObj:OCONFPROCE["emails"]) >= 1

                    aEmails  := oBuscaObj:OCONFPROCE["emails"]
                    cAssunto := "Resultado do conciliador. execução do dia:" + DTOC(Date())
                    cCorpo   := "Resultado do conciliador. execução do dia:" + DTOC(Date()) + " com os seguintes parametros: Data Inicial[" + DTOC(dDtInicial) + "]" + " Data Final["+ DTOC(dDtFim) +"] Ticket:["+ cTicket +"]" + CHR(13) + CHR(10)
                    cCorpo   += "<br>" + cConsolidado

                    For nEmail := 1 To Len(aEmails)
                        If !EnviaEmail(aEmails[nEmail], cAssunto, cCorpo, aAnexos)
                            LjGrvLog("Conciliador ->"+ ProcName(),"Não foi possivel enviar email para:[" + aEmails[nEmail] + "] os arquivos estão salvos em:",aAnexos)
                        EndIf 
                    Next 
                
                EndIf 

            EndIf 
        
        Endif 

        If !Empty(cTicket)
            oBuscaObj:cConfirma := cTicket
            oBuscaObj:Confirma()

            // -- Atualizo ultima execução do conciliador 
            oBuscaObj:OCONFPROCE["data_conferencia"] := DTOS(Date())
        EndIf 
    
        // -- Atualiza configuração do assinante. (oConfAssin)
        oBuscaObj:SalvaConfig()

        FWFreeArray(aDadosLive)
        FwFreeArray(aDadosProtheus)
        FWFreeArray(aDiferencasConsolidado)
        FWFreeArray(aSaltos)
        FWFreeArray(aAnexos)

    Else    
        LjGrvLog("Conciliador ->"+ ProcName(),"Parametro de assinante data_conferencia:[" + IIF(Valtype(oBuscaObj:OCONFPROCE["data_conferencia"]) == "U","Em branco",oBuscaObj:OCONFPROCE["data_conferencia"] +  "]")) 
       
        If Valtype(oBuscaObj:OCONFPROCE["data_conferencia"]) == "U"
            LjGrvLog("Conciliador ->"+ ProcName(),"Parametro [data_conferencia] nulo, preencheremos com a seguinte data:[" + DTOS(Date() - 1) + "]")
            oBuscaObj:OCONFPROCE["data_conferencia"] := DToS(Date() - 1)

            // -- Atualiza configuração do assinante. (oConfAssin)
            oBuscaObj:SalvaConfig()
        EndIf 
    EndIf 

    FreeObj(oBuscaObj)

Return

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} dadosLive
Static responsavel por preparar os dados recebidos pelo assisnate live

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------


Static function dadosLive(aDadosConector as Array)  as Object
    
    Local nTimer                                 as numeric
    Local aDadosLive      := {}                  as array
    Local oHashLive       := tHashMap():New()    as Object
    Local nPosicaoChave                          as numeric
    Local nPosicao        := 0                   as numeric
    Local nX              := 0                   as numeric
    Local nPosicaoFilial  := 0                   as numeric
    Local aFiliais        := {}                  as Array
    Local aChaves         := {}                  as Array
    Local cFilialProtheus := ""                  as Character
    Local cWhereFilial    := ""                  as Character
    Local lRetorno        := .T.                 as logical
    Local nTotal          := len(aDadosConector) as numeric
    Local Item            := 1                   as numeric
    
    nTimer := seconds()
   
    cWhereFilial := "("
    
    LjGrvLog("Conciliador ->"+ ProcName(),"Processando Dados LIVE... " + cValToChar(1) + " de " + cValToChar(nTotal) + "...")

    For Item := 1 To nTotal
        
        If Mod(Item, 1000) == 0   //TENORIO
            LjGrvLog("Conciliador ->"+ ProcName(),"Processando Dados LIVE... " + cValToChar(Item) + " de " + cValToChar(nTotal) + "...")
        EndIf

        nPosicao := 0
        aChaves := {}
        cFilialProtheus := ""
        
        //*Campos que temos no protheus q não temos no live */
        //* Criado para manter a compatibilidade */
        /*20*/aAdd(aDadosConector[Item],"SEM INFORMAÇÃO")//Codigo do cliente (informado somente no protheus)     
        /*21*/aAdd(aDadosConector[Item],"INFORMAÇÃO NÃO LOCALIZADA")//Observação     
        /*22*/aAdd(aDadosConector[Item],"INFORMAÇÃO NÃO LOCALIZADA")//Origem     
        /*23*/aAdd(aDadosConector[Item],"INFORMAÇÃO NÃO LOCALIZADA")//Mensagem de erro     
        /*24*/aAdd(aDadosConector[Item],"INFORMAÇÃO NÃO LOCALIZADA")//UUID

        //TENORIO
        /*25*/aAdd(aDadosConector[Item],"")//Data Integração
        /*26*/aAdd(aDadosConector[Item],"")//Observação Fiscal
        //TENORIO

        If (nPosicaoFilial := AScan(aFiliais,{|x| Alltrim(x[1]) == Alltrim(aDadosConector[Item][4])})) == 0   // Se já tiver a filial para esse codigo ignora
        
            If !Empty(cFilialProtheus := RmiDePaRet("LIVE", "SM0", aDadosConector[Item][4], .F.))
                aAdd(aFiliais, {aDadosConector[Item][4],cFilialProtheus}) 
                cWhereFilial += "'" +  cFilialProtheus + "',"
            Else
                LjGrvLog("Conciliador ->" + ProcName(),"DE/PARA de filiais[SM0] não encontrado, conteudo procurado: [" + aDadosConector[Item][4] + "], Erro ao buscar DE/PARA")
                LjGrvLog("Conciliador ->" + ProcName(),"Por esse motivo o conciliador será encerrado, regularize seu DE/PARA.")
                lRetorno := .F.
                Exit
            EndIf 
        EndIf

        If Empty(cFilialProtheus)
            cFilialProtheus := aFiliais[nPosicaoFilial][2]
        EndIF 
        
        If aDadosConector[Item][12] == "3"    //CodigoDocFiscal
            nPosicaoChave := 10 //controle
            If aDadosConector[Item][nPosicaoChave] == "0" .Or. Empty(aDadosConector[Item][nPosicaoChave])
                nPosicaoChave := 11 //Chavedocc
                
                //aAdd(aChaves,Alltrim(aDadosConector[Item][nPosicaoChave]) + "|" + aDadosConector[Item][13] + "|" + aDadosConector[Item][19] + "|" + "SEM CONTROLE")    //ChaveDocc     DocFiscal   ValorTotalBruto
                aAdd(aChaves,cFilialProtheus + "|" + Alltrim(aDadosConector[Item][nPosicaoChave]) + "|" + aDadosConector[Item][13] + "|" + aDadosConector[Item][19] + "|" + "SEM CONTROLE")    //ChaveDocc     DocFiscal   ValorTotalBruto

            Else
                //aAdd(aChaves,Alltrim(aDadosConector[Item][nPosicaoChave]))
                aAdd(aChaves,AllTrim(cFilialProtheus) + "|" + Alltrim(aDadosConector[Item][nPosicaoChave]))  //CodigoLoja    Controle     
            EndIf 
            
        Else
            nPosicaoChave := 11

            // -- Se for em branco busca apenas por doc e serie 
            If Empty(aDadosConector[Item][nPosicaoChave])
                If (Empty(aDadosConector[Item][6]) .Or. aDadosConector[Item][6] == "0") .And. (Empty(aDadosConector[Item][7]) .Or. aDadosConector[Item][7] == "0") 
                    Loop  
                Else
                    aAdd(aChaves,Alltrim(cFilialProtheus) + Alltrim(STR(Val(aDadosConector[Item][7]))) + Alltrim(STR(Val(aDadosConector[Item][8])))) 
                EndIf   
            Else
                aAdd(aChaves,Alltrim(aDadosConector[Item][nPosicaoChave]))  
                aAdd(aChaves,Alltrim(cFilialProtheus) + Alltrim(STR(Val(aDadosConector[Item][7]))) + Alltrim(STR(Val(aDadosConector[Item][8])))) // -- Filial + serie + doc 
            EndIf 
            
        EndIf

        For nX := 1 To Len(aChaves)
            oHashLive:Get(aChaves[nX],@nPosicao)
            If nPosicao > 0
                Exit
            EndIf 
        Next nX 

        If nPosicao > 0 
            aAdd(aDadosLive[nPosicao][2],aDadosConector[Item])
        Else
            aAdd(aDadosLive,{aChaves,{aDadosConector[Item]}})
            For nX := 1 To Len(aChaves)
                oHashLive:Set(Alltrim(aChaves[nX]),Len(aDadosLive)) 
            Next nX 
        EndIf 
            
    Next 

    cWhereFilial := SubString(cWhereFilial,1,Len(cWhereFilial)-1)
    cWhereFilial += ")"

    LjGrvLog("Conciliador ->"+ ProcName(), "Tempo para processar dados fornecido pelo TOTVS Conector" + str(seconds()-nTimer,12,3)) 
    LjGrvLog("Conciliador ->"+ ProcName(), "Registros: " + STR(Len(aDadosLive))) 

Return {aDadosLive,oHashLive,cWhereFilial,lRetorno}

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} dadosProtheus
Static responsavel por buscaar e preparar os dados do assisnate Protheus

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------


Static function dadosProtheus(cWhereFilial as character )
    
    Local cAlias          := GetNextAlias()   as character
    Local cQuery          := ""               as character
    Local nTotal          := 0                as numeric
    Local nAtual          := 0                as numeric
    Local aLinha          := {}               as Array
    Local aDadosProtheus  := {}               as Array
    Local aChaves         := {}               as Array
    Local oHashProtheus   := tHashMap():New() as Object
    Local nPosicao                            as numeric
    Local nPosicaoChave   := 11               as numeric
    Local aDevolucaoPDV   := {}               as Array 
    Local nPosDevolucao   := 0                as numeric
    Local nX              := 0                as numeric
    Local lDevolucaoPDV   := .F.              as logical
    Local oHashDocumentos := tHashMap():New() as Object
    Local aDocumentos     := {}               as array
    Local lSat            := .F.              as Logical
    
    
    cQuery += " SELECT  "
    cQuery += " FT_FILIAL,FT_SERSAT,FT_SERIE,FT_NFISCAL,FT_ESPECIE,FT_CHVNFE,FT_EMISSAO,FT_DTCANC,FT_ITEM,FT_PRODUTO,FT_QUANT,FT_VALCONT,FT_TIPO,FT_ENTRADA, "
    //cQuery += " FT_TIPOMOV, FT_CLIEFOR + '|' + FT_LOJA AS CLIENTE, FT_OBSERV" TENORIO
    cQuery += " FT_TIPOMOV, FT_CLIEFOR + '|' + FT_LOJA AS CLIENTE, UPPER(FT_OBSERV) AS FT_OBSERV"
    cQuery += " FROM "+ RetSqlName( 'SFT' )+ " SFT "
    cQuery += " WHERE SFT.FT_FILIAL IN " + cWhereFilial
    cQuery += " AND SFT.FT_EMISSAO BETWEEN '"+dTos(dDtInicial)+"' AND '"+dTos(dDtFim)+"' "
    cQuery += " AND (
    cQuery += "    SFT.FT_CHVNFE <> ' ' "
    cQuery += "    OR FT_TIPO = 'D' "
    cQuery += "    OR (  SFT.FT_CHVNFE  = ' ' AND SFT.FT_ESPECIE = 'NFCE' ) "
    cQuery += "    OR ( SFT.FT_TIPOMOV = 'S' AND SFT.FT_ESPECIE = 'SPED'  ) "
    cQuery +=   " ) "
    cQuery += " AND SFT.FT_ESPECIE NOT IN ('CTE','CTEOS') "
    cQuery += " AND SFT.D_E_L_E_T_ = ' ' "
    cQuery += " AND EXISTS ( SELECT '' FROM " + RetSqlName( 'SB1' ) + " SB1 WHERE B1_COD = FT_PRODUTO AND B1_TIPO = 'PA' AND SB1.D_E_L_E_T_=' ' )"
    cQuery += " AND NOT EXISTS ( SELECT '' FROM " + RetSqlName( 'SF3' ) + " SF3 WHERE F3_FILIAL = FT_FILIAL AND F3_NFISCAL = FT_NFISCAL AND F3_SERIE = FT_SERIE AND F3_ESPECIE = 'SPED' AND F3_CODRSEF = '102' AND SF3.D_E_L_E_T_ = ' ' )"  //Não trazer inutilização especie SPED
    cQuery += " ORDER BY FT_EMISSAO "

    TCQUERY cQuery NEW ALIAS (cAlias)

    Count To nTotal

    LjGrvLog("Conciliador ->"+ ProcName(),"Processando Dados LIVE... " + cValToChar(1) + " de " + cValToChar(nTotal) + "...")

    (cAlias)->(DbGoTop())
    While !(cAlias)->(EoF())
        
        lDevolucaoPDV := .F.
        nPosicao := 0
        aChaves := {}
        nAtual++
        
        If Mod(nAtual, 1000) == 0   //TENORIO
            LjGrvLog("Conciliador ->"+ ProcName(),"Processando Dados LIVE... " + cValToChar(nAtual) + " de " + cValToChar(nTotal) + "...")
        EndIf

        aLinha := {}
        /*1*/aAdd(aLinha,IIF(ALLTRIM(UPPER((cAlias)->(FT_ESPECIE))) == "SPED","NOTA","CUPOM" ))//Tipo
        /*2*/aAdd(aLinha,"SEM INFORMAÇÃO")//Ticket Saida
        /*3*/aAdd(aLinha,"SEM INFORMAÇÃO")//Situacao Ticket
        /*4*/aAdd(aLinha,(cAlias)->(FT_FILIAL) /*IIF(Empty(Auxiliar := RmiDePaRet("LIVE", "SM0", (cAlias)->(FT_FILIAL), .T.)),"SEM DE/PARA DE EMPRESA [SM0]",Auxiliar)*/)//Codigo Loja -- Pegar no DE/Para
        /*5*/aAdd(aLinha,"")//CNPJ   -- Alinhar com o thiago a remoção
        /*6*/aAdd(aLinha,(cAlias)->(FT_SERSAT))//NumeroImpressora
        /*7*/aAdd(aLinha,(cAlias)->(FT_SERIE))//Serie
        /*8*/aAdd(aLinha,(cAlias)->(FT_NFISCAL))//Nº Doc
        /*9*/aAdd(aLinha,(cAlias)->(FT_ESPECIE))//Modelo Fiscal
        /*10*/aAdd(aLinha,"")//Controle -- PEGAR DA MHQ
        /*11*/aAdd(aLinha,(cAlias)->(FT_CHVNFE))//Chave Doc
        /*12*/aAdd(aLinha,"")//Codigo Doc Fiscal
        /*13*/aAdd(aLinha,IIF(Alltrim((cAlias)->(FT_TIPOMOV)) == "E","ENTRADA","SAIDA"))//Doc Fiscal
        /*14*/aAdd(aLinha,DTOC(STOD((cAlias)->(FT_EMISSAO))))//DataEmissao
        ///*15*/aAdd(aLinha,IIF(Empty((cAlias)->(FT_DTCANC)),"0","1"))//SituacaoNFCe  Situacao Doc -- FT_DTCANC, SE PREENCHIDO VERDADEIRO     //Regra TVFR - 0=normal, 1=cancelado e 3=inutilizado  TENORIO
        /*15*/aAdd(aLinha, IIF( Empty( (cAlias)->(FT_DTCANC) ), "0", IIF( AllTrim((cAlias)->FT_OBSERV) == "NF INUTILIZADA", "3",  "1") ) )//SituacaoNFCe  Situacao Doc -- FT_DTCANC, SE PREENCHIDO VERDADEIRO     //Regra TVFR - 0=normal, 1=cancelado e 3=inutilizado
        /*16*/aAdd(aLinha,(cAlias)->(FT_ITEM))//Item
        /*17*/aAdd(aLinha,(cAlias)->(FT_PRODUTO))//Cod Produto
        /*18*/aAdd(aLinha,(cAlias)->(FT_QUANT))//Quantidade
        /*19*/aAdd(aLinha,(cAlias)->(FT_VALCONT))//ValorTotalBruto     
        /*20*/aAdd(aLinha,(cAlias)->(CLIENTE))//Cliente|Loja     
        /*21*/aAdd(aLinha,"")//Observação     
        /*22*/aAdd(aLinha,"")//Origem     
        /*23*/aAdd(aLinha,"")//Mensagem de erro     
        /*24*/aAdd(aLinha,"")//UUID

        //TENORIO
        /*25*/aAdd(aLinha,"")//Data Integração
        /*26*/aAdd(aLinha, AllTrim( (cAlias)->FT_OBSERV) )//Observação Fiscal
        //TENORIO

        // -- Regra que verifica se é uma devolução originaria do PDV
        If (cAlias)->(FT_TIPO) == "D"
            nPosDevolucao := aScan(aDevolucaoPDV,{|x| x[1] == (cAlias)->(FT_FILIAL) + (cAlias)->(FT_NFISCAL) + (cAlias)->(FT_SERIE) })

            If nPosDevolucao > 0 
                lDevolucaoPDV := aDevolucaoPDV[nPosDevolucao][2]
            Else 
                aadd(aDevolucaoPDV,{(cAlias)->(FT_FILIAL) + (cAlias)->(FT_NFISCAL) + (cAlias)->(FT_SERIE),GetAdvFVal( 'SF1', 'F1_ORIGEM', xfilial( 'SF1',(cAlias)->(FT_FILIAL)) + (cAlias)->(FT_NFISCAL) + (cAlias)->(FT_SERIE) , 1, '') == "SMARTCON"})
                lDevolucaoPDV := aDevolucaoPDV[Len(aDevolucaoPDV)][2]
            EndIf 
        EndIf 

        // -- Controle de Salto de numeração
        If (Alltrim((cAlias)->(FT_TIPOMOV)) == "E" .AND.  lDevolucaoPDV) .OR. Alltrim((cAlias)->(FT_TIPOMOV)) == "S"
            cChave := (cAlias)->(FT_FILIAL) + Alltrim(STR(Val((cAlias)->(FT_NFISCAL)))) + Alltrim(STR(Val((cAlias)->(FT_SERIE)))) + (cAlias)->(FT_TIPOMOV)
        
            If !oHashDocumentos:Get(cChave) 

                oHashDocumentos:Set(cChave) 

                lSat :=  (cAlias)->(FT_ESPECIE) == "SATCE"

                CancelamentoSAT := !(Empty((cAlias)->(FT_DTCANC))) .AND. lSat

                cNumeroSerie := Iif(lSat,(cAlias)->(FT_SERSAT),(cAlias)->(FT_SERIE))
                
                nPosicaoFilial := AScan(aDocumentos,{|x| x[1] == (cAlias)->(FT_FILIAL)})
                
                If nPosicaoFilial == 0
                    aadd(aDocumentos,{(cAlias)->(FT_FILIAL),{}})
                    nAuxLen := len(aDocumentos)

                    aadd(aDocumentos[nAuxLen][2],{Val(cNumeroSerie),{}})
                    aadd(aDocumentos[nAuxLen][2][Len(aDocumentos[nAuxLen][2])][2],{Val((cAlias)->(FT_NFISCAL)),CancelamentoSAT,(cAlias)->(FT_SERSAT),(cAlias)->(FT_SERIE)})
                Else
                    PosicaoSerie :=  AScan(aDocumentos[nPosicaoFilial][2],{|x| x[1] == Val(cNumeroSerie)})
                    
                    If PosicaoSerie == 0
                        aadd(aDocumentos[nPosicaoFilial][2],{Val(cNumeroSerie),{}})
                        aadd(aDocumentos[nPosicaoFilial][2][Len(aDocumentos[nPosicaoFilial][2])][2],{Val((cAlias)->(FT_NFISCAL)),CancelamentoSAT,(cAlias)->(FT_SERSAT),(cAlias)->(FT_SERIE)})
                    Else
                        aadd(aDocumentos[nPosicaoFilial][2][PosicaoSerie][2],{Val((cAlias)->(FT_NFISCAL)),CancelamentoSAT,(cAlias)->(FT_SERSAT),(cAlias)->(FT_SERIE)})
                    EndIf 
                    
                EndIf 

                nPosicao := 0
            EndIf 

        EndIf 
        

        // -- Se for devolução realiza busca
        If  lDevolucaoPDV
            
            //-- Atualizo o Codigo Doc Fiscal
            aDepara := StrTokArr(RmiDePaRet("LIVE", "SF1", (cAlias)->(FT_FILIAL) + "|" + (cAlias)->(FT_NFISCAL) + "|" + (cAlias)->(FT_SERIE), .T.),"|")

            If Len(aDepara) >= 3 
                aLinha[10] := aDepara[Len(aDepara)] // -- numero de controle encontrado no De/para
            EndIf 
            
            aLinha[12] := "3"
            aLinha[13] := "DEVOLUCAO - TROCA"

            // -- se é devolução a chave é o numero de controle 
            If !Empty(Alltrim(aLinha[10]))
                aAdd(aChaves,Alltrim(aLinha[4]) + "|" + Alltrim(aLinha[10]))   
            Else
                // -- se não achar o numero de controle a chave passa a ser filial + doc + serie, não deve achar para que seja apresentado a diferença
                aAdd(aChaves,Alltrim(aLinha[4]) + Alltrim(STR(Val(aLinha[7]))) + Alltrim(STR(Val(aLinha[8])))) 
            EndIf

        Else
           
            If !Empty(Alltrim(aLinha[nPosicaoChave]))   
                aAdd(aChaves,Alltrim(aLinha[nPosicaoChave]))  
            EndIf

            If !Empty(Alltrim(aLinha[4]) + Alltrim(STR(Val(aLinha[7]))) + Alltrim(STR(Val(aLinha[8]))))
                aAdd(aChaves,Alltrim(aLinha[4]) + Alltrim(STR(Val(aLinha[7]))) + Alltrim(STR(Val(aLinha[8])))) 
            EndIf   
 
        EndIf 

        For nX := 1 To Len(aChaves)
            oHashProtheus:Get(aChaves[nX],@nPosicao)
            
            If nPosicao > 0
                Exit
            EndIf 

        Next nX 
        
        If nPosicao > 0
            aAdd(aDadosProtheus[nPosicao][2],aLinha)
        Else
            aAdd(aDadosProtheus,{aChaves,{aLinha}})

            For nX := 1 To Len(aChaves)
                oHashProtheus:Set(Alltrim(aChaves[nX]),Len(aDadosProtheus)) 
            Next nX 
        EndIf 

        (cAlias)->(DbSkip())
    EndDo

    (cAlias)->(DBCloseArea())
    
Return {aDadosProtheus,oHashProtheus,aDocumentos}


//-------------------------------------------------------------------------------------
/*/{Protheus.doc} ComparaDados
Static responsavel por comparar os dados do protheus e outros assinantes

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function ComparaDados(dadosProtheus as Array, dadosLive as Array) as Array

    Local Item                                        as numeric
    Local nPosicao            := 0                     as numeric
    Local nX                 := 0                     as numeric
    Local nTamanhoItens      := Len(dadosProtheus[1]) as numeric
    Local aNotasFaltando     := {}                    as Array
    Local aMensagemErro      := array(7)              as Array //TENORIO
    Local cSerie             := ""                    as character
    Local cSerialEquipamento := ""                    as character
    Local cModelo            := ""                    as character
    Local cDoc               := ""                    as character
    Local cChave             := ""                    as character
    Local cTipo              := ""                    as character

    LjGrvLog("Conciliador ->"+ ProcName(),"Inicindo comparação Protheus > TVFR! Aguarde!")
    
    //-- Cabeçalho
    aAdd(aNotasFaltando,{})
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Tipo") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Ticket") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"SituacaoTicket") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"CodigoLoja") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"CNPJ") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"NumeroImpressora") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Serie") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Ndoc") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"ModeloFisc") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Controle") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"ChaveDocc") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"CodigoDocFiscal") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"DocFiscal") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"DataEmissao") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"SituacaoNFCe") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Item") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"CodProduto") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Quantiade") 
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"ValorTotalBruto") 
    
    // Adiciona itens a mais para o cabeçalho
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Cliente")
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Observacao")
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"Origem")
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"msg_erro")
    aAdd(aNotasFaltando[Len(aNotasFaltando)],"UUID")

    //TENORIO
    /*25*/aAdd(aNotasFaltando[Len(aNotasFaltando)],"DtIntegracao")
    /*26*/aAdd(aNotasFaltando[Len(aNotasFaltando)],"Obs_Fiscal")
    //TENORIO

    // Compara do Protheus para TVFR
    For Item := 1 To nTamanhoItens
        
        nPosicao := 0

        If  !Empty(dadosProtheus[1][Item][1])
            QtdChave := Len(dadosProtheus[1][Item][1])
            For nX := 1 To QtdChave
                
                If !(dadosProtheus[1][Item][1][nX] == "0")
                    dadosLive[2]:Get(Alltrim(dadosProtheus[1][Item][1][nX]),@nPosicao)
                EndIf

                aMensagemErro[1] := ""
                aMensagemErro[2] := ""
                aMensagemErro[3] := ""
                aMensagemErro[4] := ""
                aMensagemErro[5] := ""
                aMensagemErro[6] := ""  //TENORIO
                aMensagemErro[7] := ""  //TENORIO

                If nPosicao == 0 
                    // -- So logo se for o ultimo
                    If nX == QtdChave

                        //TENORIO
                        If UPPER(ALLTRIM(dadosProtheus[1][Item][2][1][1])) == "NOTA" .And. dadosProtheus[1][Item][2][1][15] == "1"  //Tipo e SituacaoNFCe
                            //Nota cancelada no PROTHEUS e não existe no TVFR, então não gera erro
                        Else
                        //TENORIO

                            aAdd(aNotasFaltando,dadosProtheus[1][Item][2][1])
                            aNotasFaltando[Len(aNotasFaltando)][21] := "Nota/Cupom não encontrado no TVFR"//--Observação
                            aNotasFaltando[Len(aNotasFaltando)][22] := "PROTHEUS"//--Origem

                            //lSemControle := aNotasFaltando[Len(aNotasFaltando)][10] == "0" .AND. aNotasFaltando[Len(aNotasFaltando)][12] == "3"   TENORIO

                            If UPPER(ALLTRIM(aNotasFaltando[Len(aNotasFaltando)][1])) == "NOTA" 
                                //aMensagemErro := BuscaErroNotaDeEntradaSaidaProtheus(aNotasFaltando[Len(aNotasFaltando)][04],aNotasFaltando[Len(aNotasFaltando)][08],aNotasFaltando[Len(aNotasFaltando)][07],aNotasFaltando[Len(aNotasFaltando)][20],aNotasFaltando[Len(aNotasFaltando)][13],STOD(aNotasFaltando[Len(aNotasFaltando)][14]))   TENORIO
                                aMensagemErro := BuscaErroNotaDeEntradaSaidaProtheus(aNotasFaltando[Len(aNotasFaltando)][04],aNotasFaltando[Len(aNotasFaltando)][08],aNotasFaltando[Len(aNotasFaltando)][07],aNotasFaltando[Len(aNotasFaltando)][20],aNotasFaltando[Len(aNotasFaltando)][13],CTOD(aNotasFaltando[Len(aNotasFaltando)][14]))
                            EndIf 

                            aNotasFaltando[Len(aNotasFaltando)][23] := aMensagemErro[1]
                            aNotasFaltando[Len(aNotasFaltando)][24] := aMensagemErro[5]

                            aNotasFaltando[Len(aNotasFaltando)][25] := aMensagemErro[6] //TENORIO
                            
                            If Empty(aMensagemErro[1])
                                If UPPER(ALLTRIM(aNotasFaltando[Len(aNotasFaltando)][1])) == "NOTA" 
                                    //aNotasFaltando[Len(aNotasFaltando)][23] := "Mensagem de erro não encontrada | Verifique se os filtros do processo foram atendidos."   TENORIO
                                    aNotasFaltando[Len(aNotasFaltando)][23] := IIF( aMensagemErro[6] == DToC(Date()), "Integração gerada hoje | Arquivo do TVFR ainda não contempla esta informação.", "Mensagem de erro não encontrada | Verifique se os filtros do processo foram atendidos." )
                                Else
                                    //aNotasFaltando[Len(aNotasFaltando)][23] := "Mensagem de erro não encontrada | esse movimento ainda não chegou no PROTHEUS ou não foi encontrado nas tabelas de integração"    TENORIO
                                    aNotasFaltando[Len(aNotasFaltando)][21] := "Cupom emitido pelo PROTHEUS"    //--Observação
                                    aNotasFaltando[Len(aNotasFaltando)][23] := "Não existe integração de cupom do PROTHEUS para o TVFR."    //--Mensagem de erro
                                EndIf
                            EndIf

                        EndIf   //TENORIO
                    EndIf 
                        
                Else

                    //TENORIO
                    /*
                    //Valida se a SituacaoNFCe do PROTHEUS é igual ao TVFR (0=normal, 1=cancelado e 3=inutilizado)
                    If dadosProtheus[3][Item][2][1][15] <> dadosLive[3][Posicao][2][1][15]

                        aAdd(aNotasFaltando,dadosProtheus[3][Item][2][1])
                        aNotasFaltando[Len(aNotasFaltando)][21] := "Nota/Cupom encontrado no TVFR com SituacaoNFCe diferente"   //--Observação
                        aNotasFaltando[Len(aNotasFaltando)][22] := "PROTHEUS"//--Origem

                        If UPPER(ALLTRIM(aNotasFaltando[Len(aNotasFaltando)][1])) == "NOTA" 
                            //aMensagemErro := BuscaErroNotaDeEntradaSaidaProtheus(aNotasFaltando[Len(aNotasFaltando)][04],aNotasFaltando[Len(aNotasFaltando)][08],aNotasFaltando[Len(aNotasFaltando)][07],aNotasFaltando[Len(aNotasFaltando)][20],aNotasFaltando[Len(aNotasFaltando)][13],STOD(aNotasFaltando[Len(aNotasFaltando)][14]))   TENORIO
                            aMensagemErro := BuscaErroNotaDeEntradaSaidaProtheus(aNotasFaltando[Len(aNotasFaltando)][04],aNotasFaltando[Len(aNotasFaltando)][08],aNotasFaltando[Len(aNotasFaltando)][07],aNotasFaltando[Len(aNotasFaltando)][20],aNotasFaltando[Len(aNotasFaltando)][13],CTOD(aNotasFaltando[Len(aNotasFaltando)][14]))
                        EndIf 

                        aNotasFaltando[Len(aNotasFaltando)][23] := "SituacaoNFCe no PROTHEUS " + dadosProtheus[3][Item][2][1][15] + " e no TVFR " + dadosLive[3][Posicao][2][1][15]
                        aNotasFaltando[Len(aNotasFaltando)][24] := aMensagemErro[5]
                        aNotasFaltando[Len(aNotasFaltando)][25] := aMensagemErro[6]
                    EndIf
                    */
                    //TENORIO

                    //-- se ja achei com uma chave não busco a proxima.
                    Exit
                EndIf 
  
            Next nX
        EndIf 
        If Mod(Item, 1000) == 0   //TENORIO
            LjGrvLog("Conciliador ->"+ ProcName(),"Comparando do Protheus > TVFR" + cValToChar(Item) + " de " + cValToChar(nTamanhoItens) + "...")
        EndIf
    Next Item

    nTamanhoItens := Len(dadosLive[1])

    
    LjGrvLog("Conciliador ->"+ ProcName(),"Concluida comparação Protheus > TVFR! Aguarde!")
    LjGrvLog("Conciliador ->"+ ProcName(),"Inicindo comparação TVFR > Protheus! Aguarde!")

    // Compara do Live para o Protheus
    For Item := 1 To nTamanhoItens

        nPosicao := 0

        If  !Empty(dadosLive[1][Item][1])
            QtdChave := Len(dadosLive[1][Item][1])
            For nX := 1 To QtdChave
                
                If !(dadosLive[1][Item][1][nX] == "0")
                    dadosProtheus[2]:Get(Alltrim(dadosLive[1][Item][1][nX]),@nPosicao)
                EndIf 

                aMensagemErro[1] := ""
                aMensagemErro[2] := ""
                aMensagemErro[3] := ""
                aMensagemErro[4] := ""
                aMensagemErro[5] := ""
                aMensagemErro[6] := ""  //TENORIO
                aMensagemErro[7] := ""  //TENORIO

                If nPosicao == 0 
                    
                    If nX == QtdChave 

                        aAdd(aNotasFaltando,dadosLive[1][Item][2][1])
                        aNotasFaltando[Len(aNotasFaltando)][21] := "Nota/Cupom não encontrado no PROTHEUS"
                        aNotasFaltando[Len(aNotasFaltando)][22] := "LIVE"

                        lSemControle := dadosLive[1][Item][1][nX] == "0" .AND. aNotasFaltando[Len(aNotasFaltando)][12] == "3"

                        If UPPER(ALLTRIM(aNotasFaltando[Len(aNotasFaltando)][1])) == "CUPOM" .AND. !lSemControle
                            aMensagemErro := BuscaErroVenda(aNotasFaltando[Len(aNotasFaltando)][8],aNotasFaltando[Len(aNotasFaltando)][7],aNotasFaltando[Len(aNotasFaltando)][6],aNotasFaltando[Len(aNotasFaltando)][9])
                        ElseIf ALLTRIM(aNotasFaltando[Len(aNotasFaltando)][12]) == "3" .AND. !lSemControle
                            aMensagemErro := BuscaErroNotaDeEntradaLive(aNotasFaltando[Len(aNotasFaltando)][10],aNotasFaltando[Len(aNotasFaltando)][7],CTOD(SUBSTR(aNotasFaltando[Len(aNotasFaltando)][14],1,10)))
                        EndIf 

                        aNotasFaltando[Len(aNotasFaltando)][23] := aMensagemErro[1]
                        aNotasFaltando[Len(aNotasFaltando)][24] := aMensagemErro[5]

                        aNotasFaltando[Len(aNotasFaltando)][25] := aMensagemErro[6] //TENORIO
          
                        If Empty(aMensagemErro[1])

                            If aNotasFaltando[Len(aNotasFaltando)][10] == "0" .AND. aNotasFaltando[Len(aNotasFaltando)][12] == "3"
                                aNotasFaltando[Len(aNotasFaltando)][23] := "Devolução sem numero de controle"

                            ElseIf aNotasFaltando[Len(aNotasFaltando)][08] == "0" .AND. aNotasFaltando[Len(aNotasFaltando)][12] == "1"  //NDoc      //CodigoDocFiscal
                                aNotasFaltando[Len(aNotasFaltando)][23] := "Nota de Entrada que não é troca | sem numero e sem informações de integração"

                            Else
                                aNotasFaltando[Len(aNotasFaltando)][23] := "Mensagem de erro não encontrada | esse movimento ainda não chegou no PROTHEUS ou não foi encontrado nas tabelas de integração"
                            EndIf
                        EndIf

                    EndIf 

                Else

                    //TENORIO
                    //Valida se a SituacaoNFCe do TVFR é igual ao PROTHEUS (0=normal, 1=cancelado e 3=inutilizado)
                    If dadosLive[1][Item][2][1][15] <> dadosProtheus[1][nPosicao][2][1][15]

                        aAdd(aNotasFaltando,dadosLive[1][Item][2][1])
                        aNotasFaltando[Len(aNotasFaltando)][21] := "Nota/Cupom encontrado com SituacaoNFCe diferente"
                        //aNotasFaltando[Len(aNotasFaltando)][22] := "LIVE"

                        lSemControle := dadosLive[1][Item][1][nX] == "0" .AND. aNotasFaltando[Len(aNotasFaltando)][12] == "3"

                        If UPPER(ALLTRIM(aNotasFaltando[Len(aNotasFaltando)][1])) == "CUPOM" .AND. !lSemControle

                            cSerie               := aNotasFaltando[Len(aNotasFaltando)][7]
                            cSerie               := Iif(cSerie == "0", "", cSerie)
                            cSerialEquipamento   := aNotasFaltando[Len(aNotasFaltando)][6] 
                            cModelo              := aNotasFaltando[Len(aNotasFaltando)][9] 
                            cDoc                 := aNotasFaltando[Len(aNotasFaltando)][8]

                            cChave := cSerie + "|" + cSerialEquipamento + "|" + cModelo+ "|" + cDoc

                            aMensagemErro := BuscaMHQ(cChave, "VENDA", "LIVE")

                        ElseIf ALLTRIM(aNotasFaltando[Len(aNotasFaltando)][12]) == "3" .AND. !lSemControle
                            aMensagemErro := BuscaErroNotaDeEntradaLive(aNotasFaltando[Len(aNotasFaltando)][10],aNotasFaltando[Len(aNotasFaltando)][7],CTOD(SUBSTR(aNotasFaltando[Len(aNotasFaltando)][14],1,10)))

                            cSerie       := aNotasFaltando[Len(aNotasFaltando)][7]
                            Controle    := aNotasFaltando[Len(aNotasFaltando)][10]
                            DataEmissao := CTOD(SUBSTR(aNotasFaltando[Len(aNotasFaltando)][14],1,10))

                            cChave :=  "%|" + cSerie + "|" + Controle 

                            aMensagemErro := BuscaMHQ(cChave, "NOTA DE ENTRADA", "LIVE", .T., DataEmissao)

                        Else

                            cTipo        := IIF( ALLTRIM(UPPER(aNotasFaltando[Len(aNotasFaltando)][13])) == "ENTRADA", "NOTA DE ENTRADA", "NOTA DE SAIDA" )
                            DataEmissao := CTOD(SUBSTR(aNotasFaltando[Len(aNotasFaltando)][14],1,10))

                            cChave       := RmiDePaRet("LIVE", "SM0", aNotasFaltando[Len(aNotasFaltando)][04]) + "|" + aNotasFaltando[Len(aNotasFaltando)][08] + "|" + aNotasFaltando[Len(aNotasFaltando)][07] + "|" + aNotasFaltando[Len(aNotasFaltando)][20]

                            aMensagemErro := BuscaMHQ(cChave, cTipo, "PROTHEUS", .F., DataEmissao)
                        EndIf 

                        //Origem
                        If !Empty(aMensagemErro[7])
                            aNotasFaltando[Len(aNotasFaltando)][22] := aMensagemErro[7]
                        EndIf

                        aNotasFaltando[Len(aNotasFaltando)][23] := "SituacaoNFCe no TVFR " + dadosLive[1][Item][2][1][15] + " e no PROTHEUS " + dadosProtheus[1][nPosicao][2][1][15]
                        aNotasFaltando[Len(aNotasFaltando)][24] := aMensagemErro[5]
                        aNotasFaltando[Len(aNotasFaltando)][25] := aMensagemErro[6] //TENORIO
                        aNotasFaltando[Len(aNotasFaltando)][26] := dadosProtheus[1][nPosicao][2][1][26]  //Observação Fiscal
                    EndIf
                    //TENORIO

                    //-- se ja achei com uma chave não busco a proxima.
                    Exit
                EndIf 

            Next nX    

        EndIf 
        If Mod(Item, 1000) == 0   //TENORIO
            LjGrvLog("Conciliador ->"+ ProcName(),"Comparando do TVFR > Protheus" + cValToChar(Item) + " de " + cValToChar(nTamanhoItens) + "...")
        EndIf
    Next Item


Return aNotasFaltando

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} BuscaErroVenda
Static responsavel por buscar erros na integração

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function BuscaErroVenda(cDoc as character, cSerie as character, cSerialEquipamento as character, cModelo as character)

    Local cChave               as character

    Default cSerie := ""
    Default cSerialEquipamento := ""

    cSerie := Iif(cSerie == "0","",cSerie)

    cChave := cSerie + "|" + cSerialEquipamento + "|" + cModelo + "|" + cDoc    

Return BuscaMHQ(cChave, "VENDA","LIVE")

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} BuscaErroNotaDeEntradaLive
Static responsavel por buscar erros na integração

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function BuscaErroNotaDeEntradaLive(Controle as character, cSerie as character, DataEmissao as Date)

    Local cChave               as character
    cChave :=  "%|" + cSerie + "|" + Controle 

Return BuscaMHQ(cChave, "NOTA DE ENTRADA","LIVE",.T.,DataEmissao)

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} BuscaErroNotaDeEntradaSaidaProtheus
Static responsavel por buscar erros na integração

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function BuscaErroNotaDeEntradaSaidaProtheus(Filial as character, cDoc as character, cSerie as character, Cliente as character ,cTipo as character,DataEmissao as Date)

    Local cChave        as character
    Local aMensagemErro as Array

    cChave := Filial + "|" + cDoc + "|" + cSerie + "|" + Cliente
    cTipo := IIF(ALLTRIM(UPPER(cTipo)) == "ENTRADA","NOTA DE ENTRADA", "NOTA DE SAIDA")

    If Empty((aMensagemErro := NaoAtendeFiltro(cTipo,Filial,cDoc,cSerie))[1])
        aMensagemErro := BuscaMHQ(cChave, cTipo,"PROTHEUS",.F.,DataEmissao)
    EndIf 

Return aMensagemErro

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} NaoAtendeFiltro
Static responsavel por buscar erros na integração

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function NaoAtendeFiltro(cTipo as character,Filial as character,cDoc as character,cSerie as character) as Array

    Local aMensagemErro :=Array(7)     as Array //TENORIO
    //Local Filtro                       as character
    Local prefixo    := IIF(cTipo == "NOTA DE ENTRADA", "F1_","F2_")
    Local NomeTabela := GetNextAlias() as character
    Local cQuery     := ""             as character
    //TENORIO
    Local CampoExp   := Prefixo + "MSEXP"   as character
    Local ConteudoExp:= ""                  as character
    //TENORIO
    
    DBSelectArea("MHN")
    MHN->(DBSetOrder(1)) //MHN_FILIAL+MHN_COD
    
    If MHN->(DBSeek(xfilial("MHN") + PADR(cTipo,TAMSX3("MHN_COD")[1])))
        cQuery := ""
        //cQuery += " SELECT R_E_C_N_O_ "   TENORIO
        cQuery += " SELECT R_E_C_N_O_, " + CampoExp
        cQuery += " FROM " + RetSqlName( MHN->MHN_TABELA )
        cQuery += " WHERE "+ Prefixo + "FILIAL = '" + xFilial(MHN->MHN_TABELA,Filial) + "' "
        cQuery += " AND "  + Prefixo + "DOC = '" + cDoc + "' "
        cQuery += " AND "  + Prefixo + "SERIE = '" + cSerie + "' "
        cQuery += " AND "  + Alltrim(MHN->MHN_FILTRO)

        TCQUERY cQuery NEW ALIAS (NomeTabela)

        If (NomeTabela)->(EOF())
            //aMensagemErro  := Array(6)
            aMensagemErro[1] := "Filtro do Processo :[" + cTipo + "] não foi atendido, Filtro:[" + Alltrim(MHN->MHN_FILTRO) + "] "
            aMensagemErro[2] := ""
            aMensagemErro[3] := ""
            aMensagemErro[4] := ""
            aMensagemErro[5] := ""
            aMensagemErro[6] := ""  //TENORIO
            aMensagemErro[7] := ""  //TENORIO

            aMensagemErro[1] := StrTran(StrTran(aMensagemErro[1],","," |virgula| "),";"," |virgula| ")

        //TENORIO                
        Else

            ConteudoExp := &(NomeTabela + "->" + CampoExp)
        
            If !Empty(ConteudoExp) .And. ConteudoExp < "20200101"

                //aMensagemErro  := Array(6)
                aMensagemErro[1] := "Controle de Publicação: [" + cTipo + "] não foi atendido, " + CampoExp + ":[" + ConteudoExp + "] "
                aMensagemErro[2] := ""
                aMensagemErro[3] := ""
                aMensagemErro[4] := ""
                aMensagemErro[5] := ""
                aMensagemErro[6] := ""  //TENORIO
                aMensagemErro[7] := ""  //TENORIO

                aMensagemErro[1] := StrTran(StrTran(aMensagemErro[1],","," |virgula| "),";"," |virgula| ")
            EndIf
        //TENORIO
        EndIf  
    EndIf 

   (NomeTabela)->(dbcloseArea())
Return aMensagemErro

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} BuscaMHQ
Static responsavel por buscar erros na integração

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function BuscaMHQ(cChave as  character, Processo as character, Origem as character, lBuscaAproximada as logical, ApartirDe as date)
    
    Local NomeTabela    := GetNextAlias() as Character
    Local cQuery                          as character
    Local aMensagemErro := Array(7)       as Array      //TENORIO

    Default lBuscaAproximada := .F.
    Default ApartirDe := CTOD("")

    cQuery := " SELECT MHL_ALIAS, MHL_CODMEN, ISNULL(CONVERT(VARCHAR(8000), CONVERT(VARBINARY(8000), MHL_ERROR)),'') AS MHL_ERROR, MHL_CPROCE, MHQ_UUID, MHQ_DATGER, MHQ_ORIGEM "   //TENORIO
    cQuery += " FROM "+ RetSqlName( "MHQ" )+ " MHQ " 
    cQuery +=   " LEFT JOIN  " + RetSqlName( "MHL" ) + " MHL"
    cQuery +=       " ON MHQ.MHQ_UUID = MHL.MHL_UIDORI "
    cQuery +=           " AND MHL.D_E_L_E_T_ = ' '"
    cQuery += " WHERE MHQ.MHQ_CHVUNI " + IIF(lBuscaAproximada, "LIKE", "=") + " '" + cChave + "'"
    cQuery +=   " AND MHQ.MHQ_CPROCE = '" + Processo + "'"
    cQuery +=   " AND MHQ.MHQ_ORIGEM = '" + Origem + "'"
    If !Empty(ApartirDe)
        cQuery += " AND MHQ.MHQ_DATGER >= '" + DTOS(ApartirDe) + "'"
    EndIf
    cQuery +=   " AND MHQ.D_E_L_E_T_ = ' '"
    cQuery += " ORDER BY MHL.MHL_DATA DESC, MHL.MHL_HORA DESC"

    TCQUERY cQuery NEW ALIAS (NomeTabela)

    aMensagemErro[1] := ""
    aMensagemErro[2] := ""
    aMensagemErro[3] := ""
    aMensagemErro[4] := ""
    aMensagemErro[5] := ""
    aMensagemErro[6] := ""  //TENORIO
    aMensagemErro[7] := ""  //TENORIO

    If !(NomeTabela)->(EoF())
        aMensagemErro[1] := AllTrim((NomeTabela)->MHL_ERROR)
        aMensagemErro[2] := AllTrim((NomeTabela)->MHL_ALIAS)
        aMensagemErro[3] := AllTrim((NomeTabela)->MHL_CODMEN)
        aMensagemErro[4] := AllTrim((NomeTabela)->MHL_CPROCE)
        aMensagemErro[5] := AllTrim((NomeTabela)->MHQ_UUID)
        aMensagemErro[6] := DtoC( StoD( (NomeTabela)->MHQ_DATGER ) )  //TENORIO
        aMensagemErro[7] := AllTrim((NomeTabela)->MHQ_ORIGEM)  //TENORIO
    Else
    
        aMensagemErro[1] := "Registro não localizado nas tabelas de integração. chave buscada: [" + cChave + "]"
        aMensagemErro[1] += " - Query executada: " + cQuery  //TENORIO
    EndIf 

    aMensagemErro[1] := FwCutOff(StrTran(StrTran(aMensagemErro[1],","," |virgula| "),";"," |virgula| "))

    (NomeTabela)->(DBCloseArea())

return aMensagemErro

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} GerarCsv
Static responsavel por preparar os dados de resultado para salvar

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static Function GerarCsv(dados as array) as character
    Local linha := 1 as numeric
    Local coluna := 1 as numeric
    Local csv := "" as character

    For linha := 1 To Len(dados)
        For coluna := 1 To len(dados[linha])
            If Valtype(dados[linha][coluna]) == "N"
                csv += Alltrim(STR(dados[linha][coluna]))+ ","
            Else
                csv += dados[linha][coluna] + ","
            EndIf 
        Next coluna
        csv := SubString(csv,1,Len(csv)-1)
        csv += chr(13) + chr(10)
    Next linha

Return csv

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} SalvarCsv
Static responsavel por salvar arquivo CSV

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function SalvarCsv(csv as character, NomeArquivo, caminhoDoArquivo as character)
    
    Local Arquivo  := Nil as Object
    Local lRetorno := .T. as logical
    Local nRet     := 0   as numeric
    Local lRet     := .T. as logical

    Default NomeArquivo    := "ResultadoComparacao"
    
    If Empty(caminhoDoArquivo)
        caminhoDoArquivo     := "\AUTOCOM\"
    EndIf 
   
    If !Empty(caminhoDoArquivo)

        //Verifica se ja existe o diretório principal (Diretorio Pai)
        If !ExistDir(caminhoDoArquivo)
            nRet := MakeDir(caminhoDoArquivo)
            
            If nRet != 0
                LjGrvLog("Conciliador ->"+ ProcName(), "Não foi possível criar o diretório " + caminhoDoArquivo + ". Erro: " + cValToChar( FError() ) )
                lRet := .F.
            EndIf
        EndIf

        If lRet
            
            aadd(aAnexos,caminhoDoArquivo + NomeArquivo + ".csv")
            
            Arquivo := FWFileWriter():new(caminhoDoArquivo + NomeArquivo + ".csv")

            If Arquivo:Exists()
                If  !Arquivo:Erase()
                    LjGrvLog("Conciliador ->"+ ProcName(), "Não foi possivel excluir arquivo, motivo: [" + Iif(Valtype(Arquivo:error():Message) == "U",str(FError(),4),Arquivo:error():Message) + "]")
                EndIf 
            EndIf
            
            If lRetorno
            
                If (Arquivo:Create())
                    
                    Arquivo:Write(csv)

                Else 
                    LjGrvLog("Conciliador ->"+ ProcName(), "Não foi possivel criar o arquivo["+ caminhoDoArquivo + "ResultadoComparacao.csv" +"]" + " motivo: [" + Iif(Valtype(Arquivo:error():Message) == "U",str(FError(),4),Arquivo:error():Message) + "]") 
                Endif
            EndIf 

            Arquivo:Close()

        EndIf 
    EndIf 
 
Return

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} AnalisaSaltoNumeracao
Static responsavel por buscar e informar saltos encontrados no protheus

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function AnalisaSaltoNumeracao(aDados as Array)
    Local NumeroFiliais   := 1
    Local NumeroSerie     := 1
    Local NumeroDocumento := 1
    Local ProximoNumero   := 0
    Local aSaltos         := {}

    aSaltos := {{"Filial","Serie","Documento"}} 
    
    // -- Organiza as Filiais

    ASort(aDados, , , {|x,y|x[1] < y[1]})  

    For NumeroFiliais := 1 To Len(aDados)  
            
        // -- Organiza as Series
        ASort(aDados[NumeroFiliais][2], , , {|x,y|x[1] < y[1]}) 

        For NumeroSerie := 1 To Len(aDados[NumeroFiliais][2])  
            
            // -- Organiza Documento
            ASort(aDados[NumeroFiliais][2][NumeroSerie][2], , , {|x,y|x[1] < y[1]}) 
            ProximoNumero  := 0
            PrimeiroNumero := aDados[NumeroFiliais][2][NumeroSerie][2][1][1]
            UltimoNumero   := aDados[NumeroFiliais][2][NumeroSerie][2][Len(aDados[NumeroFiliais][2][NumeroSerie][2])][1]
            For NumeroDocumento := 1 To Len(aDados[NumeroFiliais][2][NumeroSerie][2]) 
                
                If aDados[NumeroFiliais][2][NumeroSerie][2][NumeroDocumento][2]
                    Steep := 2
                Else 
                    Steep := 1
                EndIf 

                If aDados[NumeroFiliais][2][NumeroSerie][2][NumeroDocumento][1] == PrimeiroNumero
                    ProximoNumero := aDados[NumeroFiliais][2][NumeroSerie][2][NumeroDocumento][1] + Steep
                    Loop
                EndIf 

                If aDados[NumeroFiliais][2][NumeroSerie][2][NumeroDocumento][1] == ProximoNumero 
                    ProximoNumero := aDados[NumeroFiliais][2][NumeroSerie][2][NumeroDocumento][1] + Steep
                    Loop
                ENdIf 
                
                While aDados[NumeroFiliais][2][NumeroSerie][2][NumeroDocumento][1] <> ProximoNumero  
                    //Conout("Filial: " + cValtoChar(aDados[NumeroFiliais][1]) + " Serie: " + cValtoChar(aDados[NumeroFiliais][2][NumeroSerie][1])  + " Documento: " + cValtoChar(ProximoNumero))
                    aAdd(aSaltos,{cValtoChar(aDados[NumeroFiliais][1]),cValtoChar(aDados[NumeroFiliais][2][NumeroSerie][1]),cValtoChar(ProximoNumero)})
                    ProximoNumero++
                EndDo

                ProximoNumero := aDados[NumeroFiliais][2][NumeroSerie][2][NumeroDocumento][1] + Steep
                
            Next NumeroDocumento

        Next NumeroSerie

    Next Filiais

Return aSaltos

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} BuscaErroVenda
Static responsavel por remover erros conhecidos dos saltos

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function RemoveErrosdoSalto(aSaltos,diferencasConsolidado)

    Local nItem             := 0 
    Local cFilialProtheus   := "" 
    Local cSerie            := ""
    Local cSql              := "SELECT F3_FILIAL, F3_SERIE, F3_NFISCAL FROM " + RetSqlName("SF3")
    Local cWhere            := ""
    Local aSql              := {}
    Local aAuxSaltos        := {}

   
    For nItem := 2 To Len(diferencasConsolidado)
        
        If Len(diferencasConsolidado[nItem][4]) > 2 
            cFilialProtheus := RmiDePaRet("LIVE", "SM0", diferencasConsolidado[nItem][4], .F.)
        Else
            cFilialProtheus := diferencasConsolidado[nItem][4]
        EndIf 

        If Empty(diferencasConsolidado[nItem][7])
            cSerie := diferencasConsolidado[nItem][6]
        Else
            cSerie := diferencasConsolidado[nItem][7]
        EndIf 

        //Removo um erro conhecido
        //If (nPos := aScan(aSaltos,{|x|  cFilialProtheus +  cSerie + diferencasConsolidado[nItem][8] == x[1] + x[2] + x[3] })) > 0 
        If (nPos := aScan(aSaltos, {|x|  x[1] == cFilialProtheus .And. x[2] == cSerie .And. Val(x[3]) == Val(diferencasConsolidado[nItem][8])} ) ) > 0 

            ADel( aSaltos, nPos)
            ASize( aSaltos, Len(aSaltos) - 1 )
        EndIf


    Next nItem

    //Remove notas encontras no PROTHEUS
    For nItem:=2 To Len(aSaltos)

        cWhere :=   " WHERE D_E_L_E_T_ = ' '"
        cWhere +=   " AND F3_FILIAL = '" + aSaltos[nItem][1] + "'"
        cWhere +=   " AND F3_SERIE = '" + aSaltos[nItem][2] + "'"
        cWhere +=   " AND CAST(F3_NFISCAL AS INT) = " + cValToChar( Val(aSaltos[nItem][3]) )

        aSql := RmiXSql(cSql + cWhere, "*", /*lCommit*/, /*aReplace*/)

        If Len(aSql) == 0
            AADD( aAuxSaltos, aSaltos[nItem] )
        EndIf
    Next nItem
    FwFreeArray(aSql)


return aAuxSaltos

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} ObterDadosLive
Static responsavel por startar os fluxo de conciliador, solicitando ao assiante externo a geração dos arquivos de conciliador

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static Function ObterDadosLive(aTicket)
       
    Local cDtFim               as character
    Local cDtInicial           as character
    Local nRetroagir           as numeric
    Local dDataBaseConc        as date
    Local aConsulta            as array
    Local aDadosConector := {} as array

    // -- Se receber o ticket realiza as busca com base no ticket recebido, se não receber cria um nova MHQ/MHR
    If Valtype(aTicket) == "A" .AND. Len(aTicket) >= 3 .AND. !Empty(aTicket[1]) .AND. !Empty(aTicket[2]) .AND. !Empty(aTicket[3])
        cTicket    := aTicket[1]
        cDtFim     := aTicket[3]
        cDtInicial := aTicket[2]
    Else
        
        cTicket := RMITImeStamp() 

        If oBuscaObj:OCONFPROCE:hasProperty("dataInicial") .And. oBuscaObj:OCONFPROCE:hasProperty("dataFinal")
            
            cDtFim := oBuscaObj:OCONFPROCE["dataFinal"]
            
            If Empty(cDtFim)
                cDtFim :=  subStr(DTOS(date() -1),1,4) + "-" + subStr(DTOS(date() -1),5,2) + "-" + subStr(DTOS(date() -1),7,2)
            EndIf 
            
            cDtInicial := oBuscaObj:OCONFPROCE["dataInicial"]
        Else
            
            If oBuscaObj:OCONFPROCE:hasProperty("diasParaRetroagir")
                nRetroagir := oBuscaObj:OCONFPROCE["diasParaRetroagir"]
            Else
                nRetroagir := 30 // --Se não tiver a configuração retroage 30 dias
            EndIf 
            
            dDataBaseConc := date() -1

            cDtFim := subStr(DTOS(dDataBaseConc),1,4) + "-" + subStr(DTOS(dDataBaseConc),5,2) + "-" + subStr(DTOS(dDataBaseConc),7,2)
            cDtInicial := subStr(DTOS(dDataBaseConc -  nRetroagir),1,4) + "-" + subStr(DTOS(dDataBaseConc -  nRetroagir),5,2) + "-" + subStr(DTOS(dDataBaseConc -  nRetroagir),7,2)
        
        EndIf 


        RmiExeGat("CONFERENCIA", "2", {cTicket,cDtFim,cDtInicial})


    EndIf  

    dDtFim          := STOD(StrTran(cDtFim , "-", ""))
    dDtInicial      := STOD(StrTran(cDtInicial , "-", ""))

    If (aConsulta := Consulta())[1]
        aDadosConector := RecuperarConferencia()
    Else
        oBuscaObj:cConfirma := aConsulta[2] 
        oBuscaObj:Confirma()
        cTicket := ""
    EndIf 

Return aDadosConector

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} Consulta
Static responsavel por consultar a preparação dos movimentos

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function Consulta()  as Array
    
    Local nTimer            := seconds()      as numeric
    Local cQuery            := ""             as character
    Local NomeTabela        := GetNextAlias() as Character
    Local nTentativa        := 1              as numeric
    Local lRetorno          := .F.            as logical
    Local nAguarda          := 3000           as numeric
    Local nMaximaTentativas := 1200           as numeric
    Local oXml                                as Object
    Local cTicketAberto     := ""             as Character
    Local cError                              as Character
    Local cWarning                            as Character

    // -- Aguarda pelomenos (nAguarda)5 minutos antes de inicar a primeira consulta
    LjGrvLog("Conciliador ->"+ ProcName(),"Iremos aguardar:[" + cValtoChar((nAguarda / 1000) / 60) + "] minutos ate a primeira consulta de dados") 
    Sleep(nAguarda)
   
    cQuery :=   " SELECT MHQ_STATUS "
    cQuery +=   " 	 , MHR_STATUS "
    cQuery +=   "    , CAST( MHQ_MENSAG AS VARCHAR(8000) ) AS MHQ_MENSAG  "
    cQuery +=   "	 , CAST( MHR_ENVIO AS VARCHAR(8000) ) AS MHR_ENVIO "
    cQuery +=   "	 , CAST( MHR_RETORN AS VARCHAR(8000) ) AS MHR_RETORN "
    cQuery +=   " FROM " + RetSqlName( "MHQ" ) + " MHQ "
    cQuery +=   " LEFT JOIN " + RetSqlName( "MHR" ) + " MHR ON MHR.MHR_FILIAL = MHQ.MHQ_FILIAL "
    cQuery +=   "	 AND MHR.MHR_UIDMHQ = MHQ.MHQ_UUID "
    cQuery +=   "	 AND MHR.D_E_L_E_T_ = MHQ.D_E_L_E_T_ "
    cQuery +=   " WHERE MHQ.MHQ_ORIGEM = 'PROTHEUS' "
    cQuery +=   "	 AND MHQ.MHQ_CPROCE = 'CONFERENCIA' "
    cQuery +=   "	 AND MHQ.MHQ_CHVUNI = '" + cTicket + "' "
    cQuery +=   "	 AND MHQ.D_E_L_E_T_ = '' "

    While nTentativa <= nMaximaTentativas

        LjGrvLog("Conciliador ->"+ ProcName(),"Tentativa:[" + cValtoChar(nTentativa) + "] de:[" + cValtoChar(nMaximaTentativas) + "]") 
    
        If nTentativa > 1
            (NomeTabela)->(DBCloseArea())
        EndIf 

        TCQUERY cQuery NEW ALIAS (NomeTabela)
        
        If Empty((NomeTabela) ->(MHR_STATUS)) .Or. (NomeTabela) ->(MHR_STATUS) == "6" // -- Não enviado ou aguardando processamento
            // -- Aguardando  processamento da integração
           
            LjGrvLog("Conciliador ->"+ ProcName(),"Iremos aguardar:[" + cValtoChar((nAguarda / 1000) / 60) + "] minutos ate a proxima tentativa. Motivo: MHR_STATUS == 6 - Aguardando processamento ou MHR ainda não criada") 
                   
            Sleep(nAguarda) 
            nTentativa ++ 
            Loop
        Else
            If (NomeTabela) ->(MHR_STATUS) == "3"

                                
                oXml := XmlParser((NomeTabela) ->(MHR_RETORN), "_", @cError, @cWarning)

                If oXml == nil
                    LjGrvLog("Conciliador ->"+ ProcName(),"Não foi possivel realizar a busca dos dados para o conciliador, motivo:[" + cError + "]") 
                Else
                    // Ticket que será fechado 
                    cTicketAberto := oXml:_LC_RETORNOCONCILIADOR:_NUMEROTICKET:TEXT
                    LjGrvLog("Conciliador ->"+ ProcName(),"Existe um ticket em abarto, para seguir com o processamento deveremos fechar ele para que seja possivel processar na proxima execução do conciliador. ticket:[" +cTicketAberto + "]")
                EndIf 

                Exit
            Elseif (NomeTabela) ->(MHR_STATUS) == "2"
                lRetorno := .T.
                Exit
            Else 
                
                LjGrvLog("Conciliador ->"+ ProcName(),"Iremos aguardar:[" + cValtoChar((nAguarda / 1000) / 60) + "] minutos ate a proxima tentativa. Motivo: MHR_STATUS Desconhecido:["+  (NomeTabela) ->(MHR_STATUS) +"]")           

                Sleep(nAguarda) 
                nTentativa ++ 
                Loop
            EndIf 
        Endif 

    EndDo

    (NomeTabela)->(DBCloseArea())

    LjGrvLog("Conciliador ->"+ ProcName(),"Tempo para preparar os dados no TOTVS Conector (resposta do ManterConciliadorLC com movimentos disponiveis) " + str(seconds()-nTimer,12,3)) 

Return {lRetorno,cTicketAberto}


//-------------------------------------------------------------------------------------
/*/{Protheus.doc} RecuperarConferencia
Static responsavel por buscar movimentação de conciliador

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static Function RecuperarConferencia() as Array

    Local cBody    := ""  as character
    Local cData    := ""  as character
    Local nPagina  := 0   as numeric
    Local Item     := 0   as numeric
    Local cToken   := ""  as character
    Local lHasNext := .F. as logical
    Local aDados   := {}  as array
    Local oWs             as Object
    Local cError   := ""  as character
    Local cWarning        as Character
    Local oXml            as Object
    
    
    oBuscaObj:PreExecucao()
    cToken := oBuscaObj:cToken
    cURl := oBuscaObj:oConfAssin["url_token"]

    oWs    := RMIConWsdl(cURl, @cError) 

        //Seta a operação que será executada
    If !oWs:SetOperation( "RecuperarConciliadorVendaLC_Integracao_Xml" )   
        LjGrvLog("Conciliador ->"+ ProcName(), I18n("#1 Problema ao efetuar o #2: #3", {ProcName(), "SetOperation", oWs:cError} )) 
    Else

        While lHasNext .Or. nPagina == 0
            
            nPagina++

            cBody := '<?xml version="1.0" encoding="UTF-8"?>'
            cBody += '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:liv="http://LiveConnector/">
            cBody += '    <soapenv:Header/>
            cBody += '    <soapenv:Body>
            cBody += '        <liv:RecuperarConciliadorVendaLC_Integracao_Xml>
            cBody += '            <liv:codigoSistemaSatelite>' + oBuscaObj:oConfAssin["sistemasatelite"] + '</liv:codigoSistemaSatelite>'
            cBody += '            <liv:xmlIdentificacao><![CDATA[<LC_Identificacao>
            cBody += '                            <Chave>' + cToken + '</Chave>
            cBody += '                            <CodigoSistemaSatelite>' + oBuscaObj:oConfAssin["sistemasatelite"] + '</CodigoSistemaSatelite>
            cBody += '                            </LC_Identificacao>]]></liv:xmlIdentificacao>
            cBody += '            <liv:numeroTicket>' + cTicket + '</liv:numeroTicket>
            cBody += '            <liv:pagina>' + cValtochar(nPagina) + '</liv:pagina>
            cBody += '        </liv:RecuperarConciliadorVendaLC_Integracao_Xml>
            cBody += '    </soapenv:Body>
            cBody += '</soapenv:Envelope> 

            cBody := EnCodeUtf8(cBody)

            If oWs:SendSoapMsg(cBody)
                cRetorno := oWs:GetSoapResponse()
                
                LjGrvLog("Conciliador ->"+ ProcName(),"Inicio de tratamento de retorno do conector")

                cRetorno := StrTran(cRetorno , "&lt;", "<")
                cRetorno := StrTran(cRetorno , "&gt;", ">")
                cRetorno := StrTran(cRetorno , "&#xD;", "")

                LjGrvLog("Conciliador ->"+ ProcName(),"Fim de tratamento de retorno do conector")

                oXml := XmlParser(cRetorno, "_", @cError, @cWarning)

                If oXml <>  nil

                    oDados := oXml:_S_ENVELOPE:_S_BODY:_RECUPERARCONCILIADORVENDALC_INTEGRACAO_XMLRESPONSE:_RECUPERARCONCILIADORVENDALC_INTEGRACAO_XMLRESULT:_LC_TICKETCONCILIADORVENDA
                    
                    If XmlChildEx( oDados:_DOCUMENTOS, "_LC_CONCILIADORMOVIMENTO" ) <> Nil

                        lHasNext := IIf(Upper(oDados:_HASNEXT:TEXT) == "TRUE",.T.,.F.)
                        nItens := Len(oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO)

                        LjGrvLog("Conciliador ->"+ ProcName(),"Processando Dados conector... " + cValToChar(1) + " de " + cValToChar(nItens) + "...")

                        For Item := 1 To nItens 
                            
                            aAdd(aDados,{})

                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_Tipo:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_Ticket:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_SituacaoTicket:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_CodigoLoja:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_CNPJ:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_NumeroImpressora:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_Serie:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_Ndoc:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_ModeloFiscal:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_Controle:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_ChaveDoc:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_CodigoDocFiscal:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_DocFiscal:TEXT)
                            
                            cData := oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_DataEmissao:TEXT
                            cData := DTOC(STOD(strTran( SubStr( cData, 1,AT("T",cData) - 1 ), "-","" )))

                            aAdd(aDados[Len(aDados)],cData)
                            
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_SituacaoNFCe:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_Item:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_CodProduto:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_Quantidade:TEXT)
                            aAdd(aDados[Len(aDados)],oDados:_DOCUMENTOS:_LC_CONCILIADORMOVIMENTO[Item]:_ValorTotalBruto:TEXT)

                        If Mod(Item, 1000) == 0  
                            LjGrvLog("Conciliador ->"+ ProcName(),"Processando Dados Conector... " + cValToChar(Item) + " de " + cValToChar(nItens) + "...")
                        EndIf
                        
                        Next

                    Else
                        LjGrvLog("Conciliador ->"+ ProcName(),"Nenhum dados(Cupom/Nota) encontrado no período informado")    
                    EndIf 

                EndIf 
            Else
                LjGrvLog("Conciliador ->"+ ProcName(), I18n("#1 Problema ao efetuar o #2: #3", {ProcName(), "SendSoapMsg", oWs:cError} )    ) 
            EndIf 

        Enddo

    EndIF 

    LjGrvLog("Conciliador ->"+ ProcName(),"Quantidade de dados recebidos pelo Conector:[" + cValToChar(Len(aDados)) + "]")
    
Return aDados

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} EnviaEmail
Static responsavel por enviar email

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static Function EnviaEmail(cPara, cAssunto, cCorpo, aAnexos)

Return GPEMail(cAssunto, cCorpo, cPara, aAnexos)

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} Consolidado
Static responsavel por gerar informações consolidadas para enviar no corpo do e-mail

@type       Static
@author     Lucas Novais (lnovais@)
@since      08/03/2023
@version    12.1.2310
/*/
//-------------------------------------------------------------------------------------

Static function Consolidado(aDiferencasConsolidado,cCaminhoQuery)
    Local aCampos    := {}                       as Array
    Local nCampo     := 0                        as numeric
    Local oTempTable := FWTemporaryTable():New() as object
    Local cAlias     := ""
    Local nItem      := 1
    Local cQuery     := ""
    Local oFile      := Nil
    Local NomeTabela        := GetNextAlias() as Character
    Local cRetorno := ""

    oFile := FWFileReader():New(cCaminhoQuery + "QueryConsolidadoConciliador.sql")

    If (oFile:Open())

        For nCampo := 1 To Len(aDiferencasConsolidado[1])
            aDiferencasConsolidado[1][nCampo] := SubStr(aDiferencasConsolidado[1][nCampo],1,10)
            If aDiferencasConsolidado[1][nCampo] == "DataEmissa"
                aAdd(aCampos,{aDiferencasConsolidado[1][nCampo],"D",8,0})
            Else
                aAdd(aCampos,{aDiferencasConsolidado[1][nCampo],"C",254,0})
            EndIf
        Next 

        oTempTable:SetFields( aCampos )
        oTempTable:Create()
        
        cAlias := oTempTable:GetAlias()
        
        For nItem := 2 To Len(aDiferencasConsolidado)
            RecLock(cAlias, .T.)
                For nCampo := 1 To Len(aCampos)
                    (cAlias)->&(aCampos[nCampo][1]) := Iif(aCampos[nCampo][2] == "D",CTOD(aDiferencasConsolidado[nItem][nCampo]),;
                    Iif(Valtype(aDiferencasConsolidado[nItem][nCampo]) == "N",CVALTOCHAR(aDiferencasConsolidado[nItem][nCampo]),aDiferencasConsolidado[nItem][nCampo]))
                Next nCampo
            (cAlias)->(MsUnLock())
        Next nItem  
                
        While (oFile:hasLine())
            cQuery += oFile:GetLine() + CHR(13) + CHR(10)
        End

        oFile:Close()
    
        cQuery := StrTran(cQuery,"TabelaResultado",oTempTable:GetRealName())

        TCQUERY cQuery NEW ALIAS (NomeTabela)
        
        aStruct := Dbstruct(NomeTabela)
        
        If !(NomeTabela)->(EoF())
            cRetorno += '<table border="1">'
            cRetorno += '<tr>'
            
            For nCampo := 1 To Len(aStruct)
                cRetorno +=  "<td>" + Alltrim(aStruct[nCampo][1]) + "</td>"
            Next nCampo
            
            cRetorno += '</tr>'

            While !(NomeTabela)->(EoF())
                
                cRetorno += '<tr>'
                
                For nCampo := 1 To Len(aStruct)
                    cRetorno += "<td>" + Alltrim(Iif(Valtype((NomeTabela)->&(aStruct[nCampo][1])) == "C",(NomeTabela)->&(aStruct[nCampo][1]),cValtoChar((NomeTabela)->&(aStruct[nCampo][1])))) + "</td>"
                Next nCampo

                cRetorno += '</tr>'

                (NomeTabela)->(DbSkip())
            End

            cRetorno += '</table>'
        EndIf

        (NomeTabela)->(DBCloseArea()) 
        oTempTable:Delete()
    
    Endif
    
Return cRetorno
