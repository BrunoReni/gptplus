#include "tlpp-core.th"
#include "totvs.ch"
#include "backoffice.reconciliation.matchprocessing.data.protheus.ch"

namespace totvs.protheus.backoffice.reconciliation.matchprocessing
using namespace totvs.protheus.backoffice.reconciliation.util

static nTamRegMat
static nTamSeqMat
static nTamDesMat
static nTamCodcon
static _lPostgres
static _lOracle
static _nTamUUID := 36 //Fixo para remover RTRIM da regra de match
static _lCpoIdCOnc
static _cCpoEntidades
//-------------------------------------------------------------------
/*/{Protheus.doc} MatchProcessingProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class MatchProcessingProtheusData from FWAdapterBaseV2
    Public  method new()    
    Public  method postByBody()
    Public  method tcRetWhere()
    Public  method tcRetSQLExpression()
    Private method tcPrepareTemp()    
    Private method tcExecSQLExpress()    
    Private method tcRetTable()    
    Private method tcCriaProcMatch()
    Private method tcChavtoVar()
    Private method tcCondtoVar()
    Private method tcProcMatch()
    Private method tcProcDeclare()
    Private method tcCondUpdate()    
    Private method tcLoadTamSX()
    Private method tcQueryUnion()
    Private method tcRetQuery()    
    Private method tcRetSelectUnion()
    Private method tcRetUnion()
    Private method tcValidFields()
    Static  method getData() As object
endclass

/*/{Protheus.doc} MatchProcessingProtheusData
Metodo construtor

@author Totvs
/*/
method new(cVerbo, lList) Class MatchProcessingProtheusData
    Default cVerbo := "POST"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

/*/{Protheus.doc} MatchProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
method getData() class MatchProcessingProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := MatchProcessingProtheusData():new()
    EndIf
return __oActiveData

/*/{Protheus.doc} getByBody
Metodo responsável pela busca das configuracoes de acordo com as filiais
informadas

@author Totvs
/*/
method postByBody(jBody as Json) class MatchProcessingProtheusData
Local cReturn := "" as Character
Local cTableOri := "" as Character
Local cTableDes := "" as Character
Local lProgress as logical
Local aResponse := {} as Array

cReturn := ::tcPrepareTemp(jBody,@lProgress,@cTableOri,@cTableDes)

If lProgress    
    aAdd(aResponse, .T.)
    aAdd(aResponse, '{"tabori": "'+cTableOri+'", "tabdes": "'+cTableDes+'"}')
Else   
    aAdd(aResponse, .F.)
    aAdd(aResponse, cReturn)        
Endif
 
return aResponse

/*/{Protheus.doc} prepareTemp
    Prepare temp table for use
    @author TOTVS
    @since 29/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcPrepareTemp(jBody as Json,lProgress as Logical, cTableOri as Character, cTableDes as Character) class MatchProcessingProtheusData
Local cCodCfg as Character
Local jHeaders := JsonObject():new() as Json
Local jRegrasMatch := JsonObject():new() as Json
Local jUnion    := JsonObject():new() as Json
Local jTotal    := JsonObject():new() as Json
Local cAliasOri := "" as Character
Local cAliasDes := "" as Character
Local cSQLSelOri:= "" as Character
Local cSQLSelDes:= "" as Character
Local cWhereOri := "" as Character
Local cWhereDes := "" as Character
Local cError    := "" as Character
Local cReturn   := "" as Character
Local cCpoIdOri := "" as Character
Local cCpoIdDes := "" as Character
Local cView     := "" as Character
Local cOriLink  := "" as Character
Local cDesLink  := "" as Character
Local cCondition:= "" as Character
Local lAutomato := .F. as Logical
Local uRet as variant
Local cMatchOrd := "" as Character
Local nI := 0 as Numeric

DEFAULT cTableOri := ""
DEFAULT cTableDes := ""

cCodCfg   := jBody["codcfg"]
cView     := If(Valtype(jBody["view"]) == "C", jBody["view"], "0")
lAutomato := (ValType(jBody["robo"])<>"U")
lProgress := ValType(cCodCfg)=="C"

If _lPostgres == NIL
    _lPostgres := IIf(Alltrim(TcGetDB()) $ "POSTGRES", .T., .F.)
EndIf

_lOracle := IIf(_lOracle == Nil, AllTrim(TcGetDB()) $ "ORACLE", _lOracle)

If _lCpoIdCOnc == NIL
    _lCpoIdCOnc := (CT2->(FieldPos("CT2_IDCONC"))>0)
EndIf

If lProgress
    QLB->(dbSetOrder(1))
    If QLB->(dbSeek(FWxFilial("QLB")+cCodCfg))

        uRet := jHeaders:FromJson(AllTrim(QLB->QLB_FIELDS))        
        lProgress := ValType(uRet) == "U"

        //Monta o Select da Query
        If lProgress
            cAliasOri := QLB->QLB_TABORI
            cAliasDes := QLB->QLB_TABDES

            If Empty(QLB->QLB_CIDORI)
                lProgress := .F.
            Else
                cCpoIdOri := QLB->QLB_CIDORI
            EndIf

            If Empty(QLB->QLB_CIDDES)
                lProgress := .F.
            Else
                cCpoIdDes := QLB->QLB_CIDDES
            EndIf

            If lProgress
                uRet := jRegrasMatch:FromJson(AllTrim(QLB->QLB_REGMAT))
                jTotal:FromJson(AllTrim(QLB->QLB_TOTAL))
                lProgress := ValType(uRet) == "U"               
            EndIf

            If lProgress
                //Validacao de campos para query
                ::tcValidFields(jHeaders, jRegrasMatch)
                
                If QLB->(FieldPos("QLB_TABGRP"))
                    jUnion:fromJson(AllTrim(QLB->QLB_TABGRP))                    
                EndIf                
            
                If jUnion["unionori"] <> NIL
                    cSQLSelOri := ::tcQueryUnion(cCodCfg, '1', cCpoIdOri, cAliasOri, cView, jUnion["unionori"], jHeaders['data_ori'], jBody, @cMatchOrd)
                Else
                    cSQLSelOri := ::tcRetQuery(cCodCfg, jHeaders, cCpoIdOri, cAliasOri, '1')                    
                EndIf

                If jUnion["uniondes"] <> NIL
                    cSQLSelDes := ::tcQueryUnion(cCodCfg, '2', cCpoIdDes, cAliasDes, cView, jUnion["uniondes"], jHeaders['data_des'], jBody)
                Else
                    cSQLSelDes := ::tcRetQuery(cCodCfg, jHeaders, cCpoIdDes, cAliasDes, '2')
                EndIf
            Else
                cReturn := STR0001 //"Preencher o campo QLB_CIDORI ou QLB_CIDDES"
            EndIf

            If lProgress
                For nI := 1 to Len(jRegrasMatch["rules"])
                    //A validação é feita somente quando existe tabela de link = CV3 e se o RTRIM() é utilizado nos campos de UUID
                    If jRegrasMatch["rules"][nI]["rule"]["ori_link"] <> NIL
                        cOriLink   := Upper(jRegrasMatch["rules"][nI]["rule"]["ori_link"])
                    EndIf
                    
                    If jRegrasMatch["rules"][nI]["rule"]["des_link"] <> NIL
                        cDesLink   := Upper(jRegrasMatch["rules"][nI]["rule"]["des_link"])
                    EndIf

                    If jRegrasMatch["rules"][nI]["rule"]["condition"] <> NIL
                        cCondition := Upper(jRegrasMatch["rules"][nI]["rule"]["condition"])
                    EndIf

                    If  "RTRIM(CV3_ID" $ cOriLink  .Or.;
                        "RTRIM(CV3_ID" $ cDesLink  .Or.;
                        "RTRIM(CV3_ID" $ cCondition

                        If !Empty(cOriLink)
                            cOriLink := StrTran(cOriLink,"RTRIM(CV3_IDORIG)","CV3_IDORIG")
                            cOriLink := StrTran(cOriLink,"RTRIM(CV3_IDDEST)","CV3_IDDEST")
                            jRegrasMatch["rules"][nI]["rule"]["ori_link"]  := cOriLink
                        EndIf

                        If !Empty(cDesLink)
                            cDesLink := StrTran(cDesLink,"RTRIM(CV3_IDORIG)","CV3_IDORIG")
                            cDesLink := StrTran(cDesLink,"RTRIM(CV3_IDDEST)","CV3_IDDEST")
                            jRegrasMatch["rules"][nI]["rule"]["des_link"]  := cDesLink
                        EndIf

                        If !Empty(cCondition)
                            cCondition := StrTran(cCondition,"RTRIM(CV3_IDORIG)","CV3_IDORIG")
                            cCondition := StrTran(cCondition,"RTRIM(CV3_IDDEST)","CV3_IDDEST")
                            jRegrasMatch["rules"][nI]["rule"]["condition"] := cCondition  
                        EndIf
                                           
                    EndIf                    
                Next nI
            EndIf
        Else            
            cReturn := STR0002 //"Campo QLB_FIELDS incorreto no cadastro"
        EndIf

        //Monta o Where de acordo com o filtro recebido
        If lProgress
            If jUnion["unionori"] == NIL
                cWhereOri := ::tcRetWhere(jBody["tabori"], cView, "1", cAliasOri,"01", cCpoIdOri,, cCodCfg)
            EndIf

            If jUnion["uniondes"] == NIL                
                cWhereDes := ::tcRetWhere(jBody["tabdes"], cView, "2", cAliasDes,"01", cCpoIdDes,, cCodCfg)    
            EndIf

            //Monta as temporárias             
            cError := ::tcExecSQLExpress(cSQLSelOri+cWhereOri,@cTableOri,lAutomato,.T.,cCpoIdOri)          
            If Empty(cError)                
                cError += ::tcExecSQLExpress(cSQLSelDes+cWhereDes,@cTableDes,lAutomato,,cCpoIdDes)                
                If !Empty(cError)   
                    cError += tcDropTable(cTableOri)
                    lProgress := .F.
                    cReturn := cError                    
                Else
                    cError := ::tcProcMatch(cAliasOri,cAliasDes,cTableOri,cTableDes,cCpoIdOri,cCpoIdDes,jRegrasMatch,cMatchOrd,jTotal)
                    If !Empty(cError)
                        cReturn := cError
                        lProgress := .F.
                    EndIf
                EndIf
            Else
                lProgress := .F.
                cReturn := cError
            EndIf        
        EndIf    
    Else
        lProgress := .F. 
        cReturn := STR0003 //"A configuracao informada não existe"
    EndIf
Else
    cReturn := STR0004 //"Propriedade codcfg não informada ou inválida"
EndIf    

Return cReturn

/*/{Protheus.doc} tcRetSQLExpression
    @author TOTVS
    @since 29/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcRetSQLExpression(aSQLArr as Array, cSeparator as Character, cCpoIDCon as Character,; 
                            lCabec as Logical, lExcel As logical, cAlias as Character) class MatchProcessingProtheusData
Local cRet      := "" as Character
Local cConcat   := "" as Character
Local nI        := 0 as Numeric

DEFAULT aSQLArr    := {}
DEFAULT cSeparator := ""
DEFAULT cCpoIDCon  := ""
DEFAULT lCabec     := .F.
DEFAULT lExcel     := .F.
DEFAULT cAlias     := ""

cConcat :=  tcRetConcat()

If !lCabec
    tcProcessLGPD(aSQLArr)
EndIf

For nI := 1 to Len(aSQLArr)  
    If nI > 1
        cRet += cSeparator
    EndIf
    cRet += aSQLArr[nI]    
Next

If !Empty(cRet) .And. !Empty(cCpoIDCon)    
    cRet += cSeparator+"COALESCE(CAST("+cCpoIDCon+" AS VARCHAR("+cValToChar(_nTamUUID)+")), ' ') "+cCpoIDCon            
EndIf

If !lExcel 
    If lCabec

        If "CT2"$cCpoIDCon .And. _lCpoIdCOnc
            cRet += cSeparator+" CT2_IDCONC "
        EndIf
        cRet += cSeparator+" TABELA "
        cRet += cSeparator+" REGMATCH "    
        cRet += cSeparator+" DESMATCH "
        cRet += cSeparator+" SEQMATCH "    
        cRet += cSeparator+" CODCON "
        cRet += cSeparator+" IDDELETE "
        cRet += cSeparator+" RECONCILED "
        cRet += cSeparator+" IDMATCH "
        cRet += cSeparator+" COMPARISON "
    Else
        ::tcLoadTamSX()

        If "CT2"$cCpoIDCon .And. _lCpoIdCOnc
            cRet += cSeparator+" CT2_IDCONC "
        EndIf
        cRet += cSeparator+" '"+cAlias+"' TABELA "
        cRet += cSeparator+" COALESCE(QLD_REGMAT,'"+Space(nTamRegMat)+"') REGMATCH "    
        cRet += cSeparator+" COALESCE(QLD_DESMAT,'"+Space(nTamDesMat)+"') DESMATCH "
        cRet += cSeparator+" COALESCE(QLD_SEQMAT,'"+Space(nTamSeqMat)+"') SEQMATCH "    
        cRet += cSeparator+" COALESCE(QLD_CODCON,'"+Space(ntamCodCon)+"') CODCON "
        cRet += cSeparator+" '"+Space(nTamRegMat+nTamSeqMat)+"' IDDELETE "
        cRet += cSeparator+" CASE WHEN QLD_SEQMAT <> '"+Space(nTamSeqMat)+"' THEN 'S' ELSE 'N' END RECONCILED "
        cRet += cSeparator+" COALESCE(QLD_REGMAT " + cConcat + " QLD_SEQMAT, '"+Space(nTamRegMat+nTamSeqMat)+"') IDMATCH "
        If QLD->(FieldPos("QLD_COMPAR"))
            cRet += cSeparator+" CASE WHEN QLD_COMPAR = 'AD' THEN 'AD' WHEN QLD_COMPAR = 'MD' THEN 'MD' ELSE 'N' END COMPARISON "
        Else
            cRet += cSeparator+" ' ' COMPARISON "
        EndIf
    EndIf
EndIf

Return cRet

/*/{Protheus.doc} tcRetWhere
    @author TOTVS
    @since 30/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcRetWhere(aWhereArr as Array, cView as Character, cTipItem as Character, cAliasQry as Character,;
                  cMoedaLC as Character, cCpoUUID as Character, jFilters as Json, cCodCfg as Character) class MatchProcessingProtheusData
Local cType  := ""      as Character    
Local cWhere := ""      as Character
Local cCampo := ""      as Character
Local cReturn:= ""      as Character
Local cSubStr:= ""      as Character
Local nI     := 0       as Numeric
Local nX     := 0       as Numeric
Local nTamArray := 0  as Numeric
Local aValue := {}      as Array
Local uValue as variant
Local cTempTable := "" as Character
Local cCondBranch := GetBranchiesForConditional(cAliasQry) as Character
Local cQLDFil   := GetBranchiesForConditional("QLD") as Character

DEFAULT aWhereArr := {}
DEFAULT cView     := "0"
DEFAULT cTipItem  := ""
DEFAULT cAliasQry := ""
DEFAULT cMoedaLC  := ""
DEFAULT cCpoUUID  := "" 
DEFAULT cCodCfg   := ""

cTempTable  := If(cTipItem == "1", "TEMPORI", "TEMPDES")
cSubStr := If(_lOracle, "SUBSTR", "SUBSTRING")

If cAliasQry == "CT2" 
    cWhere += RetWhereEntity(aWhereArr)        
EndIf

For nI := 1 to Len(aWhereArr)
    uValue      := aWhereArr[nI]["value"]
    cType       := aWhereArr[nI]["type"]
    cCampo      := aWhereArr[nI]["field"]
    cOperation  := aWhereArr[nI]["operation"]

    If jFilters <> NIL .And.  jFilters[cCampo] <> NIL
        cCampo := jFilters[cCampo]
    EndIf

    If Empty(cCampo) .Or. &(cAliasQry)->(FieldPos(cCampo))==0
        Loop
    EndIf

    If Empty(uValue) .And. (cType == 'D' .Or. cType == 'C') .And. cOperation <> "IN" .And. cOperation <> "NOT IN"    //aqui kco
        uValue := " "
    EndIf

    If ValType(uValue) == "C" .And. !Empty(uValue)        
        uValue := tcClearSql(uValue) // Limpeza de comandos de SQL
    EndIf

    If cAliasQry == "CT2" .And. IsEntity(cCampo)
        Loop        
    EndIf

    If cOperation <> "IN" .And. cOperation <> "NOT IN"
        
        If cType == "N"      
            If ValType(uValue) == "C"
                uValue := Val(uValue)
            EndIf 

            If uValue > 0
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf
                cWhere += cCampo               
                cWhere += cOperation
                cWhere += cValToChar(uValue)
            EndIf
        Else
            If !Empty(cWhere)
                cWhere += " AND "
            EndIf
            
            If cType == "D"
                uValue := StrTran(uValue,"-","")
            EndIf

            cWhere += cCampo
            cWhere += " "
            cWhere += cOperation
            cWhere += "'"+uValue+"'"
        EndIf
    ElseIf cOperation == "IN"
        If cType == "N"
            If !Empty(uValue)            
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf
           
                cWhere += cCampo          
                cWhere += " "
                cWhere += cOperation

                // Segundo parâmetro de StrRTokArr esta como " ," 
                // para que a função entenda que tanto a virgula como o espaço sejam vistos como separadores em campos numéricos
                aValue := StrTokArr( uValue , " ,") 
                nTamArray := Len(aValue)
                uValue := ""
                For nX := 1 to nTamArray

                    If AllTrim(aValue[nX]) == CValToChar(Val(aValue[nX]))
                        uValue += ""+AllTrim(aValue[nX])+""
                        If nX < nTamArray
                            uValue += ","
                        EndIf
                    EndIf
                Next                

                cWhere += "("+uValue+")"

            EndIf

        ElseIf cType == "C"
            
            If !Empty(uValue)            
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf

                cWhere += cCampo
                cWhere += " "
                cWhere += cOperation

                If cType == "C"

                    aValue := StrTokArr( uValue , ",")
                    nTamArray := Len(aValue)
                    uValue := ""
                    For nX := 1 to nTamArray
                        uValue += "'"+AllTrim(aValue[nX])+"'"
                        If nX < nTamArray
                            uValue += ","
                        EndIf
                    Next                    

                    cWhere += "("+uValue+")"

                EndIf
            EndIf
        EndIf
    elseIf cOperation == "NOT IN" // Implementação da condição de não esta contido em
        If cType == "N"
            If !Empty(uValue)            
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf
             
                cWhere += cCampo            
                cWhere += " "
                cWhere += cOperation

                // Segundo parâmetro de StrRTokArr esta como " ," 
                // para que a função entenda que tanto a virgula como o espaço sejam vistos como separadores em campos numéricos
                aValue := StrTokArr( uValue , " ,") 
                nTamArray := Len(aValue)
                uValue := ""
                For nX := 1 to nTamArray

                    If AllTrim(aValue[nX]) == CValToChar(Val(aValue[nX]))
                        uValue += ""+AllTrim(aValue[nX])+""
                        If nX < nTamArray
                            uValue += ","
                        EndIf
                    EndIf
                Next
                
                cWhere += "("+uValue+")"

            EndIf

        ElseIf cType == "C"
            
            If !Empty(uValue)            
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf

                cWhere += cCampo
                cWhere += " "
                cWhere += cOperation

                If cType == "C"

                    aValue := StrTokArr( uValue , ",")
                    nTamArray := Len(aValue)
                    uValue := ""
                    For nX := 1 to nTamArray
                        uValue += "'"+AllTrim(aValue[nX])+"'"
                        If nX < nTamArray
                            uValue += ","
                        EndIf
                    Next                    

                    cWhere += "("+uValue+")"

                EndIf
            EndIf
        EndIF

    EndIf

Next

cReturn := " WHERE "

If !Empty(cCondBranch) 
    cReturn += cCondBranch+" AND " 
EndIf  

If !Empty(cWhere)   
    cReturn += cWhere+" AND "   
EndIf

If cAliasQry == "CT2"

    If !Empty(cMoedaLC) 
        cReturn += " CT2_MOEDLC = '"+cMoedaLC+"' AND "    
    EndIf
    
    cReturn += " CT2_DC <> '4' AND "

    If _lCpoIdConc
        cReturn += " (CT2_IDCONC = ' ' OR EXISTS"+;
                   "  (SELECT QLD_FILIAL "+;
                   "  FROM "+RetSQLName("QLD")+;
                   "  WHERE "+cQLDFil+" AND "+;
                   "  QLD_CODCFG = '"+cCodCfg+"' AND "+;
                   "  QLD_CODCON = "+cSubStr+"(CT2_IDCONC,1,"+cValToChar(nTamCodcon)+") AND "+;
                   "  QLD_REGMAT = "+cSubStr+"(CT2_IDCONC,"  +cValToChar(nTamCodcon+1)+","+cValToChar(nTamRegMat)+") AND "+;
                   "  QLD_SEQMAT = "+cSubStr+"(CT2_IDCONC,"  +cValToChar(nTamCodcon+nTamRegMat+1)+","+cValToChar(nTamSeqMat)+") AND "+; 
                   "  D_E_L_E_T_ = ' ' )"+;
                   " ) AND "
    EndIf

    If CT2->(FieldPos("CT2_ESTCAN")) > 0
        cReturn += " CT2_ESTCAN <> 'S' AND "
    EndIf

EndIf

If !Empty(cCpoUUID)
    cReturn += cCpoUUID+" IS NOT NULL AND "   
EndIf

If !Empty(cAliasQry)       
    cReturn += cAliasQry+"."
EndIf

cReturn += "D_E_L_E_T_ = ' ' "

//Tratamento concliado, não conciliado e ambos
If cView == "0"
    cReturn += ") "+cTempTable
ElseIf cView == "1"
    cReturn += ") "+cTempTable+" WHERE RECONCILED = 'S'"
ElseIf cView == "2"
    cReturn += ") "+cTempTable+" WHERE RECONCILED = 'N'"
EndIf

Return cReturn

/*/{Protheus.doc} ExecSQLExpress    
    @author TOTVS
    @since 30/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcExecSQLExpress(cSQLExpression as Character, cTableTmp as Character, lAutomato as Logical, lTmpOri as Logical, cCpoUUID as Character) class MatchProcessingProtheusData
Local cSQL    := "" as Character
Local cError  := "" as Character
Local cCpoInsert := "" as Character
Local cSetupTimeout := "" as Character
Local aStruct := {}  as Array
Local oStruct := tcTreatsFilter():new() as Object

DEFAULT cSQLExpression := ""
DEFAULT cTableTmp := ""
DEFAULT lAutomato := .F.
DEFAULT lTmpOri := .F.
DEFAULT cCpoUUID := ""

If lAutomato
    Conout(STR0005) //"entrou no callStack"
    If lTmpOri
        cTableTmp := "TCTMPORI"
    Else
        cTableTmp := "TCTMPDES"
    EndIf
EndIf

//Alimenta campos para obter estrutura
aStruct := oStruct:tcGetStruct(cSQLExpression)
oStruct:tcKillObjects()

aEval(aStruct, {|x| cCpoInsert += IIf(x[1]=="CT2_IDCONC","",x[1]+",")})
If !Empty(cCpoUUID)
    cCpoInsert += cCpoUUID +", "
EndIf

If "CT2"$cCpoUUID .And. _lCpoIdCOnc
    cCpoInsert += "CT2_IDCONC, "
EndIf

cCpoInsert += " TABELA, REGMATCH, DESMATCH, SEQMATCH, CODCON, IDDELETE, RECONCILED, IDMATCH, COMPARISON "

::tcLoadTamSX()

//Adiciona campos para registrar o Match
If !Empty(cCpoUUID)
    AAdd(aStruct, {cCpoUUID, "C", _nTamUUID, 0})
EndIf

AAdd(aStruct, {"TABELA"  , "C", 3, 0})
AAdd(aStruct, {"REGMATCH", "C", nTamRegMat, 0})
AAdd(aStruct, {"DESMATCH", "C", nTamDesMat, 0})
AAdd(aStruct, {"SEQMATCH", "C", nTamSeqMat, 0})
AAdd(aStruct, {"CODCON"  , "C", nTamCodCon, 0})
AAdd(aStruct, {"IDDELETE", "C", nTamRegMat+nTamSeqMat, 0})
AAdd(aStruct, {"RECONCILED", "C",1, 0})
AAdd(aStruct, {"IDMATCH" , "C",nTamRegMat+nTamSeqMat, 0})
AAdd(aStruct, {"COMPARISON", "C",2, 0})

/* 
    To-Do: TCConfig após disponibilidade pela Tec
    Essa funcionalidade se encarregará do gerenciamento da Temporaria,
    Permanência no banco, Exclusão  etc
*/

//Criacao da tabela temporaria com recno automatico

cTableTmp := "%SHTMP%"  //Identificador para criação de tabela temporaria compartilhada

cSetupTimeout   := TCConfig("SETTEMPKEEPALIVE=18000") // Setar timeout de inatividade em segundos (5 Horas)

If cSetupTimeout == "OK - SETTEMPKEEPALIVE TO 18000"

    FWDBCreate(cTableTmp, aStruct, "TOPCONN", .T.)      // Criação da tabela
    cTableTmp := TCConfig("GETTEMPNAME=" + cTableTmp)   // Capturar nome real da tabela

    DBUseArea(.T., "TOPCONN", cTableTmp, cTableTmp, .T., .F.) // Temporária compartilhada faz abertura com o nome REAL da tabela
    DBCreateIndex(cTableTmp+"1", cCpoUUID)

    //Alimenta tabela temporaria
    cSQL := "INSERT INTO " + cTableTmp
    cSQL += " ("+cCpoInsert+") "
    cSQL += " ("+cSQLExpression+")

    If TCSQLExec(cSQL) <> 0
        Conout(TCSQLError())    
        cError := STR0011   + STR0012 //"matchProcessing Error: " "Nao foi possivel inserir dados na tabela temporaria: "
        cError += cTableTmp + STR0007 //". Para mais detalhes, verificar arquivo console.log"    
    Endif

    DBCloseArea()

Else
    Conout(cSetupTimeout)
    cError += STR0011   + STR0013 //"matchProcessing Error: " "Não foi possível definir o tempo de timeout na tabela temporária."
    cError += cTableTmp + STR0007 //". Para mais detalhes, verificar arquivo console.log"   
EndIf

//Limpa objetos
FwFreeArray(aStruct)
FreeObj(oStruct)
Return cError

/*/{Protheus.doc} tcCriaProcMatch
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcCriaProcMatch(cAliasOri as Character, cAliasDes as Character,;
                      cTableOri as Character, cTableDes as Character,;
                      cCpoIdOri as Character, cCpoIdDes as Character,;
                      jRegrasMatch as json, cNomProc as Character,;
                      cMatchOrd as Character, jTotal as json) class MatchProcessingProtheusData

Local cError     := "" as Character
Local cQuery     := "" as Character
Local cPopTemp1  := "" as Character
Local cPoptemp2  := "" as Character
Local cPopComp1  := "" as Character
Local cPopComp2  := "" as Character
Local cIdRule    := "" as Character
Local cNameRule  := "" as Character
Local cSeqMatch  := "" as Character
Local cConcat    := "" as Character
Local lAliasLink := .F. as Logical
Local nPTratRec  := 0 as Numeric
Local cNameDB    := Alltrim(TcGetDB()) as Character
Local cFilCondCV3:= "" as Character
Local nI         := 0  As Numeric
Local nJ         := 0  As Numeric
Local cCompOri   := "" as Character
Local cCompDes   := "" as Character 
Local cComparison:= "AD" as Character
Local cFieldsOri := "" as Character
Local cFieldsDes := "" as Character
Local aCamposAux := {} as ARRAY

DEFAULT cNomProc := ""
DEFAULT cMatchOrd := ""

cNomProc := GetNextAlias()+"_"+cEmpAnt

If !TCSPExist( cNomProc )

    cIdRule     := jRegrasMatch["idrule"]
    cNameRule   := jRegrasMatch["name"]
    cAliasLink  := jRegrasMatch["linktable"]
    lAliasLink  := ValType(cAliasLink) <> "U"

    cCposChvOri := jRegrasMatch["rule"]["ori_fields"]
    cCposChvDes := jRegrasMatch["rule"]["des_fields"]
    cCondition  := jRegrasMatch["rule"]["condition"]
    
    If !Empty(cMatchOrd)
        cCposChvOri += ","+cMatchOrd
    EndIf

    cPopTemp1 := ::tcChavtoVar(cCposChvOri)
    cPoptemp2 := ::tcChavtoVar(cCposChvDes)
     
    If lAliasLink            
        cWhereOri := jRegrasMatch["rule"]["ori_link"]
    EndIf   
    If lAliasLink 
        cWhereDes := jRegrasMatch["rule"]["des_link"]        
    EndIf

    // Valido se a chave valid existe nos totais
    If ValType(jTotal) <> "U"
        For nI := 1 To Len(jTotal["totalori"])  
            // Origem
            If jTotal["totalori"][nI]["valid"] <> NIL .And. jTotal["totalori"][nI]["fields"] <> NIL
                If jTotal["totalori"][nI]["valid"] == .T.
                    cCompOri = jTotal["totalori"][nI]["total"]
                    aCamposAux := {}
                    aCamposAux := StrToArray(jTotal["totalori"][nI]["fields"],',')
                    For nJ:=1 to Len(aCamposAux)
                        If !(aCamposAux[nJ]$cCposChvOri+cFieldsOri)
                            If !Empty(cFieldsOri)
                                cFieldsOri += ", "
                            EndIf                            
                            cFieldsOri += aCamposAux[nJ]
                        EndIf
                    Next nJ                    
                EndIf
            EndIf
        Next nI   
        For nI := 1 To Len(jTotal["totaldes"])  
            // Destino
            If jTotal["totaldes"][nI]["valid"] <> NIL .And. jTotal["totaldes"][nI]["fields"] <> NIL
                If jTotal["totaldes"][nI]["valid"] == .T.
                    cCompDes = jTotal["totaldes"][nI]["total"]
                    aCamposAux := {}
                    aCamposAux := StrToArray(jTotal["totaldes"][nI]["fields"],',')
                    For nJ:=1 to Len(aCamposAux)
                        If !(aCamposAux[nJ]$cCposChvDes+cFieldsDes)                                            
                            If !Empty(cFieldsDes)
                                cFieldsDes += ", "
                            EndIf                            
                            cFieldsDes += aCamposAux[nJ]
                        EndIf
                    Next nJ                    
                EndIf
            EndIf
        Next nI 
    EndIf

    ::tcLoadTamSX()

    cConcat := tcRetConcat()

    cQuery :=  " CREATE PROCEDURE "+cNomProc+" ( "+CRLF+;
               " @OUT_RESULT Char( 01 ) output ) AS "+CRLF+;                         
               " DECLARE @REGMATCH Char( "+cValToChar(nTamRegMat)+" ) "+CRLF+;
               " DECLARE @DESMATCH Char( "+cValToChar(nTamDesMat)+" ) "+CRLF+;
               " DECLARE @SEQMATCH Char( "+cValToChar(nTamSeqMat)+" ) "+CRLF+;
               " DECLARE @IDMATCH Char( "+cValToChar(nTamRegMat+nTamSeqMat)+" ) "+CRLF+;
               " DECLARE @iSeqMatch Integer "+CRLF+;
               " DECLARE @iSeqFlag Integer "+CRLF+;
               " DECLARE @iNroRegs Integer "+CRLF+;
               " DECLARE @ins_error Integer "+CRLF+;
               " DECLARE @iLoop Integer "+CRLF+;               
               " DECLARE @iTranCount Integer "+CRLF

    cQuery += ::tcProcDeclare(cCposChvOri)
    cQuery += ::tcProcDeclare(cCposChvDes)

    //Alimenta campos para obter estrutura
    If !Empty(cCompOri) .And. !Empty(cCompDes)
        If !Empty(cFieldsOri)
            cPopComp1 := ::tcChavtoVar(cFieldsOri)
            cQuery    += ::tcProcDeclare(cFieldsOri)
        EndIf

        If !Empty(cFieldsDes)
            cPopComp2 := ::tcChavtoVar(cFieldsDes)
            cQuery    += ::tcProcDeclare(cFieldsDes)
        EndIf

        // Transforma a estrutura em string com @
        cCompOri = IIf(!(cAliasOri)->(FieldPos(cAliasOri+"_FILIAL")),StrTran(cCompOri, SubStr(cAliasOri, 2, 2),"@"+SubStr(cAliasOri, 2, 2) ),StrTran(cCompOri, cAliasOri,"@"+cAliasOri))
        cCompDes = IIf(!(cAliasDes)->(FieldPos(cAliasDes+"_FILIAL")),StrTran(cCompDes, SubStr(cAliasDes, 2, 2),"@"+SubStr(cAliasDes, 2, 2) ),StrTran(cCompDes, cAliasDes,"@"+cAliasDes))
    EndIf

    cQuery +=  " BEGIN "+CRLF+;               
               "     SELECT @OUT_RESULT  = '0' "+CRLF+;
               "     SELECT @iLoop       = 0 "+CRLF+;
               "     SELECT @iSeqMatch	 = 0 "+CRLF+;
               "     DECLARE POPTEMP01 insensitive  CURSOR FOR "+CRLF               
  
    If ValType(cCposChvOri) <> "U" .And. ValType(cAliasOri) <> "U"
        If cFieldsDes <> "" .And. cFieldsOri <> ""        
            cQuery +=  "     SELECT DISTINCT "+cCposChvOri+", "+cFieldsOri+CRLF        
        Else
            cQuery +=  "     SELECT DISTINCT "+cCposChvOri+CRLF 
        EndIf
        cQuery +=  "     FROM "+cTableOri+" "+cAliasOri+" "      
    EndIf
        
    If lAliasLink
        cQuery += ", "+RetSQLName(cAliasLink)+" "+cAliasLink+CRLF
    EndIf

    cQuery += " WHERE SEQMATCH = ' ' "
    cQuery += " AND RECONCILED = 'N' "


    If lAliasLink .And. ValType(cWhereOri) <> "U"
        cQuery += " AND "+cWhereOri        
    EndIf

    If !Empty(cMatchOrd)                   
        cQuery += "   ORDER BY "+cMatchOrd
    EndIf

    cQuery +=  "     FOR READ ONLY "+CRLF+;
               "     OPEN POPTEMP01 "+CRLF+;
               "     FETCH POPTEMP01 "+CRLF
    If cFieldsDes <> "" .And. cFieldsOri <> ""
        cQuery += "  INTO "+cPopTemp1+", "+cPopComp1+CRLF
    else
        cQuery += "  INTO "+cPopTemp1+CRLF
    EndIf
    cQuery +=  "     WHILE @@Fetch_Status  = 0 BEGIN "+CRLF+;
               "         SELECT @iNroRegs = @iNroRegs + 1 "+CRLF+;
               "         SELECT @iSeqMatch = @iSeqMatch + 1 "+CRLF+;
               "         SELECT @iSeqFlag = 0 "+CRLF+;
               "         IF @iNroRegs = 1 BEGIN "+CRLF+;
               "             BEGIN TRAN "+CRLF+; 
               "             SELECT @iNroRegs = @iNroRegs "+CRLF+;
               "         END "+CRLF+;                        
               "         DECLARE POPTEMP02 insensitive  CURSOR FOR "+CRLF

    If ValType(cCposChvDes) <> "U" .And. ValType(cAliasDes) <> "U"
    If cFieldsDes <> "" .And. cFieldsOri <> "" 
        cQuery +=  "     SELECT DISTINCT "+cCposChvDes+", REGMATCH, DESMATCH, IDMATCH, SEQMATCH, "+cFieldsDes +CRLF
    else
        cQuery +=  "     SELECT DISTINCT "+cCposChvDes+", REGMATCH, DESMATCH, IDMATCH, SEQMATCH "+CRLF
    EndIf        
        cQuery +=  "     FROM "+cTableDes+" "+cAliasDes+" "
    EndIf
        
    If lAliasLink
        cQuery += ", "+RetSQLName(cAliasLink)+" "+cAliasLink+CRLF
    EndIf

    cQuery += " WHERE RECONCILED = 'N' AND "
    cQuery += " (REGMATCH = '"+cIdRule+"' OR REGMATCH = ' ') AND "
    
    // Ajuste de Performance para adicionar filial da CV3 na procedure
    If lAliasLink .And. cAliasLink == 'CV3'
        cFilCondCV3 := GetBranchiesForConditional(cAliasLink)
        If cFilCondCV3 <> ''
            cFilCondCV3 := cFilCondCV3 + 'AND '
        EndIf
    EndIf

    cQuery += ::tcCondtoVar(cFilCondCV3+cCondition,cCposChvOri)+CRLF
    
    IIf(cNameDB$"MSSQL7|MSSQL",;
        cSeqMatch := " RIGHT('"+Replicate('0',nTamSeqMat)+"'+RTRIM(CAST(@iSeqMatch AS CHAR("+cValToChar(nTamSeqMat)+"))),"+cValToChar(nTamSeqMat)+") ",;
        cSeqMatch := " TO_CHAR(@iSeqMatch,'FM"+Replicate('0',nTamSeqMat)+"') ")    

    cQuery +=  "         FOR READ ONLY "+CRLF+;
               "         OPEN POPTEMP02 "+CRLF+;
               "         FETCH POPTEMP02 "+CRLF
    If cFieldsDes <> "" .And. cFieldsOri <> "" 
        cQuery += "      INTO "+cPopTemp2+", @REGMATCH, @DESMATCH, @IDMATCH, @SEQMATCH, "+cPopComp2 +CRLF
    else
        cQuery += "      INTO "+cPopTemp2+", @REGMATCH, @DESMATCH, @IDMATCH, @SEQMATCH "+CRLF
    EndIf
    cQuery +=  "         If @@Fetch_Status <> 0 Begin "+CRLF+;
               "            SELECT @iSeqMatch = @iSeqMatch - 1 "+CRLF+;
               "         End "+CRLF+;
               "         WHILE @@Fetch_Status  = 0 BEGIN "+CRLF

    // Condição para validar se os valores são iguais e atualizar o campo COMPARISON
    If cCompOri <> "" .And. cCompDes <> ""
        cQuery +=  "             If "+cCompOri+" <> "+cCompDes+"  Begin "+CRLF+;
                "                 UPDATE "+cTableOri+CRLF+;
                "                 SET COMPARISON = '"+cComparison+"' " +CRLF+;
                "                 WHERE "+::tcCondUpdate(cCposChvOri,cIdRule)+" "+CRLF+;
                "                 UPDATE "+cTableDes+CRLF+;
                "                 SET COMPARISON = '"+cComparison+"' " +CRLF+;
                "                 WHERE "+::tcCondUpdate(cCposChvDes,cIdRule)+" "+CRLF+;
                "             End "+CRLF
    EndIf

    cQuery +=  "             If @SEQMATCH = ' ' Begin "+CRLF+;                                    
               "                 UPDATE "+cTableOri+CRLF+;
               "                 SET REGMATCH = '"+cIdRule+"', DESMATCH = '"+cNameRule+"', "+CRLF+;
               "                 IDMATCH = ('"+cIdRule+"' " + cConcat + " "+ cSeqMatch + " ) , " +CRLF+;
               "                 SEQMATCH = " + cSeqMatch+CRLF+;
               "                 WHERE "+::tcCondUpdate(cCposChvOri,cIdRule)+" AND SEQMATCH = ' ' "+CRLF+;
               "                 UPDATE "+cTableDes+CRLF+;
               "                 SET REGMATCH = '"+cIdRule+"', DESMATCH = '"+cNameRule+"', "+CRLF+;
               "                 IDMATCH = ('"+cIdRule+ "' " + cConcat + " "+ cSeqMatch + " ) , " +CRLF+;
               "                 SEQMATCH = "+ cSeqMatch+CRLF+;
               "                 WHERE "+::tcCondUpdate(cCposChvDes,cIdRule)+CRLF+;
               "             End Else Begin "+CRLF+;
               "                 UPDATE "+cTableOri+CRLF+;
               "                 SET REGMATCH = @REGMATCH, DESMATCH = @DESMATCH, IDMATCH = @IDMATCH, SEQMATCH = @SEQMATCH "+CRLF+;
               "                 WHERE "+::tcCondUpdate(cCposChvOri,cIdRule)+" AND SEQMATCH = ' ' "+CRLF+;
               "                 If @iSeqMatch > 1 AND @iSeqFlag = 0 Begin "+CRLF+;
               "                     SELECT @iSeqMatch = @iSeqMatch - 1 "+CRLF+;
               "                     SELECT @iSeqFlag = 1 "+CRLF+;
               "                 End "+CRLF+;   
               "             End "+CRLF+;
               "             FETCH POPTEMP02 "+CRLF
    If cFieldsDes <> "" .And. cFieldsOri <> "" 
        cQuery += "      INTO "+cPopTemp2+", @REGMATCH, @DESMATCH, @IDMATCH, @SEQMATCH, "+cPopComp2 +CRLF
    else
        cQuery += "      INTO "+cPopTemp2+", @REGMATCH, @DESMATCH, @IDMATCH, @SEQMATCH "+CRLF
    EndIf
    cQuery +=     "      END "+CRLF
               
    // Em postgres ao fazer o fetch no segundo cursos e não encontrar registros a variavel que 
    // controla os laços de repetição dos dois cursores recebe = 1, para evitar o problema
    // é atribuido novamente o valor o em fim_cur para que o cursor poptemp1 passe para o próximo registro

    If _lPostgres
        cQuery += "         SELECT @fim_CUR  = 0"+CRLF
    EndIf           

    cQuery +=  "         CLOSE POPTEMP02 "+CRLF+;
               "         DEALLOCATE POPTEMP02 "+CRLF+;
               "         IF @iNroRegs >= 4000 BEGIN "+CRLF+;
               "             commit tran "+CRLF+;
               "             SELECT @iNroRegs = 0 "+CRLF+; 
               "         END "+CRLF+;
               "         FETCH POPTEMP01 "+CRLF
    If cFieldsDes <> "" .And. cFieldsOri <> "" 
        cQuery += "      INTO "+cPopTemp1+", "+cPopComp1+CRLF
    else
        cQuery += "      INTO "+cPopTemp1 +CRLF
    EndIf
    cQuery +=  "     END "+CRLF+;
               "     CLOSE POPTEMP01 "+CRLF+;
               "     DEALLOCATE POPTEMP01 "+CRLF+;
               "     IF @iNroRegs > 0 BEGIN "+CRLF+; 
               "         commit tran "+CRLF+; 
               "         select @iTranCount = 0 "+CRLF+;
               "     END "+CRLF+;
               "     SELECT @OUT_RESULT = '1' "+CRLF+;
               " END "


    cQuery := CtbAjustaP(.T., cQuery, @nPTratRec)
    cQuery := MsParse(cQuery, cNameDB)
    cQuery := CtbAjustaP(.F., cQuery, nPTratRec)

	//A variavel fim_cur fica com o nome vFim_cur ao passar pelo MSParse

    If _lPostgres
        cQuery	:= StrTran( cQuery, 'vfim_CUR', 'fim_CUR' )
    EndIf

    IIf(Empty(cQuery),;
        (conout(MsParseError()),;
            cError := STR0011  + STR0006,;  //"matchProcessing Error: " "Error on the procedure creation (MSPARSE) "
            cError += cNomProc + STR0007),; //". Para mais detalhes, verificar arquivo console.log"
        cError := "")

    If Empty(cError)
        IIf(TcSqlExec(cQuery) <> 0,; 
            (conout(TCSqlError()),;
                cError := STR0011  + STR0008,;  //"matchProcessing Error: " "Error on the procedure creation (TCSQLEXEC) "
                cError += cNomProc + STR0007),; //". Para mais detalhes, verificar arquivo console.log" 
            cError := "") 
    EndIf    
EndIf

Return cError

/*/{Protheus.doc} tcChavtoVar
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcChavtoVar(cCposChave as Character) class MatchProcessingProtheusData
Default cCposChave := ""
Return "@"+StrTran(StrTran(cCposChave," ",""),",",", @")

/*/{Protheus.doc} tcCondtoVar
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcCondtoVar(cCondition as Character, cCposChvOri as Character) Class MatchProcessingProtheusData
Local aCposChave := {} as Array
Local nI := 0 as Numeric
Local cField := "" as Character

aCposChave := StrToArray(cCposChvOri,",")
For nI := 1 to Len(aCposChave)
    cField := AllTrim(aCposChave[nI])
    If cField$cCondition
        cCondition := StrTran(cCondition,cField,"@"+cField)
    EndIf
Next

Return cCondition

/*/{Protheus.doc} tcProcMatch
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcProcMatch( cAliasOri as Character, cAliasDes as Character,;
                    cTableOri as Character, cTableDes as Character,;
                    cCpoIdOri as Character, cCpoIdDes as Character,;
                    jRegrasMatch as Json, cMatchOrd as Character,;
                    jTotal as Json) Class MatchProcessingProtheusData
Local nI        := 0 as Numeric
Local cError    := "" as Character
Local cNomProc  := "" as Character
Local aResult   := {} as Array

For nI:=1 to Len(jRegrasMatch["rules"])    
    If Empty(cError)
        cError := ::tcCriaProcMatch(cAliasOri,cAliasDes,cTableOri,cTableDes,cCpoIdOri,cCpoIdDes,jRegrasMatch["rules"][nI],@cNomProc,cMatchOrd,jTotal)                            
        If Empty(cError)
            aResult := TCSPEXEC(xProcedures(Left(cNomProc,10)))				
            
            IIf(Empty(aResult) .or. aResult[1] = "0",;
                (conout(TCSQLError()),;
                cError := STR0009+cNomProc+" "+TcSQLError()),; //"Erro na execucao do Match via procedure: "
                cError := "")

            If Empty(cError)                
                IIf(TcSqlExec(" DROP PROCEDURE " + cNomProc) <> 0,;
                    (conout(TCSQLError()),;
                        cError := STR0011 + STR0010,;   //"matchProcessing Error: " "Erro na exclusao da procedure "
                        cError += cNomProc + STR0007),; //". Para mais detalhes, verificar arquivo console.log"
                    cError := "")
            EndIf        
        EndIf
    EndIf
Next

Return cError

/*/{Protheus.doc} tcProcDeclare
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcProcDeclare(cCposChave as Character) Class MatchProcessingProtheusData
Local aCposChave := {} as Array
Local nI     := 0  as Numeric
Local cField := "" as Character
Local cTipo  := "" as Character
Local cSQL   := "" as Character
Local aTamFil:= {} as ARRAY

aCposChave := StrToArray(cCposChave,",")
For nI := 1 to Len(aCposChave)
    cField  := AllTrim(aCposChave[nI])
    
    //Fixo 36 pois as tabelas temporárias foram criadas com 36
    //Ajuste para remover o RTRIM da regra de match 
    If "_MSUID"$cField
        aTamFil := {36,0,"C"}
    Else
        aTamFil := TamSx3(cField)
    EndIf
    
    cTipo := IIf(Len(aTamFil) > 0,;
                IIf(aTamFil[3] == "N",; 
                    IIF(aTamFil[2] > 0,; 
                        "float",; 
                        "integer"),; 
                "varchar("+cValToCHar(aTamFil[1])+")"),; 
            "")
    
    cSQL += IIf(Len(aTamFil) > 0, "DECLARE @"+cField+" "+cTipo+CRLF, "")             
Next

Return cSQL

/*/{Protheus.doc} tcProcDeclare
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcCondUpdate(cCposChave as Character, cIdrule as Character) class MatchProcessingProtheusData
Local aCposChave := {} as Array
Local cSQL := "" as Character
Local nI := 0 as Numeric
Local cField := "" as Character

DEFAULT cIdRule := " "

cSQL := " RECONCILED = 'N' AND (REGMATCH = '"+cIdRule+"' OR REGMATCH = ' ') AND "

aCposChave := StrToArray(cCposChave,",")
For nI := 1 to Len(aCposChave)    
    cSQL += IIf(nI > 1, " AND ", "")            
    cField := AllTrim(aCposChave[nI])    
    cSQL += cField+" = @"+cField
Next 

Return cSQL

//-------------------------------------------------------------------
/*/{Protheus.doc} tcLoadTamSX
Metodo que retorna tamanho dos campos de match

@author Totvs
/*/
//-------------------------------------------------------------------
method tcLoadTamSX() class MatchProcessingProtheusData

If ValType(nTamRegMat) == "U"
    nTamRegMat := TamSx3("QLD_REGMAT")[1]
    nTamSeqMat := TamSx3("QLD_SEQMAT")[1]
    nTamDesMat := TamSx3("QLD_DESMAT")[1]
    nTamCodcon := TamSx3("QLD_CODCON")[1]
EndIf

Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetQuery
Metodo que retorna a query montada

@author Totvs
/*/
//-------------------------------------------------------------------
method tcRetQuery(cCodCfg as character, jHeaders as Json, cCpoID as character, cAlias as character, cTipo as character) class MatchProcessingProtheusData
    Local cRetQry   := "" as character
    Local cJsonItem := "" as character 
    Local cQLDFil   := GetBranchiesForConditional("QLD") as  character
    
    DEFAULT cCodCfg := ""
    DEFAULT cCpoID  := ""
    DEFAULT cAlias  := ""
    DEFAULT cTipo   := ""

    
    cJsonItem := IIf(cTipo == "1","data_ori","data_des")

    cRetQry := " SELECT "
    cRetQry += ::tcRetSQLExpression(jHeaders[cJsonItem],", ",cCpoId, .T.) //Cabecalho da query
    cRetQry += " FROM ( SELECT "
    cRetQry += ::tcRetSQLExpression(jHeaders[cJsonItem],", ",cCpoId, .F., nil, cAlias) //Itens da query
    cRetQry += " FROM "+RetSQLName(cAlias)+" "+cAlias
    cRetQry += " LEFT JOIN "+RetSQLName("QLD")+" QLD ON "
    cRetQry +=  cQLDFil

    If _lPostgres
        cRetQry += " AND CAST("+cCpoId+" AS VARCHAR) = RTRIM(QLD_IDITEM) "
    Else
        cRetQry += " AND "+cCpoId+" = RTRIM(QLD_IDITEM) "
    EndIf

    cRetQry += " AND QLD_TPITEM = '"+cTipo+"' "
    cRetQry += " AND QLD_CODCFG = '"+cCodCfg+"' "
    cRetQry += " AND QLD.D_E_L_E_T_ = ' ' "

Return cRetQry 

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetUnion
Metodo que retorna a query com union

@author Totvs
/*/
//-------------------------------------------------------------------
method tcQueryUnion(cCodCfg as character, cTipo as character, cCpoID as character, cAlias as character, cView as character,; 
                        jUnion as array, jHeaders as array, jBody as Json, cMatchOrd as character) class MatchProcessingProtheusData
    Local nI        := 0
    Local nJ        := 0
    Local cTabUnion := ""
    Local cIdUnion  := ""
    Local cRetQuery := ""
    Local aHeaders  := {}
    Local aCposPai  := {}
    Local aCposFil  := {}
    Local jFilters  :=  JsonObject():new() as Json
    Local cTempTab  := "" 
    Local cFieldType := ""

    cTempTab := If(cTipo == "1", "TEMPORI", "TEMPDES")

    For nI:=1 to Len(jUnion)                        
        cTabUnion := jUnion[nI]["table"]
        cIdUnion  := jUnion[nI]["cpoid"]   
        cMatchOrd := jUnion[nI]["matchorder"]        

        For nJ:=1 to Len(jUnion[nI]["fields"])
            If Empty(jUnion[nI]["fields"][nJ]["cpopai"])
                aAdd(aHeaders, jUnion[nI]["fields"][nJ]["cpofil"])
                
                cFieldType := FWSX3Util():GetFieldType((jUnion[nI]["fields"][nJ]["cpofil"]))                        
                If cFieldType == "N" .OR. cFieldType == "L"
                    aAdd(aCposPai, "0 "+jUnion[nI]["fields"][nJ]["cpofil"])
                Else
                    aAdd(aCposPai, "' ' "+jUnion[nI]["fields"][nJ]["cpofil"])
                EndIf
            Else
                aAdd(aHeaders, jUnion[nI]["fields"][nJ]["cpopai"])
                aAdd(aCposPai, jUnion[nI]["fields"][nJ]["cpopai"])                                                                                
                jFilters[jUnion[nI]["fields"][nJ]["cpopai"]] := jUnion[nI]["fields"][nJ]["cpofil"]                                            
            EndIf

            If Empty(jUnion[nI]["fields"][nJ]["cpofil"])
                
                cFieldType := FWSX3Util():GetFieldType((jUnion[nI]["fields"][nJ]["cpopai"]))
                If cFieldType == "N" .OR. cFieldType == "L"
                    aAdd(aCposFil, "0 "+jUnion[nI]["fields"][nJ]["cpopai"])
                Else
                    aAdd(aCposFil, "' ' "+jUnion[nI]["fields"][nJ]["cpopai"])
                EndIf
            Else
                aAdd(aCposFil, jUnion[nI]["fields"][nJ]["cpofil"])
            EndIf
        Next nJ         

        For nJ:=1 to Len(jHeaders)
            If aScan(aHeaders, {|x| x = jHeaders[nJ]}) == 0
                aAdd(aHeaders, jHeaders[nJ])
                aAdd(aCposPai, jHeaders[nJ])

                cFieldType := FWSX3Util():GetFieldType(jHeaders[nJ])
                If cFieldType == "N" .OR. cFieldType == "L"
                    aAdd(aCposFil, "0 "+jHeaders[nJ])
                Else
                    aAdd(aCposFil, "' ' "+jHeaders[nJ])
                EndIf

            EndIf
        Next nJ  
        
        If nI == 1
            cRetQuery := ::tcRetSelectUnion(cCodCfg, cTipo, cCpoId, cAlias, aHeaders, aCposPai, jBody)
        EndIf

        cRetQuery += ::tcRetUnion(cCodCfg, cTipo, cIdUnion, cTabUnion, aCposFil, jFilters, jBody)
    Next nI   
    
    //Tratamento concliado, não conciliado e ambos
    If !Empty(cRetQuery)
        If cView == "0"
            cRetQuery += ") "+cTempTab
        ElseIf cView == "1"
            cRetQuery += ") "+cTempTab+" WHERE RECONCILED = 'S'"
        ElseIf cView == "2"
            cRetQuery += ") "+cTempTab+" WHERE RECONCILED = 'N'"
        EndIf
    EndIf

Return cRetQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetSelectUnion
Metodo que retorna o select do Union

@author Totvs
/*/
//-------------------------------------------------------------------
method tcRetSelectUnion(cCodCfg as character, cTipo as character, cCpoId as character, cAlias as character,;
                            aHeaders as array,  aCposPai as array, jBody as json) class MatchProcessingProtheusData
    Local cRetQuery := ""
    Local cQLDFil   := GetBranchiesForConditional("QLD")  as character

    cRetQuery := " SELECT "
    cRetQuery += ::tcRetSQLExpression(aHeaders,", ",cCpoId, .T.) //Cabecalho da query
    cRetQuery += " FROM ( SELECT "
    cRetQuery += ::tcRetSQLExpression(aCposPai,", ",cCpoId, .F., nil, cAlias) //Itens da query
    cRetQuery += " FROM "+RetSQLName(cAlias)+" "+cAlias
    cRetQuery += " LEFT JOIN "+RetSQLName("QLD")+" QLD ON "
    cRetQuery +=  cQLDFil
    
    If _lPostgres
        cRetQuery += " AND CAST("+cCpoId+" AS VARCHAR) = RTRIM(QLD_IDITEM) "
    Else
        cRetQuery += " AND "+cCpoId+" = RTRIM(QLD_IDITEM) "

    EndIf
    cRetQuery += " AND QLD_TPITEM = '"+cTipo+"' "
    cRetQuery += " AND QLD_CODCFG = '"+cCodCfg+"' "
    cRetQuery += " AND QLD.D_E_L_E_T_ = ' ' "
    cRetQuery += ::tcRetWhere(jBody["tabori"], "", cTipo, cAlias,"01", cCpoId)

Return cRetQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetUnion
Metodo que retorna a string do UNION

@author Totvs
/*/
//-------------------------------------------------------------------
method tcRetUnion(cCodCfg as character, cTipo as character, cCpoId as character, cAlias as character,;
                     aCposFil as array, jFilters as json, jBody as Json) class MatchProcessingProtheusData

    Local cRetQuery := ""
    Local cQLDFil   := GetBranchiesForConditional("QLD") as  character

    cRetQuery := " UNION SELECT "
    cRetQuery += ::tcRetSQLExpression(aCposFil, ", ", cCpoId, .F., nil, cAlias) //Itens da query
    cRetQuery += " FROM "+RetSQLName(cAlias)+" "+cAlias
    cRetQuery += " LEFT JOIN "+RetSQLName("QLD")+" QLD ON "
    cRetQuery +=  cQLDFil

    If _lPostgres
        cRetQuery += " AND CAST("+cCpoId+" AS VARCHAR) = RTRIM(QLD_IDITEM) "
    Else
        cRetQuery += " AND "+cCpoId+" = RTRIM(QLD_IDITEM) "
    EndIf    

    cRetQuery += " AND QLD_TPITEM = '"+cTipo+"' "
    cRetQuery += " AND QLD_CODCFG = '"+cCodCfg+"' "
    cRetQuery += " AND QLD.D_E_L_E_T_ = ' ' "
    cRetQuery += ::tcRetWhere(jBody["tabori"], "", cTipo, cAlias,"01", cCpoId, jFilters)

Return cRetQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} tcValidFields
Metodo que valida se campos utilizados nas condicoes estao presentes
no Select e inclui se necessario

@author Totvs
/*/
//-------------------------------------------------------------------
method tcValidFields(jHeaders as Json, jRegrasMatch as Json) class MatchProcessingProtheusData
Local nI        := 0  as Numeric
Local nX        := 0  as Numeric
Local aRulesOri := {} as Array
Local aRulesDes := {} as Array

//Verifica todas as regras de Match
For nI := 1 To Len(jRegrasMatch["rules"])
    aRulesOri := StrToArray(jRegrasMatch["rules"][nI]["rule"]["ori_fields"], ",")
    aRulesDes := StrToArray(jRegrasMatch["rules"][nI]["rule"]["des_fields"], ",")

    //Tratamento para campos de origem
    For nX := 1 To Len(aRulesOri)
        If aScan(jHeaders["data_ori"], {|x| x = aRulesOri[nX]}) == 0 .And. !("MSUIDT" $ aRulesOri[nX])
           aAdd(jHeaders["data_ori"], aRulesOri[nX])
        EndIf
    Next nX

    //Tratamento para campos de destino
    For nX := 1 To Len(aRulesDes)
        If aScan(jHeaders["data_des"], {|x| x = aRulesDes[nX]}) == 0 .And. !("MSUIDT" $ aRulesDes[nX])
            aAdd(jHeaders["data_des"], aRulesDes[nX])
        EndIf
    Next nX
Next nI

FwFreeArray(aRulesOri)
FwFreeArray(aRulesDes)
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IsEntity
Valida de se o campo é uma entidade contábil
O Where desses campos será montado na função WhereEntity()

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function IsEntity(cCampo as Character)
DEFAULT cCampo := ""
DEFAULT _cCpoEntidades :=   'CT2_DEBITO|'+;
                            'CT2_CREDIT|'+;
                            'CT2_CCD|'+;
                            'CT2_CCC|'+;
                            'CT2_ITEMD|'+;
                            'CT2_ITEMC|'+;
                            'CT2_CLVLDB|'+;
                            'CT2_CLVLCR|'+;
                            'CT2_EC05DB|'+;
                            'CT2_EC05CR|'+;
                            'CT2_EC06DB|'+;
                            'CT2_EC06CR|'+;
                            'CT2_EC07DB|'+;
                            'CT2_EC07CR|'+;
                            'CT2_EC08DB|'+;
                            'CT2_EC08CR|'+;
                            'CT2_EC09DB|'+;
                            'CT2_EC09CR'
Return (cCampo$_cCpoEntidades)

//-------------------------------------------------------------------
/*/{Protheus.doc} RetWhereEntity
Monta a condição Where das entidades contábeis

@author Totvs
/*/
//-------------------------------------------------------------------
Function RetWhereEntity(aWhereArr as Array, cDebCred as Character)
Local nI := 0
Local cWhere  := ""
Local cCampo  := ""
Local cOperation := ""
Local cValue  := ""
Local cDebito := "" 
Local cCredit := ""
Local cCCD    := ""
Local cCCC    := ""
Local cItemD  := ""
Local cItemC  := ""
Local cClVlDB := ""
Local cClVlCR := ""
Local cEC05DB := ""
Local cEC05CR := ""
Local cEC06DB := ""
Local cEC06CR := ""
Local cEC07DB := ""
Local cEC07CR := ""
Local cEC08DB := ""
Local cEC08CR := ""
Local cEC09DB := ""
Local cEC09CR := ""

DEFAULT aWhereArr := {}
Default cDebCred  := ''

For nI := 1 to Len(aWhereArr)
    cCampo      := aWhereArr[nI]["field"]
    If IsEntity(cCampo)        
        cValue      := aWhereArr[nI]["value"]        
        cOperation  := aWhereArr[nI]["operation"]    

        If cCampo=="CT2_DEBITO"            
            cDebito := RetCondEntity(cCampo, cOperation, cValue, cDebito)
        EndIf

        If cCampo=="CT2_CREDIT"            
            cCredit := RetCondEntity(cCampo, cOperation, cValue, cCredit)
        EndIf

        If cCampo=="CT2_CCD"
            cCCD := RetCondEntity(cCampo, cOperation, cValue, cCCD)
        EndIf

        If cCampo$"CT2_CCC"
            cCCC := RetCondEntity(cCampo, cOperation, cValue, cCCC)
        EndIf

        If cCampo=="CT2_ITEMD"
            cItemD := RetCondEntity(cCampo, cOperation, cValue, cItemD)
        EndIf

        If cCampo$"CT2_ITEMC"
            cItemC := RetCondEntity(cCampo, cOperation, cValue, cItemC)
        EndIf

        If cCampo=="CT2_CLVLDB"
            cClVlDB := RetCondEntity(cCampo, cOperation, cValue, cClVlDB)
        EndIf

        If cCampo$"CT2_CLVLCR"
            cClVlCR := RetCondEntity(cCampo, cOperation, cValue, cClVlCR)
        EndIf

        If cCampo=="CT2_EC05DB"
            cEC05DB := RetCondEntity(cCampo, cOperation, cValue, cEC05DB)
        EndIf

        If cCampo$"CT2_EC05CR"
            cEC05CR := RetCondEntity(cCampo, cOperation, cValue, cEC05CR)
        EndIf

        If cCampo=="CT2_EC06DB"
            cEC06DB := RetCondEntity(cCampo, cOperation, cValue, cEC06DB)
        EndIf

        If cCampo$"CT2_EC06CR"
            cEC06CR := RetCondEntity(cCampo, cOperation, cValue, cEC06CR)
        EndIf

        If cCampo=="CT2_EC07DB"
            cEC07DB := RetCondEntity(cCampo, cOperation, cValue, cEC07DB)
        EndIf

        If cCampo$"CT2_EC07CR"
            cEC07CR := RetCondEntity(cCampo, cOperation, cValue, cEC07CR)
        EndIf

        If cCampo=="CT2_EC08DB"
            cEC08DB := RetCondEntity(cCampo, cOperation, cValue, cEC08DB)
        EndIf

        If cCampo$"CT2_EC08CR"
            cEC08CR := RetCondEntity(cCampo, cOperation, cValue, cEC08CR)
        EndIf

        If cCampo=="CT2_EC09DB"
            cEC09DB := RetCondEntity(cCampo, cOperation, cValue, cEC09DB)
        EndIf

        If cCampo$"CT2_EC09CR"
            cEC09CR := RetCondEntity(cCampo, cOperation, cValue, cEC09CR)
        EndIf
    EndIf  
Next nI    

cWhere += WhereEntity(cDebito, cCredit, cDebCred)
cWhere += WhereEntity(cCCD   , cCCC,    cDebCred)
cWhere += WhereEntity(cItemD , cItemC,  cDebCred)
cWhere += WhereEntity(cClVlDB, cClVlCR, cDebCred)
cWhere += WhereEntity(cEC05DB, cEC05CR, cDebCred)
cWhere += WhereEntity(cEC06DB, cEC06CR, cDebCred)
cWhere += WhereEntity(cEC07DB, cEC07CR, cDebCred)
cWhere += WhereEntity(cEC08DB, cEC08CR, cDebCred)
cWhere += WhereEntity(cEC09DB, cEC09CR, cDebCred)


If !Empty(cWhere)
    cWhere := Left(cwhere,Len(cWhere)-4)
EndIf

Return cWhere

//-------------------------------------------------------------------
/*/{Protheus.doc} RetCondEntity
Retorna a condição SQL para os campos de entidades contábeis

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function RetCondEntity(cCampo as Character, cOperation as Character, cValue as Character, cCondSQL as Character)
Local cRet := ""
Local nI   := 0
Local nTamCpo := TamSX3(cCampo)[1]
Local aValue  := {}

DEFAULT cCampo    := ""
DEFAULT cOperation:= ""
DEFAULT cValue    := ""
DEFAULT cCondSQL  := ""

cRet := cCondSQL

If cOperation == "IN" .Or. cOperation == "NOT IN"            
    If !Empty(cValue)        
        If !Empty(cRet)
            cRet += " AND "
        EndIf
    
        aValue := StrTokArr( cValue , ",")        
        
        cValue := ""
        
        For nI := 1 to Len(aValue)
            If nI>1
                cValue += ","
            EndIf
            cValue += "'"+PadR(AllTrim(aValue[nI]),nTamCpo)+"'"           
        Next                    

        cRet += cCampo+" "+cOperation+"("+cValue+")"
    EndIf       
Else
    If !Empty(cRet)
        cRet +=" AND "
    EndIf

    cRet += cCampo+cOperation+"'"+PadR(AllTrim(cValue),nTamCpo)+"'"
EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} WhereEntity
Monta o Where dos grupos de entidade

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function WhereEntity(cDebito as Character, cCredit as Character, cDebCred as Character)
Local cWhere := ""

DEFAULT cDebito := ""
DEFAULT cCredit := ""
DEFAULT cDebCred := ""

If cDebCred == '1' // Condição Débito
    If !Empty(cDebito)
        cWhere := "("+cDebito+") "
    EndIf

    If !Empty(cWhere)
        cWhere := "("+cWhere+") AND "
    EndIf
ElseIf cDebCred == '2' // Condição Crédito
    If !Empty(cCredit)
        cWhere := "("+cCredit+") "
    EndIf

    If !Empty(cWhere)
        cWhere := "("+cWhere+") AND "
    EndIf
Else
    If !Empty(cDebito)
        cWhere := "("+cDebito+") "
    EndIf

    If !Empty(cCredit)
        If !Empty(cWhere)
            cWhere += " OR "
        EndIf
        cWhere += "("+cCredit+") "
    EndIf

    If !Empty(cWhere)
        cWhere := "("+cWhere+") AND "
    EndIf    
EndIf

Return cWhere
