#include 'tlpp-core.th'
#include 'pc.mingle.integrator.ch'

namespace portal.cliente.util.mingle

/*/{Protheus.doc} MingleIntegrator
  Classe responsável pela integração com o Mingle.

  @type class
  @version 1.0 
  @author alison.kaique
  @since 05/05/2021
/*/
Class MingleIntegrator
  Data cClientID As Character // código do cliente no Mingle
  Data cAppID    As Character // código do aplicativo no Mingle
  Data cToken    As Character // token de autenticação do Mingle
  Data cIUser    As Character // login do usuário integrador
  Data oError    As Object // instância da Classe MingleError
  Data oRest     As Object // instância da Classe FWRest

  /*construtores*/
  Public  Method New() // construtor da classe

  /*getters e setters*/
  Public  Method getClientID() // retorna do código do cliente no Mingle
  Public  Method setClientID() // atualização do código do cliente no Mingle
  Public  Method getAppID() // retorna o código do aplicativo no Mingle
  Public  Method setAppID() // atualização do código do aplicativo no Mingle
  Public  Method getErrorMessage() // retorna a mensagem de erro
  Private Method setErrorMessage() // atualização da mensagem de erro

  /*requisições e processos*/
  Public Method getMUserPublicByLogin() // retorna dados do usuário Mingle Public a partir do seu login
  Public Method createMUserPublic() // criação de usuário Mingle Public
  Public Method getURLMingle()
EndClass

/*/{Protheus.doc} MingleIntegrator::New
  Construtor da Classe.

  @type method
  @version 1.0
  @author alison.kaique
  @since 05/05/2021

  @return Self, object, Instância da Classe
/*/
Method New() Class MingleIntegrator
  Self:cClientID := ""
  Self:cAppID    := ""
  Self:cToken    := AllTrim(GetMV('MV_MINGTOK', .F., ''))
  Self:cIUser    := AllTrim(GetMV('MV_MINGIUS', .F., ''))
  Self:oError    := MingleError():New()
Return Self

/*/{Protheus.doc} MingleIntegrator::getClientID
  Retorna a código do cliente no Mingle

  @type method
  @version 1.0
  @author alison.kaique
  @since 05/05/2021
  
  @return cClientID, character, código do cliente no Mingle
/*/
Method getClientID() Class MingleIntegrator
Return Self:cClientID

/*/{Protheus.doc} MingleIntegrator::setClientID
  Atribuição do código do cliente no Mingle

  @param cClientID, character, código do cliente no Mingle

  @type method
  @version 1.0
  @author alison.kaique
  @since 05/05/2021
  
  @return Self, object, Instância da Classe
/*/
Method setClientID(cClientID) Class MingleIntegrator
  Local lRet          As Logical // retorno do método
  Local cParamType    As Character // tipo do dado do parâmetro
  Local cExpectedType As Character // tipo de dado esperado

  cParamType    := ValType(cClientID)
  cExpectedType := "C"

  If typeValidation(cParamType, cExpectedType)
    Self:cClientID := cClientID
    lRet := .T.
  Else
    Self:setErrorMessage("INVALID", STR0001 + cParamType, STR0002 + cExpectedType) // #"Tipo de dado inválido: "#"Tipo de dado esperado: "
    lRet := .F.
  EndIf
Return Self

/*/{Protheus.doc} MingleIntegrator::getAppID
  Retorna a código do aplicativo no Mingle

  @type method
  @version 1.0
  @author alison.kaique
  @since 05/05/2021
  
  @return cAppID, character, código do aplicativo no Mingle
/*/
Method getAppID() Class MingleIntegrator
Return Self:cAppID

/*/{Protheus.doc} MingleIntegrator::setAppID
  Atribuição do código do aplicativo no Mingle

  @param cAppID, character, código do aplicativo no Mingle

  @type method
  @version 1.0
  @author alison.kaique
  @since 05/05/2021
  
  @return Self, object, Instância da Classe
/*/
Method setAppID(cAppID) Class MingleIntegrator
  Local lRet          As Logical // retorno do método
  Local cParamType    As Character // tipo do dado do parâmetro
  Local cExpectedType As Character // tipo de dado esperado

  cParamType    := ValType(cAppID)
  cExpectedType := "C"

  If typeValidation(cParamType, cExpectedType)
    Self:cAppID := cAppID
    lRet := .T.
  Else
    Self:setErrorMessage("INVALID", STR0001 + cParamType, STR0002 + cExpectedType) // #"Tipo de dado inválido: "#"Tipo de dado esperado: "
    lRet := .F.
  EndIf
Return Self

/*/{Protheus.doc} MingleIntegrator::getErrorMessage
  Retorna a Mensagem de Erro

  @type method
  @version 1.0
  @author alison.kaique
  @since 05/05/2021
  
  @return oError, object, instância da Classe MingleError
/*/
Method getErrorMessage() Class MingleIntegrator
Return Self:oError

/*/{Protheus.doc} MingleIntegrator::setErrorMessage
  Atribuição da Mensagem de Erro

  @param cID      , character, ID do erro
  @param cError   , character, descrição do erro
  @param cSolution, character, solução do erro

  @type method
  @version 1.0
  @author alison.kaique
  @since 05/05/2021
/*/
Method setErrorMessage(cID, cError, cSolution) Class MingleIntegrator
  Self:oError:cID          := cID
  Self:oError:cDescription := cError
  Self:oError:cSolution    := cSolution
Return

/*/{Protheus.doc} MingleIntegrator::getMUserPublicByLogin
  Retorna dados do usuário Mingle Public a partir do seu login

  @param cLogin, character, login do usuário
  
  @type method
  @version 1.0
  @author alison.kaique
  @since 06/05/2021

  @return oUser, object, objeto com dados do usuário
/*/
Method getMUserPublicByLogin(cLogin) Class MingleIntegrator
  Local oUser         As Json // usuário retornado pela API
  Local oError        As Json // erro retornado pela API
  Local aHeadStr      As Array // array com os parâmetros do head
  Local cParamType    As Character // tipo do dado do parâmetro
  Local cExpectedType As Character // tipo de dado esperado
  Local cPath         As Character // path da URL
  Local cError        As Character // erro da requisição
  Local cResponse     As Character // response da requisição
  Local cHttpCode     As Character // código de retorno da requsição http

  cParamType    := ValType(cLogin)
  cExpectedType := "C"
  
  If (Empty(Self:cToken))
    Self:setErrorMessage("EMPTYTOKEN", STR0003, STR0004 + "MV_MINGTOK") // #"Token não informado"#"Efetue a checagem do parâmetro: "
  ElseIf typeValidation(cParamType, cExpectedType)
    // path com o login recebido
    cPath := "/api/api/v1/data/musers-public/" + cLogin
    Self:oRest:SetPath(cPath)
    // definição do head
    aHeadStr := {}
    AAdd(aHeadStr, 'x-mingle-integrator-auth: ' + Self:cToken)
    
    //efetuando requisição
    If(Self:oRest:Get(aHeadStr))
      cResponse := Self:oRest:GetResult()
    Else
      cError := AllTrim(Self:oRest:GetLastError())
      If "Unauthorized" $ cError
        Self:setErrorMessage("REQUESTERROR", STR0005 + cError, STR0009) // #"Erro na Requisição: "
      Else
        Self:setErrorMessage("REQUESTERROR", STR0005 + cError, "") // #"Erro na Requisição: "
      EndIf
    EndIf

    // verifica o status de retorno
    cHttpCode := Self:oRest:GetHttpCode()

    If (cHttpCode == "200") // OK
      // efetua o parser do Objeto JSON
      oUser := JsonObject():New()

      cError := oUser:FromJson(cResponse)
      If !(Empty(cError))
        oUser := Nil
        Self:setErrorMessage("PARSERERROR", STR0006 + cError, "") // #"Erro Parser do JSON: "
      EndIf
    ElseIf Empty(cError)
      // efetua o parser do Objeto JSON
      oError := JsonObject():New()
      cError := oError:FromJson(cResponse)
      If !(Empty(cError))
        Self:setErrorMessage("PARSERERROR", STR0006 + cError, "") // #"Erro Parser do JSON: "
      Else
        // retorna o erro da requisição
        cError := getRequestError(oError)
        Self:setErrorMessage("NOTFOUND", STR0005 + cError, "") // #"Erro na Requisição: "
      EndIf
    EndIf
  Else
    Self:setErrorMessage("INVALID", STR0001 + cParamType, STR0002 + cExpectedType) // #"Tipo de dado inválido: "#"Tipo de dado esperado: "
  EndIf
Return oUser

/*/{Protheus.doc} MingleIntegrator::createMUserPublic
  Criação do usuário Mingle Public a partir do seu login e senha

  @param cLogin   , character, login do usuário
  @param cPassword, character, senha do usuário
  
  @type method
  @version 1.0
  @author alison.kaique
  @since 06/05/2021

  @return oUser, object, objeto com dados do usuário
/*/
Method createMUserPublic(cLogin, cPassword, cUserId) Class MingleIntegrator
  Local oUser         As Json // usuário retornado pela API
  Local oError        As Json // erro retornado pela API
  Local oBody         As Json // body da requisição
  Local oLogin        As Json // dados do login
  Local aHeadStr      As Array // array com os parâmetros do head
  Local cParamType    As Character // tipo do dado do parâmetro
  Local cExpectedType As Character // tipo de dado esperado
  Local cPath         As Character // path da URL
  Local cError        As Character // erro da requisição
  Local cBody         As Character // body a ser enviado
  Local cResponse     As Character // response da requisição
  Local cHttpCode     As Character // código de retorno da requsição http
  Local lOk  := .F.   As Logical
  Default cUserId := ''
  cExpectedType := "C"

  If (Empty(Self:cIUser))
    Self:setErrorMessage("EMPTYIUSER", STR0008, STR0004 + "MV_MINGIUS") // #"Usuário Integrador não informado"#"Efetue a checagem do parâmetro: "
  ElseIf (Empty(Self:cToken))
    Self:setErrorMessage("EMPTYTOKEN", STR0003, STR0004 + "MV_MINGTOK") // #"Token não informado"#"Efetue a checagem do parâmetro: "
  ElseIf !(typeValidation(cParamType := ValType(cLogin), cExpectedType))
    Self:setErrorMessage("INVALIDLOGIN", STR0001 + cParamType, STR0002 + cExpectedType) // #"Tipo de dado inválido: "#"Tipo de dado esperado: "
  ElseIf !(typeValidation(cParamType := ValType(cPassword), cExpectedType))
    Self:setErrorMessage("INVALIDPASS", STR0001 + cParamType, STR0002 + cExpectedType) // #"Tipo de dado inválido: "#"Tipo de dado esperado: "
  Else
    // path com o login recebido
    cPath := "/api/api/v1/data/musers-public"
    Self:oRest:SetPath(cPath)
    // definição do head
    aHeadStr := {}
    AAdd(aHeadStr, 'x-mingle-integrator-auth: ' + Self:cToken)
    AAdd(aHeadStr, 'Content-Type: application/json' )

    
    //efetuando requisição Post
    If(EMPTY(cUserId))
      // definição do Body
      oLogin := JsonObject():New()    
      oLogin['login']    := cLogin
      oLogin['password'] := cPassword

      oBody := JsonObject():New()
      oBody['integratorUser'] := Self:cIUser
      oBody['applicationUsers'] := {oLogin}

      // parâmetros do POST
      cBody := oBody:ToJson()
      Self:oRest:SetPostParams(cBody)    
      lOk := Self:oRest:Post(aHeadStr)
    //efetuando requisição Put
    Else
      oBody := JsonObject():New()
      oBody['_id'] := cUserId
      oBody['login']    := cLogin
      oBody['password'] := cPassword    
      // parâmetros do PUT
      cBody := oBody:ToJson()
      //Self:oRest:SetPostParams(cBody)      
      Self:oRest:SetPath(cPath + '/' + cUserId)
      lOk := Self:oRest:Put(aHeadStr, cBody)
    EndIf

    If(lOk)
        cResponse := Self:oRest:GetResult()
    Else
      cError := Self:oRest:GetLastError()
      Self:setErrorMessage("REQUESTERROR", STR0005 + cError, "") // #"Erro na Requisição: "
    EndIf

    // verifica o status de retorno
    cHttpCode := Self:oRest:GetHttpCode()

    If (Left(cHttpCode, 02) == "20" .AND. EMPTY(cUserId)) // OK
      // efetua o parser do Objeto JSON
      oUser := JsonObject():New()

      cError := oUser:FromJson(cResponse)
      If !(Empty(cError))
        oUser := Nil
        Self:setErrorMessage("PARSERERROR", STR0006 + cError, "") // #"Erro Parser do JSON: "
      ElseIf !(Empty(cError := getRequestError(oUser, .T.)))
        oUser := Nil
        Self:setErrorMessage("REQUESTERROR", STR0005 + cError, "") // #"Erro na Requisição: "
      EndIf
    ElseIf(EMPTY(cUserId))
      // efetua o parser do Objeto JSON
      oError := JsonObject():New()

      cError := oError:FromJson(cResponse)
      If !(Empty(cError))
        Self:setErrorMessage("PARSERERROR", STR0006 + cError, "") // #"Erro Parser do JSON: "
      Else
        // retorna o erro da requisição
        cError := getRequestError(oError)
        Self:setErrorMessage("REQUESTERROR", STR0005 + cError, "") // #"Erro na Requisição: "
      EndIf
    EndIf
  EndIf
Return oUser

/*/{Protheus.doc} MingleError
  Classe responsável pelo controle de Erros da integração com Mingle

  @type class
  @version 1.0 
  @author alison.kaique
  @since 05/05/2021
/*/
Class MingleError
  Public Data cID          As Character // ID do erro
  Public Data cDescription As Character // descrição do erro
  Public Data cSolution    As Character // solução do erro

  Public  Method New() // construtor da classe
EndClass

/*/{Protheus.doc} MingleError::New
  Construtor da Classe

  @type method
  @version 1.0
  @author alison.kaique
  @since 05/05/2021

  @return Self, object, Instância da Classe
/*/
Method New() Class MingleError
  Self:cID          := ""
  Self:cDescription := ""
  Self:cSolution    := ""
Return Self

/*/{Protheus.doc} typeValidation
  Validação de Tipo

  @param cParamType   , character, tipo de dado do parâmetro
  @param cExpectedType, character, tipo de dado do esperado

  @type function
  @version 1.0
  @author alison.kaique
  @since 06/05/2021

  @return lRet, logical, .T. para tipos iguais
/*/
Static Function typeValidation(cParamType, cExpectedType)
  Local lRet As Logical // retorno da validação

  lRet := (cParamType == cExpectedType)
Return lRet

/*/{Protheus.doc} getRequestError
  Retorna o Erro da Requisição

  @param oError, object, Objeto de Erro
  @param lEmpty, logical, retorna erro em branco?

  @type function
  @version 1.0
  @author alison.kaique
  @since 06/05/2021

  @return cError, character, erro da requisição
/*/
Static Function getRequestError(oError, lEmpty)
  Local cError As Character // erro da requisição
  Local aUsers As Array // usuários criados
  Local nI     As Numeric // controle do FOR

  Default lEmpty := .F.

  // verifica se possui a propriedade "message"
  If (typeValidation(ValType(oError['message']), "C"))
    cError := oError['message']
  ElseIf (typeValidation(ValType(oError['applicationUsers']), "A"))
    aUsers := oError['applicationUsers']
    cError := ""

    For nI := 01 To Len(aUsers)
      If (typeValidation(ValType(aUsers[nI]['Error']), "C"))
        cError := AllTrim(aUsers[nI]['Error'])
      EndIf
    Next nI
  ElseIf !(lEmpty)
    // retorna a mensagem da erro
    cError := STR0007 // #"Erro indefinido"
  Else
    cError := ""
  EndIf
Return cError

/*/{Protheus.doc} getURLMingle
  Retorna a URL do Mingle
  Produção: "https://mingle.totvs.com.br"
  Desenvolvimento: "https://dev-mingle.totvs.com.br"
  Homologação: "https://hom-mingle.totvs.com.br"

  Retorna string com URL Mingle

  @type Method
  @author francisco.oliveira
  @since 05/10/2022

  @return Retorna a URL do Mingle
/*/

Method getURLMingle(cEnviron As Character) Class MingleIntegrator

  Local cUrlMingle := "" As Character
  Default cEnviron := ""

  If cEnviron == "DEV"
    cUrlMingle := "https://dev-mingle.totvs.com.br"
  ElseIf cEnviron == "HOM"
    cUrlMingle := "https://hom-mingle.totvs.com.br"
  Else
    cUrlMingle := "https://mingle.totvs.com.br"
  Endif

  Self:oRest := FWRest():New(cUrlMingle)
  Self:oRest:SetChkStatus(.F.)

Return cUrlMingle
