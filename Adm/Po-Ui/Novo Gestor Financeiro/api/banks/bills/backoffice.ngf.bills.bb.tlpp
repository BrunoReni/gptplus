#INCLUDE "backoffice.ngf.bills.bb.ch"
#include "protheus.ch"
#INCLUDE "TOTVS.CH"

NAMESPACE totvs.protheus.backoffice.ngf.bills.bb
USING NAMESPACE totvs.protheus.backoffice.ngf.bills.functions

Static __oHashErros as Object
Static __oHashEstadoPagamento as Object
Static __jModelos   as Json

/*/{Protheus.doc} getURLAuth
	URL para token do ambiente de produção e homologação
	@type  Function
	@author renat.ito
	@since 03/01/2023
	@param cEnvironment, character, 1 = produção 2- homologação
	@return cURL, character, url
/*/
Function getURLAuth(cEnvironment as Character) as Character
	Local cURL := "" as Character

	If cEnvironment == "1"
		cURL := "https://oauth.bb.com.br"
	Else
		cURL := "https://oauth.hm.bb.com.br"
	EndIf
Return cURL

/*/{Protheus.doc} getURLAPI
	URL para API do ambiente de produção e homologação
	@type  Function
	@author renat.ito
	@since 03/01/2023
	@param cEnvironment, character, 1 = produção 2- homologação
	@return cURL, character, url
/*/
Function getURLAPI(cEnvironment as Character) as Character
	Local cURL := "" as Character

	If cEnvironment == "1"
		cURL := "https://api-ip.bb.com.br/pagamentos-lote/v1/"
	Else
		cURL := "https://api.hm.bb.com.br/pagamentos-lote/v1/"
	EndIf
Return cURL

/*/{Protheus.doc} getPathAPI
	Path para API do ambiente de producao e homologacao
	@type  Function
	@author renat.ito
	@since 03/01/2023
	@param cModelo, character, modelo
	@param cProperty, character, propriedaded do json que deve ser retornado
	@return cPath, character, url
/*/
Function getPathAPI(cModelo as Character, cProperty as Character) as Character
	Local cPath := "" as Character

	If __jModelos == NIL
		__jModelos := preparaModelos()
	EndIf

	If __jModelos:hasProperty(cModelo)
		cPath := __jModelos[cModelo][cProperty]
	EndIf

Return cPath

/*/{Protheus.doc} getToken
	Método de geração de token de acesso para o Banco do Brasil
	@type functioon
	@author renato.it
	@since 03/01/2023
/*/
Function getToken(cEnvironment as Character, cAppKey as Character, cID as Character, cSecret as Character) as Json
	Local aHeaders := {}                       as Array
	Local cPath    := "/oauth/token"           as Character
	Local cUrlBase := getURLAuth(cEnvironment) as Character
	Local cBasic   := ""                       as Character
	local jToken   := JsonObject():New()       as Json
	local oRestToken                           as Object

	cBasic := Encode64(cID + ":" + cSecret)

	cTokenBody := "grant_type=client_credentials&scope=pagamentos-lote.lotes-requisicao pagamentos-lote.pagamentos-info "
	cTokenBody += "pagamentos-lote.guias-codigo-barras-requisicao pagamentos-lote.transferencias-pix-requisicao "
	cTokenBody += "pagamentos-lote.boletos-requisicao pagamentos-lote.transferencias-info pagamentos-lote.guias-codigo-barras-info "
	cTokenBody += "pagamentos-lote.boletos-info pagamentos-lote.pagamentos-codigo-barras-info pagamentos-lote.transferencias-pix-info "
	cTokenBody += "pagamentos-lote.pix-info pagamentos-lote.devolvidos-info pagamentos-lote.cancelar-requisicao "
	cTokenBody += "pagamentos-lote.transferencias-requisicao pagamentos-lote.pagamentos-guias-sem-codigo-barras-info "
	cTokenBody += "pagamentos-lote.lotes-info pagamentos-lote.pagamentos-guias-sem-codigo-barras-requisicao"

	If !Empty(cAppKey) .And. !Empty(cBasic)
		aadd(aHeaders, 'Content-Type: application/x-www-form-urlencoded')
		aadd(aHeaders, 'Authorization: Basic ' + cBasic)
		cPath += "?gw-dev-app-key=" + cAppKey
		oRestToken := FwRest():New(cUrlBase)
		oRestToken:SetPostParams(cTokenBody)
		oRestToken:SetPath(cPath)
		If oRestToken:Post(aHeaders)
			jToken:FromJSON(oRestToken:GetResult())
		Else
			jToken["error"]   := oRestToken:GetHTTPCode()
			jToken["message"] := oRestToken:GetResult()
		EndIf
	EndIf
Return jToken

/*/{Protheus.doc} validCredentials
	verifica se existe todas as propriedades nas credenciais
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param jCredentials, Json, credenciais do layout
	@return logical, true ou false
/*/
Function validCredentials(jCredentials as Json) as Logical
	Local lCredentials := .F. as Logical
	Local lCertificate := .F. as Logical

	If jCredentials:hasProperty("environment") .And. jCredentials:hasProperty("appKey") .And. jCredentials:hasProperty("clientId") .And. jCredentials:hasProperty("clientSecret")
		If !Empty(jCredentials["environment"]) .And. !Empty(jCredentials["appKey"]) .And. !Empty(jCredentials["clientId"]) .And. !Empty(jCredentials["clientSecret"])
			lCredentials := .T.
		EndIf
	EndIf

	If jCredentials["certificate"]:hasProperty("cert") .And. jCredentials["certificate"]:hasProperty("key")
		If !Empty(jCredentials["certificate"]["cert"]) .And. !Empty(jCredentials["certificate"]["key"])
			lCertificate := .T.
		EndIf
	EndIf

Return lCredentials .And. lCertificate

/*/{Protheus.doc} getBody
	gera as informações conforme o modelo e layout
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param jLayout, Json, layout
	@return cBody, character, body para o request
/*/
Function getBody(jLayout as Json) as Character
	Local cBody   := ""             as Character
	Local cModelo := SEA->EA_MODELO as Character

	If __jModelos == NIL
		__jModelos := preparaModelos()
	EndIf

	If __jModelos:hasProperty(cModelo)
		cBody := &("totvs.protheus.backoffice.ngf.bills.bb." + __jModelos[cModelo]["layout"] + "(jLayout)")
	EndIf

Return cBody

/*/{Protheus.doc} layoutBoleto
	layout para pagamentos de boleto
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param jLayout, json, layout
	@return cBody, character, body para o request
/*/
Function layoutBoleto(jLayout as Json) as Character
	Local jBoleto     := JsonObject():New() As Json
	Local jLancamento := JsonObject():New() As Json
	Local cAux        := "" as character

	jBoleto["numeroRequisicao"]                     := SEA->EA_IDTRANS
	jBoleto["codigoContrato"]                       := AllTrim(SEE->EE_CODEMP)
	jBoleto["numeroAgenciaDebito"]                  := AllTrim(totvs.protheus.backoffice.ngf.bills.functions.getAgenciaSEE())
	jBoleto["numeroContaCorrenteDebito"]            := AllTrim(totvs.protheus.backoffice.ngf.bills.functions.getContaSEE())
	jBoleto["digitoVerificadorContaCorrenteDebito"] := AllTrim(totvs.protheus.backoffice.ngf.bills.functions.getContaAdvSEE())

	jBoleto["lancamentos"] := {}

	// Obrigatorio
	jLancamento["numeroCodigoBarras"]   := AllTrim(SE2->E2_CODBAR)
	jLancamento["dataPagamento"]        := VAL(dateFormat(&(jLayout["titulo"]["dataPagamento"]), "ddmmyyyy"))
	jLancamento["valorPagamento"]   	:= &(jLayout["valores"]["valorPagamento"])
	jLancamento["valorNominal"]			:= SE2->E2_VALOR // Valor original registrado pelo beneficiário do boleto.

	If jLayout["valores"]:hasProperty("valorNominal") .and. !Empty(jLayout["valores"]["valorNominal"])
		jLancamento["valorNominal"] := &(jLayout["valores"]["valorNominal"])
	Endif	
		                                                 
	jLancamento["documentoBeneficiario"]  := Alltrim(SA2->A2_CGC)
	jLancamento["codigoTipoBeneficiario"] := If(Len(jLancamento["documentoBeneficiario"]) > 11 , 2 , 1)    // 1=CPF 2=CNPJ

	// Opcional
	cAux := &(jLayout["titulo"]["numeroDocumentoDebito"])
	If Empty(Val(cAux))
		cAux := SE2->E2_IDCNAB
	EndIf
	jLancamento["numeroDocumentoDebito"] := VAL(cAux) // Campo numérico - Número que será mostrado no extrato da conta do pagador (Opcional)
	jLancamento["codigoSeuDocumento"]    := AllTrim(SE2->E2_IDCNAB)
	jLancamento["valorDesconto"]         := validForMacro(jLayout["valores"]["valorDesconto"], 'valorDesconto', '', "N")
	jLancamento["valorMoraMulta"]        := validForMacro(jLayout["valores"]["valorMulta"], 'valorMoraMulta', '', "N")

	AAdd(jBoleto["lancamentos"], jLancamento)

Return jBoleto:toJson()

/*/{Protheus.doc} send
	comuniacção com as APIS de pagamento
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param cEnvironment, Character, 1= producao 2=homologacao
	@param cBody, Character, bady que sera enviado
	@param cAppKey, Character, appKey do cliente
	@param cCert, Character, caminho do certificado
	@param cKey, Character, caminho da chave certificado
	@param cToken, Character, token para autenticacao
	@return jResult, json, json com a resposta
/*/
Function send(cEnvironment as Character, cBody as Character, cAppKey as Character, cCert as Character, cKey as Character, cToken as Character )
	Local cURL        := getURLAPI(cEnvironment)    as Character
	Local cPath       := getPathAPI(SEA->EA_MODELO, "path") as Character
	Local nProp       := 0                          as Numeric
	Local aProperty   := {}                         as Array
	Local cHeaderRet  := ""                         as Character
	Local jResponse   := JsonObject():New()         as Json
	Local jResult     := JsonObject():New()         as Json
	Local nStatusCode := 0                          as Numeric
	Local nErro       := 0                          as Numeric
	Local cErro       := ""                         as Character
	Local cLog        := ""                         as Character
	Local cStatus     := ""                         as Character
	Local cResponse	  := ""							as Character

	cPath += "?gw-dev-app-key=" + cAppKey

	aHeaders := {}
	aadd(aHeaders, "Content-Type: application/json")
	aadd(aHeaders, "Charset: UTF-8")
	aadd(aHeaders, "Authorization: Bearer " + cToken)

	If cEnvironment == "2"
		cCert := ""
		cKey  := ""
	EndIf

	cResponse := HTTPSPost(cUrl + cPath, cCert, cKey, "", "", EncodeUTF8(cBody), 30, aHeaders, @cHeaderRet)

	If !EMPTY(cResponse)
		cResponse := DecodeUTF8(cResponse)
	Else
		cResponse := STR0274 + IIf(cEnvironment == "2", STR0275, STR0276) //"Falha na comunicação com o Banco do Brasil, verifique com o banco se o serviço de 'Pagamentos em lote' está funcionando corretamente em ambiente de " # "homologação" # "produção"
	Endif

	nStatusCode := HTTPGetStatus(cHeaderRet)

	If nStatusCode == 201
		jResponse:FromJson(DecodeUTF8(cResponse))
		cLog    := STR0003 //"Requisição em processamento pelo Banco"
		cStatus := "V"

		aProperty := jResponse:getNames()

		For nProp := 1 To Len(aProperty)
			If ValType(jResponse[aProperty[nProp]]) == "A"
				If jResponse[aProperty[nProp]][1]:hasProperty("errorCodes")
					For nErro := 1 To Len(jResponse[aProperty[nProp]][1]["errorCodes"])
						cErro += errorCodes(jResponse[aProperty[nProp]][1]["errorCodes"][nErro])
					Next nErro
				EndIf
				If jResponse[aProperty[nProp]][1]:hasProperty("erros")
					For nErro := 1 To Len(jResponse[aProperty[nProp]][1]["erros"])
						cErro += errorCodes(jResponse[aProperty[nProp]][1]["erros"][nErro])
					Next nErro
				EndIf
			EndIf
		Next nProp
		If !Empty(cErro)
			cLog    := cErro
			cStatus := "F"
		EndIf
		jResult := totvs.protheus.backoffice.ngf.bills.payments.prepareResult(cBody, DecodeUTF8(cResponse), nStatusCode, cStatus, cLog)
	Else
		jResult := totvs.protheus.backoffice.ngf.bills.payments.prepareResult(cBody, cResponse, nStatusCode, "F")
	EndIf
Return jResult

/*/{Protheus.doc} liberation
	comuniacção com as APIS de pagamento
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param cEnvironment, Character, 1= producao 2=homologacao
	@param nIDTrans, Numeric, numero da requisicao
	@param cAppKey, Character, appKey do cliente
	@param cCert, Character, caminho do certificado
	@param cKey, Character, caminho da chave certificado
	@param cToken, Character, token para autenticacao
	@return jResult, json, json com a resposta
/*/
Function liberation(cEnvironment as Character, nIDTrans as Numeric, cAppKey as Character, cCert as Character, cKey as Character, cToken as Character )
	Local cURL        := getURLAPI(cEnvironment) as Character
	Local cPath       := "liberar-pagamentos"    as Character
	Local jBody       := JsonObject():New()      as Json
	Local cHeaderRet  := ""                      as Character
	Local jResult     := JsonObject():New()      as Json
	Local nStatusCode := 0                       as Numeric
	Local cLog        := ""                      as Character
	Local cStatus     := ""                      as Character
	Local cBody       := ""                      as Character
	Local cResponse	  := ""						 as Character

	cPath += "?gw-dev-app-key=" + cAppKey

	aHeaders := {}
	aadd(aHeaders, "Content-Type: application/json")
	aadd(aHeaders, "Charset: UTF-8")
	aadd(aHeaders, "Authorization: Bearer " + cToken)
	If cEnvironment == "2"
		cCert := ""
		cKey  := ""
	EndIf

	jBody["numeroRequisicao"] := nIDTrans
	jBody["indicadorFloat"]   := "N"
	cBody := jBody:toJson()
	cResponse := HTTPSPost(cUrl + cPath, cCert, cKey, "", "", EncodeUTF8(cBody), 30, aHeaders, @cHeaderRet)

	nStatusCode := HTTPGetStatus(cHeaderRet)

	If nStatusCode == 200
		cLog    := DecodeUTF8(cResponse)
		cLog    := STR0004 //"Requisição em processamento pelo Banco, liberação efetuada com sucesso"
		cStatus := "V"
		jResult := totvs.protheus.backoffice.ngf.bills.payments.prepareResult(cBody, DecodeUTF8(cResponse), nStatusCode, cStatus, cLog)
	Else
		jResult := totvs.protheus.backoffice.ngf.bills.payments.prepareResult(cBody, DecodeUTF8(cResponse), nStatusCode, "F")
	EndIf
Return jResult

/*/{Protheus.doc} errorCodes
	lista de erros do bb
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param nCode, numeric, número do codigo
	@return cErro, character, mensagem de erro
/*/
Function errorCodes(nCode as Numeric) as Character
	Local cErro := "" as Character
	If __oHashErros == NIL
		__oHashErros := FwHashMap():New()
		__oHashErros:put(1, STR0005) //"Agência de crédito igual a zero. Informe o nº da Agência de Crédito."
		__oHashErros:put(2, STR0006) //"Conta de crédito não é numérica. Informe apenas números."
		__oHashErros:put(3, STR0007) //"Dígito conta de crédito igual a espaços. Informe o DV da conta de crédito."
		__oHashErros:put(4, STR0008) //"CPF não é numérico. Informe apenas números."
		__oHashErros:put(5, STR0009) //"CNPJ não é numérico. Informe apenas números."
		__oHashErros:put(6, STR0010) //"Data do pagamento igual a zeros. Informe a data do pagamento."
		__oHashErros:put(7, STR0011) //"Data do pagamento inválida. Informe uma data de pagamento válida."
		__oHashErros:put(8, STR0012) //"Valor do pagamento não é númerico. Informe apenas números."
		__oHashErros:put(9, STR0013) //"Valor do pagamento igual a zeros. Informe o valor do pagamento."
		__oHashErros:put(10, STR0014) //"Ambos os campos Número Compensação e Número ISPB estão zerados. Informe um dos campos."
		__oHashErros:put(11, STR0015) //"Ambos os campos Número Compensação e Número ISPB foram informados. Informe apenas um dos campos."
		__oHashErros:put(12, STR0016) //"Ambos os campos Finalidade DOC e Finalidade TED estão zerados. Informe um dos campos."
		__oHashErros:put(13, STR0017) //"Ambos os campos Finalidade DOC e Finalidade TED foram informados. Informe apenas um dos campos."
		__oHashErros:put(14, STR0018) //"Número depósito judicial igual a espaços."
		__oHashErros:put(15, STR0019) //"Digito da conta de crédito inválido."
		__oHashErros:put(16, STR0020) //"Ambos os campos CPF e CNPJ foram informados. Informe apenas um dos campos. Caso informado os 2 campos, nas consultas será exibido apenas os dados do CPF."
		__oHashErros:put(17, STR0021) //"Ambos os campos CPF e CNPJ estão zerados. Informe um dos campos."
		__oHashErros:put(18, STR0022) //"Digito do CPF inválido. Verifique o dado informado."
		__oHashErros:put(19, STR0023) //"Dígito do CNPJ inválido. Verifique o dado informado."
		__oHashErros:put(20, STR0024) //"Agência e conta de crédito estão iguais a de débito. Opção não permitida."
		__oHashErros:put(21, STR0025) //"Número Compensação inválido. Verifique o dado informado."
		__oHashErros:put(22, STR0026) //"Número ISPB diferente de zeros. Não informe o nº ISPB."
		__oHashErros:put(23, STR0027) //"Conta de crédito igual a zeros. Informe o número da conta de crédito."
		__oHashErros:put(24, STR0028) //"CPF igual a Zeros. Obrigatório informar o nº do CPF."
		__oHashErros:put(25, STR0029) //"CNPJ diferente de zeros. Não permitido informar CNPJ."
		__oHashErros:put(26, STR0030) //"Conta de crédito diferente de zeros. Não permitido informar Conta de crédito."
		__oHashErros:put(27, STR0031) //"Dígito conta de crédito diferente de espaços. Não informar dígito da conta de crédito."
		__oHashErros:put(28, STR0032) //"Finalidade DOC diferente de zeros. Não informar finalidade DOC."
		__oHashErros:put(29, STR0033) //"Finalidade TED diferente de zeros. Não informar finalidade TED."
		__oHashErros:put(30, STR0034) //"Número Depósito Judicial diferente de espaços. Não informar finalidade Depósito Judicial."
		__oHashErros:put(31, STR0035) //"Número do documento de crédito não é numérico. Informar números."
		__oHashErros:put(32, STR0036) //"Número do documento de débito não é numérico. Informar números."
		__oHashErros:put(33, STR0037) //"CPF não encontrado na base da receita federal"
		__oHashErros:put(34, STR0038) //"CNPJ não encontrado na base da receita federal"
		__oHashErros:put(35, STR0039) //"Conta de poupança não permitido. Para creditar poupança utilize Código Produto igual a 128 - Pagamentos Diversos. "
		__oHashErros:put(36, STR0040) //"Código COMPE deve ser igual a 1"
		__oHashErros:put(37, STR0041) //"Código ISPB deve ser igual a 0"
		__oHashErros:put(38, STR0042) //"Código de barras não é numérico. Informar números."
		__oHashErros:put(39, STR0043) //"Código de barras igual a zeros. Informar números."
		__oHashErros:put(40, STR0044) //"Número de inscrição do pagador não é numérico. Informar números."
		__oHashErros:put(41, STR0045) //"Número de inscrição do beneficiário não é numérico. Informar números."
		__oHashErros:put(42, STR0046) //"Número de inscrição do avalista não é numérico. Informar números."
		__oHashErros:put(43, STR0047) //"Digito do CPF para o pagador inválido. Verifique o nº correto."
		__oHashErros:put(44, STR0048) //"Digito do CPF para o beneficiário inválido. Verifique o nº correto."
		__oHashErros:put(45, STR0049) //"Digito do CPF para o avalista inválido. Verifique o nº correto."
		__oHashErros:put(46, STR0050) //"Digito do CNPJ para o pagador inválido. Verifique o nº correto."
		__oHashErros:put(47, STR0051) //"Digito do CNPJ para o beneficiário inválido. Verifique o nº correto."
		__oHashErros:put(48, STR0052) //"Digito do CNPJ para o avalista inválido. Verifique o nº correto."
		__oHashErros:put(49, STR0053) //"Data do vencimento inválida.  Informar data válida."
		__oHashErros:put(50, STR0054) //"Valor nominal não é numérico. Informar números."
		__oHashErros:put(51, STR0055) //"Valor de desconto não é numérico. Informar números."
		__oHashErros:put(52, STR0056) //"Valor de mora não é numérico. Informar números."
		__oHashErros:put(53, STR0057) //"Data do pagamento deve ser maior ou igual ao dia atual. "
		__oHashErros:put(54, STR0058) //"Número do documento de débito igual a zeros"
		__oHashErros:put(55, STR0059) //"Data do vencimento igual a zeros. Informar data de vencimento."
		__oHashErros:put(56, STR0060) //"Nome do beneficiário não informado"
		__oHashErros:put(57, STR0061) //"Número de inscrição do beneficiário não informado. Obrigatório informar o CPF ou CNPJ do beneficiário"
		__oHashErros:put(58, STR0062) //"Conta pagamento diferente de espaços. Não informar conta pagamento."
		__oHashErros:put(59, STR0063) //"Ambos os campos conta de crédito e conta pagamento foram informados. Informar apenas um dos campos."
		__oHashErros:put(60, STR0064) //"Transação cancelada pelo cliente"
		__oHashErros:put(61, STR0065) //"Código da Receita do Tributo não informado"
		__oHashErros:put(62, STR0066) //"Tipo de Identificação do Contribuinte não informado"
		__oHashErros:put(63, STR0067) //"Nº de Identificação do Contribuinte não informado"
		__oHashErros:put(64, STR0068) //"Nº de Identificação do Contribuinte não numérico"
		__oHashErros:put(65, STR0069) //"Código de Identificação do Tributo não informado"
		__oHashErros:put(66, STR0070) //"Período de apuração não informado"
		__oHashErros:put(67, STR0071) //"Numero de Referência não informado"
		__oHashErros:put(68, STR0072) //"Valor Principal não é numérico"
		__oHashErros:put(69, STR0073) //"Valor Principal não informado"
		__oHashErros:put(70, STR0074) //"Valor da Multa não é numérico"
		__oHashErros:put(71, STR0075) //"Valor dos Juros/Encargos não é numérico"
		__oHashErros:put(72, STR0076) //"Data de Vencimento não informada"
		__oHashErros:put(73, STR0077) //"Mês e ano de competência não informados"
		__oHashErros:put(74, STR0078) //"Valor previsto do pagamento do INSS não é numérico"
		__oHashErros:put(75, STR0079) //"Valor previsto do pagamento do INSS não informado"
		__oHashErros:put(76, STR0080) //"Valor de Outras Entidades não é numérico"
		__oHashErros:put(77, STR0081) //"Valor de Atualização Monetária não é numérico"
		__oHashErros:put(78, STR0082) //"Valor de Atualização Monetária não é numérico"
		__oHashErros:put(79, STR0083) //"Período de apuração inválido"
		__oHashErros:put(80, STR0084) //"Conta de crédito inválida. Informe o numero sem o 45 do início."
		__oHashErros:put(81, STR0085) //"A conta informada não pertence ao funcionário."
		__oHashErros:put(82, STR0086) //"Pagamento permitido apenas para pessoas físicas."
		__oHashErros:put(83, STR0087) //"Agência e Conta incorretos."
		__oHashErros:put(84, STR0088) //"A conta informada não está ativa."
		__oHashErros:put(85, STR0089) //"Conta não permite crédito de salário. Informe outra conta."
		__oHashErros:put(86, STR0090) //"Ambos os campos agência de crédito e conta pagamento foram informados"
		__oHashErros:put(90, STR0091) //"Mês de competência inválido"
		__oHashErros:put(91, STR0092) //"Valor de outras deduções inválido"
		__oHashErros:put(92, STR0093) //"Valor de outros acréscimos inválido"
		__oHashErros:put(93, STR0094) //"Código da forma de identificação do cliente não foi informado"
		__oHashErros:put(94, STR0095) //"DDD do cliente do Pix não foi informado"
		__oHashErros:put(95, STR0096) //"Telefone do Cliente do Pix não foi informado"
		__oHashErros:put(96, STR0097) //"Email do cliente do Pix não foi informado"
		__oHashErros:put(97, STR0098) //"Chave Aleatória do Cliente do Pix não foi informado"
		__oHashErros:put(98, STR0099) //"Código de tipo de conta do Cliente do Pix não foi informado"
		__oHashErros:put(99, STR0100) //"Consultar o Banco para detalhar o erro"
		__oHashErros:put(100, STR0101) //"E-mail inválido"
		__oHashErros:put(101, STR0102) //"Email do cliente do PIX não deve conter caractere especial"
		__oHashErros:put(102, STR0103) //"Telefone Inválido"
		__oHashErros:put(103, STR0104) //"DDD inválido"
		__oHashErros:put(104, STR0105) //"E-mail com tamanho maior que 77 caracteres."
		__oHashErros:put(105, STR0106) //"Conta de crédito inválida. Informe um número de conta válido."
		__oHashErros:put(106, STR0107) //"CPF inválido. Informe um CPF válido."
		__oHashErros:put(107, STR0108) //"CNPJ inválido. Informe um CNPJ válido."
		__oHashErros:put(108, STR0109) //"Número do documento de crédito inválido. Informe um número válido."
		__oHashErros:put(109, STR0110) //"Número do documento de débito inválido. Informe um número válido."
		__oHashErros:put(110, STR0111) //"Valor do pagamento inválido. Informe um valor válido."
		__oHashErros:put(111, STR0112) //"Valor nominal inválido. Informe um valor válido."
		__oHashErros:put(112, STR0113) //"Valor de desconto inválido. Informe um valor válido."
		__oHashErros:put(113, STR0114) //"Valor de mora inválido. Informe um valor válido."
		__oHashErros:put(114, STR0115) //"Número de inscrição do beneficiário inválido. Informe um número válido."
		__oHashErros:put(115, STR0116) //"Número de inscrição do pagador inválido. Informe um número válido."
		__oHashErros:put(116, STR0117) //"Número de inscrição do avalista inválido. Informe um número válido."
		__oHashErros:put(117, STR0118) //"Nº de identifiação do contribuinte DARF inválido. Informe um número válido."
		__oHashErros:put(118, STR0119) //"Número de referência inválido. Informe um número válido."
		__oHashErros:put(119, STR0120) //"Valor principal inválido. Informe um valor válido."
		__oHashErros:put(120, STR0121) //"Valor da multa inválido. Informe um valor válido."
		__oHashErros:put(121, STR0122) //"Valor dos juros/encargos inválido. Informe um valor válido."
		__oHashErros:put(122, STR0123) //"Nº de identificação do contribuinte GPS inválido. Informe um número válido."
		__oHashErros:put(123, STR0124) //"Valor previsto do pagamento do INSS inválido. Informe um valor válido."
		__oHashErros:put(124, STR0125) //"Valor de outras entidades inválido. Informe um valor válido."
		__oHashErros:put(125, STR0126) //"Valor de atualização monetária inválido. Informe um valor válido."
		__oHashErros:put(126, STR0127) //"Valor de desconto GRU inválido. Informe um valor válido."
		__oHashErros:put(200, STR0128) //"Insuficiência de Fundos - Débito Não Efetuado"
		__oHashErros:put(201, STR0129) //"Crédito ou Débito Cancelado pelo Pagador"
		__oHashErros:put(202, STR0130) //"Débito Autorizado pela Agência - Efetuado"
		__oHashErros:put(203, STR0131) //"Controle Inválido. Verificar campos 01, 02 e 03 do header ou segmento A, B, C, J, J52, N, O ou W do Arquivo CNAB240. Limitação de 80 carecteres para uso nos canais logados BB.Controle Inválido. Vide campos 01,02 e 03 do header/segmento do Arquivo CNAB240"
		__oHashErros:put(204, STR0132) //"Tipo de Operação Inválido"
		__oHashErros:put(205, STR0133) //"Tipo de Serviço Inválido. Utilize 20 para Pagamento a Fornecedores, 30 Pagamento de Salários ou 98 Pagamentos Diversos"
		__oHashErros:put(206, STR0134) //"Forma de Lançamento Inválida. Para crédito em Poupança utilize Pagamentos Diversos. Para crédito em Conta Pagamento utilize Pagamentos Diversos ou Pagamento a Fornecedores. Para Pagamento de salário a conta de crédito deve ser do BB. "
		__oHashErros:put(207, STR0135) //"Tipo/Número de Inscrição Inválido. CPF ou CNPJ inválido."
		__oHashErros:put(208, STR0136) //"Código de Convênio Inválido"
		__oHashErros:put(209, STR0137) //"Agência/Conta Corrente/DV Inválido"
		__oHashErros:put(210, STR0138) //"Nº Sequencial do Registro no Lote Inválido"
		__oHashErros:put(211, STR0139) //"Código de Segmento de Detalhe Inválido"
		__oHashErros:put(212, STR0140) //"Lançamento inconsistente, rejeitado na prévia.Corrigir os dados do lançamento e enviar novo pagamento."
		__oHashErros:put(213, STR0141) //"Nº Compe do Banco para crédito Inválido"
		__oHashErros:put(214, STR0142) //"Nº do ISPB Banco, Instituição de Pagamento para crédito Inválido"
		__oHashErros:put(215, STR0143) //"Agência Mantenedora da Conta Corrente do Favorecido Inválida"
		__oHashErros:put(216, STR0144) //"Conta Corrente/DV/Conta de Pagamento do Favorecido Inválido"
		__oHashErros:put(217, STR0145) //"Nome do Favorecido Não Informado"
		__oHashErros:put(218, STR0146) //"Data Lançamento Inválido"
		__oHashErros:put(219, STR0147) //"Tipo/Quantidade da Moeda Inválido"
		__oHashErros:put(220, STR0148) //"Valor do Lançamento Inválido"
		__oHashErros:put(221, STR0149) //"Aviso ao Favorecido - Identificação Inválida"
		__oHashErros:put(222, STR0150) //"Tipo/Número de Inscrição do Favorecido Inválido CPF ou CNPJ do favorecido inválido."
		__oHashErros:put(223, STR0151) //"Logradouro do Favorecido Não Informado"
		__oHashErros:put(224, STR0152) //"Nº do Local do Favorecido Não Informado"
		__oHashErros:put(225, STR0153) //"Cidade do Favorecido Não Informada"
		__oHashErros:put(226, STR0154) //"CEP/Complemento do Favorecido Inválido"
		__oHashErros:put(227, STR0155) //"Sigla do Estado do Favorecido Inválida"
		__oHashErros:put(228, STR0156) //"Nº do Banco para crédito Inválido "
		__oHashErros:put(229, STR0157) //"Código/Nome da Agência Depositária Não Informado"
		__oHashErros:put(230, STR0158) //"Seu Número Inválido"
		__oHashErros:put(231, STR0159) //"Nosso Número Inválido"
		__oHashErros:put(232, STR0160) //"Inclusão Efetuada com Sucesso"
		__oHashErros:put(233, STR0161) //"Alteração Efetuada com Sucesso"
		__oHashErros:put(234, STR0162) //"Exclusão Efetuada com Sucesso"
		__oHashErros:put(235, STR0163) //"Agência/Conta Impedida Legalmente"
		__oHashErros:put(236, STR0164) //"Empresa não pagou salário Conta de crédito só aceita pagamento de salário"
		__oHashErros:put(237, STR0165) //"Falecimento do mutuário"
		__oHashErros:put(238, STR0166) //"Empresa não enviou remessa do mutuário"
		__oHashErros:put(239, STR0167) //"Empresa não enviou remessa no vencimento"
		__oHashErros:put(240, STR0168) //"Valor da parcela inválida"
		__oHashErros:put(241, STR0169) //"Identificação do contrato inválida"
		__oHashErros:put(242, STR0170) //"Operação de Consignação Incluída com Sucesso"
		__oHashErros:put(243, STR0171) //"Operação de Consignação Alterada com Sucesso"
		__oHashErros:put(244, STR0172) //"Operação de Consignação Excluída com Sucesso"
		__oHashErros:put(245, STR0173) //"Operação de Consignação Liquidada com Sucesso"
		__oHashErros:put(246, STR0174) //"Reativação Efetuada com Sucesso"
		__oHashErros:put(247, STR0175) //"Suspensão Efetuada com Sucesso"
		__oHashErros:put(248, STR0176) //"Código de Barras - Código do Banco Inválido"
		__oHashErros:put(249, STR0177) //"Código de Barras - Código da Moeda Inválido"
		__oHashErros:put(250, STR0178) //"Código de Barras - Dígito Verificador Geral Inválido"
		__oHashErros:put(251, STR0179) //"Código de Barras - Valor do Título Inválido"
		__oHashErros:put(252, STR0180) //"Código de Barras - Campo Livre Inválido"
		__oHashErros:put(253, STR0181) //"Valor do Documento Inválido"
		__oHashErros:put(254, STR0182) //"Valor do Abatimento Inválido"
		__oHashErros:put(255, STR0183) //"Valor do Desconto Inválido"
		__oHashErros:put(256, STR0184) //"Valor de Mora Inválido"
		__oHashErros:put(257, STR0185) //"Valor da Multa Inválido"
		__oHashErros:put(258, STR0186) //"Valor do IR Inválido"
		__oHashErros:put(259, STR0187) //"Valor do ISS Inválido"
		__oHashErros:put(260, STR0188) //"Valor do IOF Inválido"
		__oHashErros:put(261, STR0189) //"Valor de Outras Deduções Inválido"
		__oHashErros:put(262, STR0190) //"Valor de Outros Acréscimos Inválido"
		__oHashErros:put(263, STR0191) //"Valor do INSS Inválido"
		__oHashErros:put(264, STR0192) //"Lote Não Aceito"
		__oHashErros:put(265, STR0193) //"Inscrição da Empresa Inválida para o Contrato"
		__oHashErros:put(266, STR0194) //"Convênio com a Empresa Inexistente/Inválido para o Contrato"
		__oHashErros:put(267, STR0195) //"Agência/Conta Corrente da Empresa Inexistente/Inválido para o Contrato"
		__oHashErros:put(268, STR0196) //"Tipo de Serviço Inválido para o Contrato"
		__oHashErros:put(269, STR0197) //"Conta Corrente da Empresa com Saldo Insuficiente"
		__oHashErros:put(270, STR0198) //"Lote de Serviço Fora de Sequência"
		__oHashErros:put(271, STR0199) //"Lote de Serviço Inválido"
		__oHashErros:put(272, STR0200) //"Arquivo não aceito"
		__oHashErros:put(273, STR0201) //"Tipo de Registro Inválido"
		__oHashErros:put(274, STR0202) //"Código Remessa / Retorno Inválido"
		__oHashErros:put(275, STR0203) //"Versão de layout inválida"
		__oHashErros:put(276, STR0204) //"Mutuário não identificado"
		__oHashErros:put(277, STR0205) //"Tipo do beneficio não permite empréstimo"
		__oHashErros:put(278, STR0206) //"Beneficio cessado/suspenso"
		__oHashErros:put(279, STR0207) //"Beneficio possui representante legal"
		__oHashErros:put(280, STR0208) //"Beneficio é do tipo PA (Pensão alimentícia)"
		__oHashErros:put(281, STR0209) //"Quantidade de contratos permitida excedida"
		__oHashErros:put(282, STR0210) //"Beneficio não pertence ao Banco informado"
		__oHashErros:put(283, STR0211) //"Início do desconto informado já ultrapassado"
		__oHashErros:put(284, STR0212) //"Número da parcela inválida"
		__oHashErros:put(285, STR0213) //"Quantidade de parcela inválida"
		__oHashErros:put(286, STR0214) //"Margem consignável excedida para o mutuário dentro do prazo do contrato"
		__oHashErros:put(287, STR0215) //"Empréstimo já cadastrado"
		__oHashErros:put(288, STR0216) //"Empréstimo inexistente"
		__oHashErros:put(289, STR0217) //"Empréstimo já encerrado"
		__oHashErros:put(290, STR0218) //"Arquivo sem trailer"
		__oHashErros:put(291, STR0219) //"Mutuário sem crédito na competência"
		__oHashErros:put(292, STR0220) //"Não descontado - outros motivos"
		__oHashErros:put(293, STR0221) //"Retorno de Crédito não pago"
		__oHashErros:put(294, STR0222) //"Cancelamento de empréstimo retroativo"
		__oHashErros:put(295, STR0223) //"Outros Motivos de Glosa"
		__oHashErros:put(296, STR0224) //"Margem consignável excedida para o mutuário acima do prazo do contrato"
		__oHashErros:put(297, STR0225) //"Mutuário desligado do empregador"
		__oHashErros:put(298, STR0226) //"Mutuário afastado por licença"
		__oHashErros:put(299, STR0227) //"Primeiro nome do mutuário diferente do primeiro nome do movimento do censo ou diferente da base de Titular do Benefício"
		__oHashErros:put(300, STR0228) //"Benefício suspenso/cessado pela APS ou Sisobi"
		__oHashErros:put(301, STR0229) //"Benefício suspenso por dependência de cálculo"
		__oHashErros:put(302, STR0230) //"Benefício suspenso/cessado pela inspetoria/auditoria"
		__oHashErros:put(303, STR0231) //"Benefício bloqueado para empréstimo pelo beneficiário"
		__oHashErros:put(304, STR0232) //"Benefício bloqueado para empréstimo por TBM"
		__oHashErros:put(305, STR0233) //"Benefício está em fase de concessão de PA ou desdobramento"
		__oHashErros:put(306, STR0234) //"Benefício cessado por óbito"
		__oHashErros:put(307, STR0235) //"Benefício cessado por fraude"
		__oHashErros:put(308, STR0236) //"Benefício cessado por concessão de outro benefício"
		__oHashErros:put(309, STR0237) //"Benefício cessado: estatutário transferido para órgão de origem"
		__oHashErros:put(310, STR0238) //"Empréstimo suspenso pela APS"
		__oHashErros:put(311, STR0239) //"Empréstimo cancelado pelo banco"
		__oHashErros:put(312, STR0240) //"Crédito transformado em PAB"
		__oHashErros:put(313, STR0241) //"Término da consignação foi alterado"
		__oHashErros:put(314, STR0242) //"Fim do empréstimo ocorreu durante período de suspensão ou concessão"
		__oHashErros:put(315, STR0243) //"Empréstimo suspenso pelo banco"
		__oHashErros:put(316, STR0244) //"Não averbação de contrato - quantidade de parcelas/competências informadas ultrapassou a data limite da extinção de cota do dependente titular de benefícios"
		__oHashErros:put(317, STR0245) //"Lote Não Aceito - Totais do Lote com Diferença"
		__oHashErros:put(318, STR0246) //"Título Não Encontrado"
		__oHashErros:put(319, STR0247) //"Identificador Registro Opcional Inválido"
		__oHashErros:put(320, STR0248) //"Código Padrão Inválido"
		__oHashErros:put(321, STR0249) //"Código de Ocorrência Inválido"
		__oHashErros:put(322, STR0250) //"Complemento de Ocorrência Inválido"
		__oHashErros:put(323, STR0251) //"Alegação já Informada"
		__oHashErros:put(324, STR0252) //"Agência / Conta do Favorecido Substituída"
		__oHashErros:put(325, STR0253) //"Divergência entre o primeiro e último nome do beneficiário versus primeiro e último nome na Receita Federal"
		__oHashErros:put(326, STR0254) //"Confirmação de Antecipação de Valor"
		__oHashErros:put(327, STR0255) //"Antecipação parcial de valor"
		__oHashErros:put(328, STR0256) //"Boleto bloqueado na base. Não passível de pagamento."
		__oHashErros:put(329, STR0257) //"Sistema em contingência - Boleto valor maior que referência"
		__oHashErros:put(330, STR0258) //"Sistema em contingência - Boleto vencido"
		__oHashErros:put(331, STR0259) //"Sistema em contingência - Boleto indexado"
		__oHashErros:put(332, STR0260) //"Beneficiário divergente."
		__oHashErros:put(333, STR0261) //"Limite de pagamentos parciais do boleto excedido. Consulte o Beneficiário do boleto."
		__oHashErros:put(334, STR0262) //"Boleto já liquidado. Não passível de pagamento."
		__oHashErros:put(999, STR0263) //"Consultar o Banco para detalhar o erro"
	EndIf
	If nCode > 0
		cErro := __oHashErros:get(nCode) + chr(13)+chr(10)
	EndIf
Return cErro

/*/{Protheus.doc} ValidBorderoBB
	Validações para inclusão do bordero para o Banco do Brasil
	@type  Function
	@author Vitor Duca
	@since 09/01/2023
	@version 1.0
	@param cModelo, Character, Codigo do modelo de pagamento (Tabela 58 SX5)
	@return lRet, Logical, Define se o modelo selecionado podera ser usado na geração do bordero
/*/
Function ValidBorderoBB(cModelo As Character) As Logical
	Local lRet As Logical
	Local aModelos As Array
	Local nModelos As Numeric

	lRet := .F.
	aModelos := {}
	nModelos := 0

	If __jModelos == NIL
		__jModelos := preparaModelos()
	Endif

	aModelos := __jModelos:getNames()

	For nModelos := 1 to len(aModelos)
		If Alltrim(cModelo) == aModelos[nModelos]
			lRet := .T.
			Exit
		Endif
	Next nModelos

	If !lRet
		HELP(" ", 1, "APIPAGAR",, STR0001, 2, 0, NIL, NIL, NIL, NIL, NIL, {STR0002}) //"Modelo informado não possui registro online de pagamentos para o banco selecionado."#"Selecione um modelo de pagamento válido."
	Endif

Return lRet

/*/{Protheus.doc} preparaModelos
	Prepara objeto com endpoint e layout
	@type  Function
	@author renat.ito
	@since 03/01/2023
	@param cEnvironment, character, 1 = produção 2- homologação
	@return jModelos, json
/*/
Function preparaModelos() as Json
	Local jModelos := JsonObject():new() as Json
	// BOLETO
	jModelos["30"] := JsonObject():new()
	jModelos["30"]["path"] := "lotes-boletos"
	jModelos["30"]["pathret"] := "boletos"
	jModelos["30"]["layout"] := "layoutBoleto"
	jModelos["31"] := JsonObject():new()
	jModelos["31"]["path"] := "lotes-boletos"
	jModelos["31"]["layout"] := "layoutBoleto"
	jModelos["31"]["pathret"] := "boletos"
	// TRNSFERENCIA
	jModelos["01"] := JsonObject():new()
	jModelos["01"]["path"] := "lotes-transferencias"
	jModelos["01"]["pathret"] := "transferencias"
	jModelos["01"]["layout"] := "layoutTransf"
	jModelos["03"] := JsonObject():new()
	jModelos["03"]["path"] := "lotes-transferencias"
	jModelos["03"]["pathret"] := "transferencias"
	jModelos["03"]["layout"] := "layoutTransf"
	jModelos["41"] := JsonObject():new()
	jModelos["41"]["path"] := "lotes-transferencias"
	jModelos["41"]["pathret"] := "transferencias"
	jModelos["41"]["layout"] := "layoutTransf"
	jModelos["43"] := JsonObject():new()
	jModelos["43"]["path"] := "lotes-transferencias"
	jModelos["43"]["pathret"] := "transferencias"
	jModelos["43"]["layout"] := "layoutTransf"
	// GUIA
	jModelos["13"] := JsonObject():new()
	jModelos["13"]["path"] := "lotes-guias-codigo-barras"
	jModelos["13"]["pathret"] := "guias-codigo-barras"
	jModelos["13"]["layout"] := "layoutGuia"
	// DARF
	jModelos["16"] := JsonObject():new()
	jModelos["16"]["path"] := "lotes-darf-normal-preto"
	jModelos["16"]["pathret"] := "darf-preto"
	jModelos["16"]["layout"] := "layoutDarf"
	jModelos["18"] := JsonObject():new()
	jModelos["18"]["path"] := "lotes-darf-normal-preto"
	jModelos["18"]["pathret"] := "darf-preto"
	jModelos["18"]["layout"] := "layoutDarf"
	// GPS
	jModelos["17"] := JsonObject():new()
	jModelos["17"]["path"] := "lotes-gps"
	jModelos["17"]["pathret"] := "gps"
	jModelos["17"]["layout"] := "layoutGps"
Return jModelos

/*/{Protheus.doc} getDadosDefault
	layout para tranferencias
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@return jDados, jSon, json com as informações default das apis
/*/
Function getDadosDefault() as json
	Local jDados := JsonObject():new()

	jDados["numeroRequisicao"]               := SEA->EA_IDTRANS
	jDados["numeroContratoPagamento"]        := AllTrim(SEE->EE_CODEMP)
	jDados["agenciaDebito"]                  := AllTrim(totvs.protheus.backoffice.ngf.bills.functions.getAgenciaSEE())
	jDados["contaCorrenteDebito"]            := AllTrim(totvs.protheus.backoffice.ngf.bills.functions.getContaSEE())
	jDados["digitoVerificadorContaCorrente"] := AllTrim(totvs.protheus.backoffice.ngf.bills.functions.getContaAdvSEE())

Return jDados

/*/{Protheus.doc} layoutTransf
	layout para tranferencias
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param jLayout, json, layout
	@return cBody, character, body para o request
/*/
Function layoutTransf(jLayout as Json) as Character
	Local jTransf AS Json
	Local jLancamento := JsonObject():New() As Json
	Local nTipoPag   := 0 as Numeric

	jTransf := getDadosDefault()

	If SEA->EA_TIPOPAG =='30'
		nTipoPag :=  127          // 127 pagamento de salário
	ElseIf SEA->EA_TIPOPAG =='20'
		nTipoPag :=  126          // 126 pagamento de fornecedores
	Else
		nTipoPag :=  128          // 128 pagamentos diversos
	EndIf

	jTransf["tipoPagamento"]       := nTipoPag
	jTransf["listaTransferencias"] := {}

	If jLayout["transferencia"]:hasProperty("bancoCredito")
		jLancamento["numeroCOMPE"] := VAL(&(jLayout["transferencia"]["bancoCredito"]))
	Endif
	
	//Transferencia para o BB não precisa mandar as tags
	If jLancamento["numeroCOMPE"] <> 1
		If SEA->EA_MODELO == "03"
			jLancamento["codigoFinalidadeDOC"] := 1
		Else
			jLancamento["codigoFinalidadeTED"] := 10
		Endif	
	Endif

	jLancamento["agenciaCredito"]                 := ALLTRIM(&(jLayout["transferencia"]["agenciaCredito"]))
	jLancamento["contaCorrenteCredito"]           := ALLTRIM(&(jLayout["transferencia"]["contaCorrenteCredito"]))
	jLancamento["digitoVerificadorContaCorrente"] := ALLTRIM(&(jLayout["transferencia"]["digitoVerificadorContaCorrente"]))

	If len(Alltrim(SA2->A2_CGC)) < 14
		jLancamento["cpfBeneficiario"]  := ALLTRIM(SA2->A2_CGC)
	Else
		jLancamento["cnpjBeneficiario"] := ALLTRIM(SA2->A2_CGC)
	EndIf

	jLancamento["dataTransferencia"]  := VAL(dateFormat(&(jLayout["titulo"]["dataPagamento"]), "ddmmyyyy"))
	jLancamento["valorTransferencia"] := &(jLayout["valores"]["valorPagamento"])

	jLancamento['documentoDebito']         :=  VAL(&(jLayout["titulo"]["numeroDocumentoDebito"]))
	jLancamento['documentoCredito']        :=  VAL(&(jLayout["titulo"]["numeroDocumentoDebito"]))

	jLancamento['descricaoTransferencia']  :=  SE2->E2_IDCNAB

	If jLayout["titulo"]:hasProperty("descricaoPagamento")
		jLancamento['descricaoTransferencia'] := &(jLayout["titulo"]["descricaoPagamento"])
	Endif

	AAdd(jTransf["listaTransferencias"], jLancamento)

Return jTransf:toJson()

/*/{Protheus.doc} layoutGuia
	layout para pagamentos de guias com codigo de barras
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param jLayout, json, layout
	@return cBody, character, body para o request
/*/
Function layoutGuia(jLayout as Json) as Character
	Local jGuia      := JsonObject():New()  As Json
	Local jDados                            As Json
	Local jLancamento := JsonObject():New() As Json

	jDados := getDadosDefault()

	jGuia["numeroRequisicao"]                     := jDados["numeroRequisicao"]
	jGuia["codigoContrato"]                       := jDados["numeroContratoPagamento"]
	jGuia["numeroAgenciaDebito"]                  := jDados["agenciaDebito"]
	jGuia["numeroContaCorrenteDebito"]            := jDados["contaCorrenteDebito"]
	jGuia["digitoVerificadorContaCorrenteDebito"] := jDados["digitoVerificadorContaCorrente"]

	jGuia["lancamentos"] := {}

	jLancamento["codigoBarras"]   := AllTrim(SE2->E2_CODBAR)
	jLancamento["dataPagamento"]  := VAL(dateFormat(&(jLayout["titulo"]["dataPagamento"]), "ddmmyyyy"))
	jLancamento["valorPagamento"] := &(jLayout["valores"]["valorPagamento"])

	jLancamento["numeroDocumentoDebito"] := VAL(&(jLayout["titulo"]["numeroDocumentoDebito"]))
	jLancamento["codigoSeuDocumento"]    := SE2->E2_IDCNAB

	AAdd(jGuia["lancamentos"], jLancamento)

Return jGuia:toJson()

/*/{Protheus.doc} layoutGps
	layout para pagamentos de GPS
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param jLayout, json, layout
	@return cBody, character, body para o request
/*/
Function layoutGps(jLayout as Json) as Character
	Local jGuia     := JsonObject():New() As Json
	Local jDados  As Json
	Local jLancamento := JsonObject():New() As Json

	jDados := getDadosDefault()

	jGuia["numeroRequisicao"]                     := jDados["numeroRequisicao"]
	jGuia["codigoContrato"]                       := jDados["numeroContratoPagamento"]
	jGuia["numeroAgenciaDebito"]                  := jDados["agenciaDebito"]
	jGuia["numeroContaCorrenteDebito"]            := jDados["contaCorrenteDebito"]
	jGuia["digitoVerificadorContaCorrenteDebito"] := jDados["digitoVerificadorContaCorrente"]

	jGuia["lancamentos"] := {}
	jLancamento["dataPagamento"]                             := Val(dateFormat(&(jLayout["titulo"]["dataPagamento"]), "ddmmyyyy"))
	jLancamento["valorPagamento"]                            := &(jLayout["valores"]["valorPagamento"])
	jLancamento["numeroDocumentoDebito"]                     := Val(&(jLayout["titulo"]["numeroDocumentoDebito"]))
	jLancamento["codigoSeuDocumento"]                        := SE2->E2_IDCNAB
	jLancamento["textoDescricaoPagamento"]                   := Alltrim(SE2->E2_HIST)
	jLancamento["codigoReceitaTributoGuiaPrevidenciaSocial"] := Val(SE2->E2_RETINS)

	If jLayout["titulo"]:hasProperty("descricaoPagamento")
		jLancamento["textoDescricaoPagamento"] := &(jLayout["titulo"]["descricaoPagamento"])
	Endif

	jLancamento["mesAnoCompetenciaGuiaPrevidenciaSocial"]               := Val(dateFormat(SE2->E2_EMISSAO, "mmyyyy"))
	jLancamento["codigoTipoContribuinteGuiaPrevidenciaSocial"]          := 1
	jLancamento["numeroIdentificacaoContribuinteGuiaPrevidenciaSocial"] := SE2->E2_CNPJRET

	jLancamento["codigoIdentificadorTributoGuiaPrevidenciaSocial"]           := "17" // SEM REFERENCIA NO SISTEMA
	jLancamento["valorPrevistoInstNacSeguridadeSocialGuiaPrevidenciaSocial"] := &(jLayout["valores"]['valorPagamento'])
	jLancamento["valorOutroEntradaGuiaPrevidenciaSocial"]                    := 0
	jLancamento["valorAtualizacaoMonetarioGuiaPrevidenciaSocial"]            := 0

	AAdd(jGuia["lancamentos"], jLancamento)

return jGuia:toJson()

/*/{Protheus.doc} layoutDarf
	layout para pagamentos de DARF
	@type  Function
	@author renato.ito
	@since 03/01/2023
	@param jLayout, json, layout
	@return cBody, character, body para o request
/*/
Function layoutDarf(jLayout as Json) as Character
	Local jDarf       := JsonObject():New() as Json
	Local jLancamento := JsonObject():New() as Json
	Local jDados  As Json
	Local aFilAtu     := {}                 as Array

	jDados := getDadosDefault()

	jDarf["id"]                                   := jDados["numeroRequisicao"]
	jDarf["codigoContrato"]                       := jDados["numeroContratoPagamento"]
	jDarf["numeroAgenciaDebito"]                  := jDados["agenciaDebito"]
	jDarf["numeroContaCorrenteDebito"]            := jDados["contaCorrenteDebito"]
	jDarf["digitoVerificadorContaCorrenteDebito"] := jDados["digitoVerificadorContaCorrente"]

	jDarf["lancamentos"] := {}

	jLancamento["dataPagamento"]           := VAL(dateFormat(&(jLayout["titulo"]["dataPagamento"]), "ddmmyyyy")) // Omitir o zero Ã  esquerda do dia, se houver
	jLancamento["valorPagamento"]          := &(jLayout["valores"]["valorPagamento"])
	jLancamento["numeroDocumentoDebito"]   := Val(&(jLayout["titulo"]["numeroDocumentoDebito"]))
	jLancamento["codigoSeuDocumento"]      := SE2->E2_IDCNAB

	jLancamento["textoDescricaoPagamento"] := Alltrim(SE2->E2_HIST)
	jLancamento["codigoReceitaTributo"]    := Alltrim(SE2->E2_CODRET)

	If jLayout["titulo"]:hasProperty("descricaoPagamento")
		jLancamento["textoDescricaoPagamento"] := &(jLayout["titulo"]["descricaoPagamento"])
	Endif

	jLancamento["codigoTipoContribuinte"]  := 1 // 1 CNPJ
	If jLayout:Hasproperty("filial")
		aFilAtu   := FWArrFilAtu(cEmpAnt, jLayout["filial"])
	Else
		aFilAtu   := FWArrFilAtu()
	EndIf
	jLancamento["numeroIdentificacaoContribuinte"] := AllTrim(aFilAtu[18])
	// Código de identificação do tributo. 18 - somente para Simples (receita 6106) 16 - demais receitas
	If jLancamento["codigoReceitaTributo"] == "6106"
		jLancamento["codigoIdentificadorTributo"] := "18"
	Else
		jLancamento["codigoIdentificadorTributo"] := "16"
	EndIf
	jLancamento["valorPrincipal"]   := SE2->E2_VALOR
	jLancamento["valorMulta"]       := validForMacro(jLayout["valores"]["valorMulta"], 'valorMulta', '', "N")
	jLancamento["valorJuroEncargo"] := validForMacro(jLayout["valores"]["valorJuros"], 'valorJuroEncargo', '', "N")
	jLancamento["dataVencimento"]   := VAL(dateFormat(SE2->E2_VENCTO, "ddmmyyyy"))

	jLancamento["dataApuracao"]   := VAL(dateFormat(SE2->E2_EMISSAO, "ddmmyyyy"))
	jLancamento["numeroReferencia"]   := Val(Transform(SE2->E2_IDCNAB, "9999999999"))

	AAdd(jDarf["lancamentos"], jLancamento)

Return jDarf:toJson()

/*/{Protheus.doc} consult
	consulta de titulos no BB
	@type  Function
	@author jailton.urbano
	@since 10/01/2023
	@param nCode, numeric, número do codigo
	@return cErro, character, mensagem de erro
/*/
Function consult(cEnvironment as Character, cAppKey as Character, cCert as Character, cKey as Character, cToken as Character ) As Json
	Local cURL        := getURLAPI(cEnvironment) 								as Character
	Local cPath       := getPathAPI(SEA->EA_MODELO, 'pathret') 					as Character
	Local cHeaderRet  := ""                      								as Character
	Local jResponse   := JsonObject():New()      								as Json
	Local jResult     := JsonObject():New()      								as Json
	Local nStatusCode := 0                       								as Numeric
	Local nErro		  := 0                       								as Numeric
	Local cLog        := ""                      								as Character
	Local cErro       := ""                      								as Character
	Local cStatus     := ""                      								as Character
	Local cResponse	  := ""						 								as Character
	Local cID 		  := getIdPayment(SEA->EA_APIMSG)							as Character

	cPath += "/" + cValtoChar(cID)
	cPath += "?gw-dev-app-key=" + cAppKey

	aHeaders := {}
	aadd(aHeaders, "Content-Type: application/json")
	aadd(aHeaders, "Charset: UTF-8")
	aadd(aHeaders, "Authorization: Bearer " + cToken)
	If cEnvironment == "2"
		cCert := ""
		cKey  := ""
	EndIf

	cResponse   := HTTPSGet(cUrl + cPath, cCert, cKey, "", "", 30, aHeaders, @cHeaderRet)
	nStatusCode := HTTPGetStatus(cHeaderRet)

	If nStatusCode == 200
		//Removendo as tags que possuem formatação em ascii para não dar erro no momento da conversão para JSON
		cResponse := formatCodeBB(cResponse, '"texto":', .t.)
		jResponse:FromJson(DecodeUTF8(cResponse))

		Do Case
			// Estados de pagamento transitorios, não definem se a operação ocorreu com sucesso ou não
			Case jResponse:hasProperty("estadoPagamento") .And. (jResponse["estadoPagamento"] == "CONSISTENTE" .Or.;
																jResponse["estadoPagamento"] == "AGUARDANDO SALDO")
				cLog    := STR0265 + Lower(AllTrim(jResponse["estadoPagamento"])) //"Requisição em processamento pelo Banco, situação do pagamento "
				cStatus := "V"
			
			// Estado de pagamento onde existe a necessidade de liberação manual
			Case jResponse:hasProperty("estadoPagamento") .And. jResponse["estadoPagamento"] == "PENDENTE"
				cLog    := msgEstadoPagamento(jResponse["estadoPagamento"])
				cStatus := "V"

			//Estados de pagamento de erro que não retornam as mensagens na propriedade listaDevolucao
			Case jResponse:hasProperty("estadoPagamento") .And. jResponse["estadoPagamento"] == "BLOQUEADO" .Or.;
																jResponse["estadoPagamento"] == "CANCELADO" .Or.;
																jResponse["estadoPagamento"] == "DEVOLVIDO" .Or.;
																jResponse["estadoPagamento"] == "VENCIDO"
				cLog    := msgEstadoPagamento(jResponse["estadoPagamento"])
				cStatus := "F"

			Otherwise
				If jResponse:hasProperty("listaDevolucao")
					If Len(jResponse["listaDevolucao"]) > 0
						For nErro := 1 To Len(jResponse["listaDevolucao"])
							cErro += errorCodes(jResponse["listaDevolucao"][nErro]["codigoMotivo"])
						Next nErro
						cLog    := cErro
						cStatus := "F"
					Else
						cLog    := STR0264 //"Pagamento registrado com sucesso pelo Banco"
						cStatus := "S"
					EndIf
				EndIf
		End Case

		jResult := totvs.protheus.backoffice.ngf.bills.payments.prepareResult('', DecodeUTF8(cResponse), nStatusCode, cStatus, cLog)
	Else
		jResult := totvs.protheus.backoffice.ngf.bills.payments.prepareResult('', DecodeUTF8(cResponse), nStatusCode, "V")
	EndIf
Return jResult

/*/{Protheus.doc} formatCodeBB
	ajusta o campo numerico para string, por limitação do appserver, gerava erro pois cortava o numerico em 16 casas
	@type method
	@author jailton.urbano
	@since 28/12/2022
	@return cRet string ajustada
/*/
Function formatCodeBB(cString as Character, cSeparator as Character, lVazio as Logical) As Character
   	Local cRet := "" As Character
    Local nPoSeparator := 0 As Numeric
    Local nTamSeparator := 0 As Numeric
    Local i := 0 As Numeric

    Default lVazio := .F.

    While .T.
        i++
        // localiza a posicao do separador e separa a string encontrada
        nPoSeparator := AT(cSeparator, cString)
        If i == 1
          	nTotalTag := at(',',substr(cString, nPoSeparator))
          	nTamSeparator := len(cSeparator)
          	nTamValue := nTotalTag - nTamSeparator
        EndIf

        If nPoSeparator <> 0
          	cRet +=  LEFT(cString, nPoSeparator - 1)
          	cRet += cSeparator

			If i == 1
				nPosicao := len(cRet)+1
			Else
				nPosicao := nPoSeparator+31
			EndIf

			cString := SUBSTR(cString, nPosicao)

			If lVazio
				cRet += Alltrim(Substr(Space(nTamValue),1,nTamValue-3))+'"'
				nPosicao := nTamValue-3
			Else
				cRet += ' "'+Alltrim(Substr(cString,1,nTamValue-1))+'"'
				nPosicao := nTamValue
			EndIf
			cString := SUBSTR(cString, nPosicao)
          	If Empty(cString)
            	Exit
          	Endif
        Else
            cRet += cString
          	Exit
        Endif
   EndDo

Return cRet

/*/{Protheus.doc} msgEstadoPagamento
	Retorna as mensagens de erro referentes ao estado de pagamento
	@type  Function
	@author Vitor Duca
	@since 03/02/2023
	@version 1.0
	@param cEstadoPagamento, Character, Descrição do estado de pagamento
	@return cMessage, Characte, Mensagem referente ao estado de pagamento
/*/
Function msgEstadoPagamento(cEstadoPagamento As Character) As Character
	Local cMessage := "" as Character

	If __oHashEstadoPagamento == NIL
		__oHashEstadoPagamento := FwHashMap():New()
		__oHashEstadoPagamento:put("BLOQUEADO", STR0267) //"Débito na conta do pagador não efetivado por ocorrência no convênio, inconsistência de data ou falta de saldo"
		__oHashEstadoPagamento:put("AGUARDANDO SALDO", STR0266) // "Débito não efetivado e em verificação de saldo até o horário limite da teimosinha"
		__oHashEstadoPagamento:put("CANCELADO", STR0268) //"Pagamento cancelado pelo cliente conveniado antes da data do crédito"
		__oHashEstadoPagamento:put("DEVOLVIDO", STR0269) //"Pagamento efetuado e posteriormente recusado pelo recebedor. O valor será devolvido para a conta corrente onde ocorreu o débito"
		__oHashEstadoPagamento:put("VENCIDO", STR0270) //"Pagamento não efetuado na data indicada por falta de saldo ou falta de autorização para débito do pagamento na conta do cliente conveniado"
		__oHashEstadoPagamento:put("PENDENTE", "Aguardando liberação para débito do pagamento na conta do cliente conveniado")
	Endif

	If !Empty(cEstadoPagamento)
		cMessage := __oHashEstadoPagamento:get(cEstadoPagamento) + chr(13)+chr(10)
	EndIf

Return cMessage

/*/{Protheus.doc} sendUpdate
	alteração boleto bb
	@type method
	@author rafael.rondon
	@since 28/12/2022
	@return cRet string ajustada
/*/
Function sendUpdate(jLayout As Json, jBolbb As Json,cNewVencto As Character) As Json
	Local jBody 	:= JsonObject():new()	As jSon
	Local jVencto 	:= JsonObject():new()	As jSon
	Local jRespBank	:= JsonObject():new()	As jSon
	Local oObjToken 						As Object
	Local aHeaders	:={}					As Array
	Local cAppKey	:= ""					As Character
	Local cPath		:= ""					As Character
	Local cUrl		:= ""					As Character
	Local cResult	:= ""					As Character
	Local nHttpCode	:= 0					As Numeric

	If FindFunction("HTTPSQuote") // HTTPSQuote utilizada para alteração de boleto bb verbo Patch (Função nova, não existia antes)

		oObjToken  := &("gfin.job.bills.bills():new()")
		oObjToken:setCredentials(jLayout['credentials']:ToJSON())
		oObjToken:token001()

		If (ValType(oObjToken:oToken) == 'J' .or. ValType(oObjToken:oToken) == 'O')

			aHeaders := {}
			aadd(aHeaders, 'Content-Type: application/json')
			aadd(aHeaders, 'Authorization: Bearer ' + oObjToken:oToken['access_token'])
			aadd(aHeaders, "Charset: UTF-8")

			cAppKey := Alltrim(jLayout['credentials']['appKey'])

			cPath := '/cobrancas/v2/boletos'
			cPath += '/' + jBolbb['response']['numero']
			If jLayout['credentials', 'environment'] == '1' // Producao
				cPath += '?' + 'gw-dev-app-key' + '=' + cAppKey
				cUrl := 'https://api.bb.com.br'
			Else
				cPath += '?' + 'gw-app-key' + '=' + cAppKey
				cUrl := 'https://api.hm.bb.com.br'
			EndIf

			jBody['numeroConvenio'] := Val(AllTrim(SEE->EE_CODEMP))
			jBody['indicadorNovaDataVencimento'] := "S"
			jVencto['novaDataVencimento'] := cNewVencto
			jBody['alteracaoData'] := jVencto

			cHttpsQuot := 'HTTPSQuote(cUrl+cPath, "", "", "", "PATCH", "", EncodeUTF8(jBody:ToJSON()), 120, aHeaders, Nil, .F.)'
			cResult    := &cHttpsQuot
			nHttpCode  := HTTPGetStatus(Nil, Nil)
			If nHttpCode == 200 .OR. nHttpCode == 201
				jRespBank['response'] := JsonObject():new()
				jRespBank['response']:FromJSON(DecodeUTF8(cResult))
			Else
				jRespBank['error'] := nHttpCode
				jRespBank['message'] := DecodeUTF8(cResult)
			EndIf
			jRespBank['sent'] := jBody
		Else
			jRespBank['message'] := STR0271 // 'Erro no retorno do token para autenticação.'
		EndIf
	Else
		jRespBank['message'] := STR0272 // 'AppServer não está atualizado para utilizar função HTTPSQuote.'
	EndIf

Return jRespBank

/*/{Protheus.doc} cancel
	cancelemnto boleto bb
	@type method
	@author rafael.rondon
	@since 28/12/2022
	@return cRet string ajustada
/*/
Function cancel(jLayout As Json, jBolbb As Json,cNewVencto As Character) As Json
	Local jBody 	:= JsonObject():new()	As jSon
	Local jRespBank	:= JsonObject():new()	As jSon
	Local oRestBank	:= NIL					As Object
	Local oObjToken	:= Nil					As Object
	Local aHeaders	:={}					As Array
	Local cAppKey	:= ""					As Character
	Local cPath		:= ""					As Character
	Local cUrl		:= ""					As Character

	oObjToken  := &("gfin.job.bills.bills():new()")
	oObjToken:setCredentials(jLayout['credentials']:ToJSON())
	oObjToken:token001()

	If (ValType(oObjToken:oToken) == 'J' .or. ValType(oObjToken:oToken) == 'O')

		aHeaders := {}
		aadd(aHeaders, 'Content-Type: application/json')
		aadd(aHeaders, 'Authorization: Bearer ' + oObjToken:oToken['access_token'])
		aadd(aHeaders, "Charset: UTF-8")

		cAppKey := Alltrim(jLayout['credentials']['appKey'])

		cPath := '/cobrancas/v2/boletos'
		cPath += '/' + jBolbb['response']['numero'] + '/baixar'
		If jLayout['credentials', 'environment'] == '1' // Producao
			cPath += '?' + 'gw-dev-app-key' + '=' + cAppKey
			cUrl := 'https://api.bb.com.br'
		Else
			cPath += '?' + 'gw-app-key' + '=' + cAppKey
			cUrl := 'https://api.hm.bb.com.br'
		EndIf

		jBody['numeroConvenio'] := Val(AllTrim(SEE->EE_CODEMP))

		oRestBank := FwRest():New(cUrl)
		oRestBank:SetPostParams( EncodeUTF8(jBody:ToJSON()))
		oRestBank:SetPath(cPath)
		If oRestBank:Post(aHeaders)
			jRespBank['response'] := JsonObject():new()
			jRespBank['response']:FromJSON(DecodeUTF8(oRestBank:GetResult()))
		Else
			jRespBank["error"]   := oRestBank:GetHTTPCode()
			jRespBank["message"] := DecodeUTF8(oRestBank:GetResult())
		EndIf
		jRespBank['sent'] := jBody

	Else
		jRespBank['message'] := STR0271 // 'Erro no retorno do token para autenticação.'
	EndIf

Return jRespBank

/*/{Protheus.doc} cancelPayment
	Cancelamento do pagamento via API
	Exemplo do body que sera enviado:
	{
		"agenciaDebito": 0,
		"contaCorrenteDebito": 0,
		"digitoVerificadorContaCorrente": "string",
		"listaPagamentos": [
			{
				"codigoPagamento": 0
			}
		],
		"numeroContratoPagamento": 0
	}
	@type  Function
	@author Vitor Duca
	@since 08/01/2023
	@param cEnvironment, Character, 1= producao 2=homologacao
	@param cAppKey, Character, appKey do cliente
	@param cCert, Character, caminho do certificado
	@param cKey, Character, caminho da chave certificado
	@param cToken, Character, token para autenticacao
	@return jResult, json, json com a resposta
/*/
Function cancelPayment(cEnvironment as Character, cAppKey as Character, cCert as Character, cKey as Character, cToken as Character )
	Local cURL        := getURLAPI(cEnvironment)    	as Character
	Local cPath       := "cancelar-pagamentos" 			as Character
	Local cHeaderRet  := ""                         	as Character
	Local jResponse   := JsonObject():New()         	as Json
	Local jResult     := JsonObject():New()         	as Json
	Local nStatusCode := 0                          	as Numeric
	Local cStatus	  := ""								as Character
	Local nErro       := 0                          	as Numeric
	Local cLog        := ""                         	as Character
	Local cResponse	  := ""								as Character
	Local jBody		  := JsonObject():New()				as Json
	Local cID 		  := getIdPayment(SEA->EA_APIMSG)	as Character
	Local aListPayments := {}							as Array
	Local cBody			:= ""							as Character
	Local nPagamentos	:= 0							as Numeric

	Aadd(aListPayments, { "codigoPagamento": cID } )

	jBody := getDadosDefault()
	jBody:DelName("numeroRequisicao")
	jBody["listaPagamentos"]	:= aListPayments

	cPath += "?gw-dev-app-key=" + cAppKey

	aHeaders := {}
	aadd(aHeaders, "Content-Type: application/json")
	aadd(aHeaders, "Charset: UTF-8")
	aadd(aHeaders, "Authorization: Bearer " + cToken)
	If cEnvironment == "2"
		cCert := ""
		cKey  := ""
	EndIf

	cBody := jBody:ToJson()
	cResponse := HTTPSPost(cUrl + cPath, cCert, cKey, "", "", EncodeUTF8(cBody), 30, aHeaders, @cHeaderRet)
	nStatusCode := HTTPGetStatus(cHeaderRet)
	jResponse:FromJson(DecodeUTF8(cResponse))

	If nStatusCode == 200
		For nPagamentos := 1 to Len(jResponse["pagamentos"])
			If Alltrim(Upper(jResponse["pagamentos"][nPagamentos]["indicadorCancelamento"])) == "S"
				cLog    := STR0273 //"Cancelamento efetuado com sucesso"
				cStatus := "S"
			Else
				cLog    := jResponse["pagamentos"][nPagamentos]["estadoCancelamento"] //"Requisição em processamento pelo Banco"
				cStatus := "F"
			Endif
		Next nPagamentos
	Else
		If jResponse:hasProperty("erros") .and. ValType(jResponse["erros"]) == "A"
			For nErro := 1 To Len(jResponse["erros"])
				If jResponse["erros"][nErro]:hasProperty("codigo")
					cLog += "Código: " + jResponse["erros"][nErro]["codigo"] + " "
				EndIf
				If jResponse["erros"][nErro]:hasProperty("mensagem")
					cLog += jResponse["erros"][nErro]["mensagem"] +  chr(13)+chr(10)
				EndIf
			Next nErro
		EndIf
		cStatus := "F"
	EndIf

	jResult := totvs.protheus.backoffice.ngf.bills.payments.prepareResult(cBody, DecodeUTF8(cResponse), nStatusCode, cStatus, cLog)
Return jResult

/*/{Protheus.doc} getIdPayment
	Recupera o id do pagamento que sera utilizado na consulta e no cancelamento
	@type  Function
	@author Vitor Duca
	@since 08/03/2023
	@version 1.0
	@param cEA_APIMSG, Character, Conteudo do campo EA_APIMSG
	@return cID, Character, Id do pagamento registrado no banco
/*/
Function getIdPayment(cEA_APIMSG As Character) as Character
	Local cID 			 := ""				   as Character
	Local jLote          := JsonObject():New() as Json
	Local jUnit          := JsonObject():New() as Json
	Local jEA_APIMSG	 := JsonObject():New() as Json
	Local cJsonRegister  := ""				   As Character

	jEA_APIMSG:FromJson(cEA_APIMSG)
	jLote:fromjson(jEA_APIMSG['log'])

	If jLote:hasProperty('register') .and. ValType(jLote['register']) == "J" .and. jLote['register']:hasProperty('response')
		jUnit:fromjson(jLote['register']['response'])

		If jUnit:hasProperty('transferencias')
			cID := jUnit['transferencias'][1]['identificadorTransferencia']
		ElseIf jUnit:hasProperty('lancamentos')
			cID := jUnit['lancamentos'][1]['codigoIdentificadorPagamento']

			//Ajusta o ID caso seja numerico, pois o tamanho é de 18 e ultrapassa a precisão do appserver
			If Valtype(cID) == "N"
				cJsonRegister := formatCodeBB(jLote['register']['response'], '"codigoIdentificadorPagamento":', .f.)
				jUnit:fromjson(cJsonRegister)
				cID := jUnit['lancamentos'][1]['codigoIdentificadorPagamento']
			EndIf
		EndIf
	Endif

Return cID
