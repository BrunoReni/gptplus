/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³  DATA  ³ BOPS ³Program.³					ALTERACAO				  ³±±
±±ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³29.03.99³      ³Alice   ³ Desabilitar o cria automatico no windows e   ³±±
±±³        ³      ³        ³ na classificacao do 2§ ou proximo aRotina ini³±±
±±³        ³      ³        ³cializar o arotina com 3 (Inclusao).          ³±±
±±³20.04.99³      ³Alice   ³ Alteracao de macro (PROTHEUS).               ³±±
±±³16.11.99³      ³Alice   ³ Alteracao na passagem de parametro no atfmod3³±±
±±³22.12.99³      ³Pilar   ³ Retirar chamada do Windows					  ³±±
±±ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
#Include "ATFA240.CH"
#INCLUDE "Protheus.ch"
#Include "FWLIBVERSION.CH"

#define Confirma 1
#define Redigita 2
#define Abandona 3

//********************************
// Controle de multiplas moedas  *
//********************************
Static lMultMoed := .T.

//Variavel de controle para evitar a rotina chamar novamente a tela de classificação após operação
Static __lMostraTela	:= .T.

//Metricas
Static __lMetric	:= FwLibVersion() >= "20210517" .And. GetSrvVersion() >= "19.3.0.6" //Metricas apenas em Lib a partir de 20210517 e Binario 19.3.0.6
Static oMrkBrowse	

Static __cProcPrinc  	:= "ATFA240"
Static _oATFA0240

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ ATFA240    ³ Autor ³ Alice                 ³ Data ³ 27/01/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Classificacao de Bens                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaatf                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ATFA240(nPosArot, lAutomato)
LOCAL cFilEsp		:= ""
LOCAL cAlias		:= "SN1"
Local lBmContr      := IIf(SN1->(FieldPos("N1_BMCONTR"))>0,.T., .F.) 

Private aRotina := MenuDef()
Private aPos:= {  8,  4, 11, 74 }
Private nOriginal  := 0
Private cMoedaAtf := GetMV("MV_ATFMOED")
Private cFilter    := Nil

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define o cabecalho da tela de atualizacoes                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private cCadastro := STR0004 		//"Classifica‡„o de Ativos Imobilizados"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Vari veis para filtro do browse ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private aIndexFil	:= {}
Private bFiltraBrw
Private cFilPad		:= ""

Default nPosArot	:= 0 //Variável criada para teste de automação
Default lAutomato	:= .F. //Variável criada para teste de automação

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ativa tecla F12 para ativar parametros de lan‡amentos contab.             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

SetKey( VK_F12, { || pergunte("AFA240",.T.)} )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega as perguntas selecionadas                                         ³
//³ mv_par01 - Se mostra ou n„o os lan‡amentos cont beis                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Pergunte("AFA240",.F.)

ATFXKERNEL()

//PONTO DE ENTRADA - FILBROWSE
cFilPad := ".T."
IF ExistBlock("AF240BRW")
	cFilEsp := ExecBlock("AF240BRW",.F.,.F.,cFilPad)
	cFilPad	:= IIF(ValType(cFilEsp) == "C",cFilEsp,cFilPad)
ENDIF

//PONTO DE ENTRADA - MBROWSE
If lBmContr	
	cFilter := " N1_BMCONTR = ' ' "
EndIf
IF ExistBlock("AF240BRT")
	cFilter :=ExecBlock("AF240BRT",.F.,.F.,cFilter)
	cFilter :=IIF(ValType(cFilter) == "C",cFilter,Nil)
ENDIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Endere‡a a fun‡„o de BROWSE ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAutomato .And. nPosArot > 0 //Se for chamada por testes de automação
	DbSelectArea("SN1")
	bBlock := &("{|a,b,c,d| " + aRotina[nPosArot,2] + "(a,b,c,d)}") //Pega a função desejada para automação a partir do Menudef (aRotina)
	Eval (bBlock,cAlias,,3,lAutomato)
Else
	mBrowse( 6, 1,22,75,"SN1",,,,,, Af240Legenda(cAlias),,,,,,,,cFilter)
EndIf	

lClassifica := .F.
SetKey(VK_F12, { || Verdade() } )

If _oATFA0240 <> Nil
	_oATFA0240:Delete()
	_oATFA0240 := Nil
Endif

Return
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ af240Class ³ Autor ³ Alice                 ³ Data ³ 27/01/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Classificacao de Bens                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaatf                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function af240Class( cAlias,nReg,nOpc, lAutomato )
Local nOpca		:= 0
Local cCodAnt		:= SN1->N1_CBASE
Local cItemAnt		:= SN1->N1_ITEM
Local dDataBloq := GetNewPar("MV_ATFBLQM",CTOD(""))
Local cChaveSNN := ""
Local aRetAuto := {} //Array a ser utilizado nos testes de automação
Local aRegAC9	:= {}
Local ny		:= 0

Default lAutomato := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Evita a chamada da tela após a operação³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If !__lMostraTela
	__lMostraTela := .T.
	Return(.T.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Salva a integridade dos campos de Bancos de Dados            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAlias)
IF Reccount() == 0
	Return (.T.)
EndIf

If lAutomato
	If FindFunction("GetParAuto")
		aRetAuto	:= GetParAuto("ATFA240TestCase")
		cAutBase	:= aRetAuto[1][2][2] //Código do Ativo 
		cAutItem	:= aRetAuto[1][3][2] //Item do Ativo 
		nOpca	:= 3
	EndIf
	
	DbSelectArea("SN1")
	DbSetOrder( 1 )
	DbSeek(xFilial("SN1")+cAutBase+cAutItem)
	
EndIf

IF SN1->N1_FILIAL != xFilial("SN1")
	Help(" ",1,"A000FI")
	Return (.T.)
Endif

If !Empty(dDataBloq) .AND. (SN1->N1_AQUISIC <= dDataBloq)
	HELP(" ",1,"AF240BLQM",,STR0015 + DTOC(dDataBloq) ,1,0)    //"A data de aquisição do bem é igual ou menor que a data de bloqueio de movimentação : "
	Return (.T.)
Endif

//Validacao para o bloquei do proceco
If !CtbValiDt(,SN1->N1_AQUISIC  ,,,,{"ATF001"},)
	Return (.T.)
EndIf

If SN1->N1_STATUS $ "2|3"
	Help(" ",1,"AF240BLOQ")   //Este bem esta bloqueado, nao poder sofrer baixas.
	Return (.T.)
EndIf

If Af240JaClas()
	Help(" ",1,"AF240CLASS")
	Return .T.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³  Verifica se o registro n„o est  em uso por outra esta‡„o. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !SoftLock("SN1")
	Return .T.
Endif

If !AtfVldMoed(cMoedaAtf)
	Help(" ",1,"ATFVLDMOED",,STR0037,1,0)//"Parâmetro MV_ATFMOED configurado incorretamente"
	Return .T.
EndIf

If !lAutomato
	Pergunte("AFA012",.f.)	
	SaveInter()	
	aRotina := GetRotAux()	
	nOpca := FWExecView(STR0006, 'ATFA012', 4, /*oDlg*/, { || .T. } )
	RestInter()
Else
	MsExecAuto({|a,b,c| ATFA012(a,b,c)},aRetAuto[1]/*aCab*/, aRetAuto[2]/*aItens*/, 4)
EndIf

// Atualiza o codigo do bem no Planejamento
IF nOpca == 0
	dbSelectArea("SNN")
	cChaveSNN:=IndexKey(2)
	If AllTrim(cChaveSNN) == "NN_FILIAL+NN_CODEFTV+NN_ITMEFTV+NN_CODIGO+NN_ITEM"
		dbSetOrder( 2 )
		If dbSeek(xFilial("SNN")+cCodAnt)
			RecLock("SNN",.F.)
			SNN->NN_CODEFTV:=SN1->N1_CBASE
			SNN->NN_ITMEFTV:=SN1->N1_ITEM
			MsUnlock()
		EndIF
	EndIf
EndIf

// Atualiza o codigo do bem no Conhecimento (AC9)
If cCodAnt+cItemAnt <> SN1->N1_CBASE+SN1->N1_ITEM

	dbSelectarea("AC9")
	AC9->( DbSetOrder( 2 ) ) //AC9_FILIAL + AC9_ENTIDA + AC9_FILENT + AC9_CODENT + AC9_CODOBJ

	If AC9->(DbSeek(xFilial("AC9")+'SN1'+xFilial("SN1")+cCodAnt+cItemAnt) ) 
		
		While AC9->(!EOF() .And. AC9_FILIAL == XFILIAL("AC9") .And. AC9_ENTIDA == 'SN1' .And. AC9_FILENT == xFilial("SN1") .And. Alltrim(AC9_CODENT) == cCodAnt+cItemAnt )
			aAdd(aRegAC9, AC9->( Recno() ) )
			AC9->(dbSkip())		
		Enddo
		
		For ny := 1 to len(aRegAC9)
			AC9->( DbGoto(aRegAC9[ny]) )
			RecLock("AC9",.F.)
			AC9->AC9_CODENT := SN1->N1_CBASE+SN1->N1_ITEM
			MsUnlock()
		Next
	
	Endif
EndIF

//Metrica de quantidade de bens que são classificados que contém ciap
If __lMetric .And. !Empty(SN1->N1_CODCIAP)
	ATF240Metrics("01" /*cEvent*/,/*nStart*/, "001" /*cSubEvent*/, Alltrim(ProcName()) /*cSubRoutine*/)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Este unlock libera o softlock acima deste While. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectarea("SN1")
MsUnlock()
IF nOpca == 0
	If ExistBlock("AF240CLA")
		ExecBlock("AF240CLA",.F.,.F.)
	Endif
Endif

MBrChgLoop(.F.) //Desabilita a chamada da tela de inclusão novamente.

Return nOpca

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Af240Base ³ Autor ³ Vin¡cius Barreira     ³ Data ³ 14/09/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se o novo c¢digo ‚ v lido                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ af240Base()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAATF                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Af240Base(cBasePara,cBaseDe)
If Empty( cBasePara )
	HELP(" ",1,"AFA130Vazi")
	Return .F.
ElseIf cBasePara == cBaseDe
	HELP(" ",1,"AFA130Igua")
	Return .F.
Endif
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Af240Legenda³ Autor ³ Wagner Mobile Costa ³ Data ³ 19.11.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria uma janela contendo a legenda da mBrowse ou retorna a ³±±
±±³          ³ para o BROWSE                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Atfa240                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Af240Legenda(cAlias, nReg)

Local aLegenda := 	{ 	{"BR_PRETO", STR0011 },; //"Bem nao Classificado"
{"BR_VERDE", STR0012 },; //"Bem Classificado"
{"BR_VERMELHO", STR0013 } } //"Bem totalmente baixado"

Local uRetorno := .T.

If nReg = Nil	// Chamada direta da funcao onde nao passa, via menu Recno eh passado
	uRetorno := {}
	Aadd(uRetorno, { '! Empty(N1_BAIXA)' 	, aLegenda[3][1] } )	//Não Classificado
	Aadd(uRetorno, { 'Af240JaClas()'		, aLegenda[2][1] } )	//Classificado
	Aadd(uRetorno, { '.T.'					, aLegenda[1][1] } )
Else
	BrwLegenda(cCadastro, STR0010, aLegenda) //"Legenda"
Endif

Return uRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Af240JaClas ³ Autor ³ Wagner Mobile Costa ³ Data ³ 19.11.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna se o bem ja foi ou nao classificado                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Atfa240                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Af240JaClas()
Local lRet     := .F.
Local aArea    := GetArea()
Local aAreaSN1 := SN1->(GetArea())
Local aAreaSN3 := SN3->(GetArea())

DbSelectArea("SN3")
SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
SN3->(MsSeek(SN1->(N1_FILIAL+N1_CBASE+SN1->N1_ITEM)))

If Alltrim(SN1->N1_ORIGEM) == "ATFA310"
	If SN1->N1_STATUS != "0" // Pendente de Classificação
		lRet := .T.
	EndIf
Else
	If SN1->N1_STATUS # "0" 	// Pendente de Classificação  			//-- JRJ - 20170922
		While SN1->N1_FILIAL+SN1->N1_CBASE+SN1->N1_ITEM == SN3->(N3_FILIAL+N3_CBASE+N3_ITEM) .and. SN3->(!Eof())
			If Val( SN3->N3_BAIXA ) # 0 .or. !Empty(SN3->N3_CCONTAB)
				lRet := .T.
				Exit
			EndIf
			SN3->(dbSkip())
		Enddo
	EndIf																//-- JRJ - 20170922
EndIf


RestArea(aAreaSN3)
RestArea(aAreaSN1)
RestArea(aArea)
Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Ana Paula N. Silva     ³ Data ³29/11/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados     ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³    6 - Acessa cadastro de Bens de Terceiro                 ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()
Local nX		:= 0
Local aAF240BUT := {}
Local aRotina 	:= {{ STR0001, "AxPesqui"  		, 0 , 1 , ,.F.},;     //"Pesquisar"
					{ STR0002, "VIEWDEF.ATFA012", 0 , 2},;        		//"Visualizar"
					{ STR0003, "AF240Class"		, 0 , 3, 43 },;		//"Classificar"
					{ STR0010, "AF240Legenda"	, 0 , 5, ,.F. },;	// "Legenda"
					 {STR0020, "AF240Lote"	    , 0 , 3, ,.F. }}	//"Classificação em Lote",

Aadd(aRotina, { STR0017		, "ATFA320"	, 0, 6, 45 } )	//"Contr. Terceiros"

Aadd(aRotina, { STR0018  , "ATFA321"	, 0, 6, 45 } )	//"Contr.em Terceiros"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ P.E. Utilizado para adicionar botoes ao Menu Principal       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock( "AF240BUT" )
	aAF240BUT := ExecBlock( "AF240BUT", .F., .F., aRotina )
	IF ValType( aAF240BUT ) == "A" .AND. Len( aAF240BUT ) > 0
		For nX := 1 To Len( aAF240BUT )
			aAdd( aRotina, aAF240BUT[ nX ] )
		Next
	ENDIF
Endif

Return(aRotina)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ATF240PRJC   ³Autor ³Rodrigo Gimenes       ³Data³11/11/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se é uma projecao ou compra                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ATF240PRJC()

Local lRetorno := .F.

If !Empty(SN1->N1_STATUS)
	lRetorno := SN1->N1_STATUS == '2' .AND. Alltrim(SN1->N1_ORIGEM) == "ATFA310"
EndIf

Return(lRetorno)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ BemProj      ³Autor ³Rodrigo Gimenes       ³Data³11/11/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se é uma projecao para a Legenda                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function BemProj()

Local lRetorno := .F.

lRetorno := Empty(SN1->N1_BAIXA) .And. !Af240JaClas() .And. ATF240PRJC()


Return(lRetorno)
//-------------------------------------------------------------------
/*/{Protheus.doc}GetRotAux
Cria um menu fake para habilitar a opção de carregar imagem no folder 
FOTO.
O aRotina é restaurado após a execução da View.

@author TOTVS
@since  19/09/2019
@version 12
/*/	
//-------------------------------------------------------------------
Static Function GetRotAux()
Local aRotAux := {{ "", "", 0 , 1},; 
				  { "", "", 0 , 2},; 
				  { "", "", 0 , 3},; 
				  { "", "", 0 , 4},;
				  { "", "", 0 , 5}}
Return aRotAux


/*/{Protheus.doc} ATF012Metrics
	
	ATF012Metrics - Funç?o utilizada para metricas no CTBR400

	@type  Static Function
	@author user
	@since date
	@version version
	@param param, param_type, param_descr
	@return return, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function ATF240Metrics(cEvent, nStart, cSubEvent, cSubRoutine, nQtdReg)

Local cFunBkp	:= ""
Local cFunMet	:= ""

// Local nFim := 0

Local cIdMetric  := ""
Local dDateSend := CtoD("") 
Local nLapTime := 0
Local nTotal := ""

Default cEvent := ""
Default nStart := Seconds() //Caso futuramente exista metrica de tempo medio
Default cSubEvent := ""
Default cSubRoutine := Alltrim(ProcName(1))
Default nQtdReg := 0

//Só capturar metricas se a vers?o da lib for superior a 20210517
If __lMetric .And. !Empty(cEvent)
	
	//grava funname atual na variavel cFunBkp
	cFunBkp := FunName()

	If cEvent == "01" //Evento 01 -  Metrica da quantidade de bens classificados que contém CIAP 

		
		//Evento 01 - Metrica da quantidade de bens classificados que contém CIAP
		If cEvent == "01" 

			If cSubEvent == '001'

				cFunMet := Iif(AllTrim(cFunBkp)=='RPC',"RPCATFA240",cFunBkp)
				SetFunName(cFunMet)

				//atribuicao das variaveis que serao utilizadas pelo FwCustomMetrics
				cSubRoutine := Alltrim(cSubRoutine)			
				cIdMetric  := "ativo-fixo--protheus_classificacao-bem-ciap-qtd_total"
				nTotal := 1 //nTotal					
				dDateSend := LastDay( Date() ) //Date()//
				FWCustomMetrics():SetSumMetric(cSubRoutine, cIdMetric, nTotal, dDateSend, nLapTime)
			EndIf
		EndIf
	EndIf

	//Restaura setfunname a partir da variavel salva cFunBkp
	SetFunName(cFunBkp)
EndIf

Return 

/*{Protheus.doc}AF240Lote
Classificação em lote
@author Mayara Alves da silva
@since 05/08/2015
@version P12
@project Inovação Controladoria
*/
Function AF240Lote( cAlias,nReg,nOpc )
Local cGrupo		:= ""								//Grupo Classificação
Local cCodBas		:= ""								//Codigo Base
Local cItem			:= ""								//Item inicial
Local cNumPla		:= ""								//Numero da Palqueta
Local cAliasMrk		:= "" 								//Alias
Local cMarca		:= "0w"
Local nX			:= 0 								//Variavel do for para criar colunas mark
Local nCols			:= 1
Local aArea			:= GetArea()
Local aAreaSNG		:= SNG->(GetArea())
Local aStru			:= SN1->(DbStruct()) 				//Estrutura da tabela SN1
Local aSize			:= MSADVSIZE()	
Local aColsEdit		:= {}
Local aColumns		:= {}
Local aRotOld		:= aClone(aRotina)
Local oDlgMrk		:= Nil
Local lAglutina		:= .F.
Local lContinua		:= .T.								//Continua função depois das validações
Local lRepetChap	:= Iif(mv_par02 == 1, .T., .F. )	//Salva SX1 -> AFA240 se repete chapa ou n?o
Local bOk 			:= {|| MsgRun(STR0034,"",{|| Iif( AF240LTOK(cAliasMrk,oMrkBrowse,lRepetChap) ,lContinua := AF240LGrv(cAliasMrk,lAglutina,lRepetChap),lContinua:=.F.), Iif( lContinua,(oMrkBrowse:Deactivate(),oDlgMrk:End()),Nil) })}//"Classificação em lote"
Local bCancel		:= {|| oMrkBrowse:Deactivate(),oDlgMrk:End()}

Private xAliasAux

aRotina := {}

//Usado para preservar os parametros do pergunt do F12
SaveInter()

If Pergunte("AFA240L", .T.)

	/*-----------Descritivo Perguntas - AFA240L----------*/
	//"mv_par01"	//Código Base De ?
	//"mv_par02"	//Item De ?
	//"mv_par03"	//Código Base Até ?
	//"mv_par04"	//Item Até ?
	//"mv_par05"	//Documento De ?
	//"mv_par06"	//Série De ?
	//"mv_par07"	//Fornecedor De ?
	//"mv_par08"	//Loja  De ?
	//"mv_par09"	//Documento Até ?
	//"mv_par10"	//Série Até ?
	//"mv_par11"	//Fornecedor Até ?
	//"mv_par12"	//Loja  Até ?
	//"mv_par13"	//Produto ?
	//"mv_par14"	//Dt Aquisiç?o de ?
	//"mv_par15"	//Dt Aquisiç?o Até ?
	//"mv_par16"	//Contabiliza On line ?
	//"mv_par17"	//Aglutina Lançamento ?
	//"mv_par18"	//Grupo Classificaç?o ?
	//"mv_par19"	//Incremento Automático ?
	//"mv_par20"	//Código Base ?
	//"mv_par21"	//Item Inicial ?
	//"mv_par22"	//Número da plaqueta Inicial ?
	//"mv_par23"	//Descriç?o ? 
	//"mv_par24" 	//Data de Aquisiç?o ?
	
	//Transforma parametros do tipo Range em expressao ADVPL para ser utilizada no filtro
	MakeSqlExpr("AFA240L")

	//Atribui valores do pergunte
	cGrupo		:= MV_PAR18 //Grupo Classificação
	cCodBas	:= MV_PAR20 //Codigo Base
	cItem		:= MV_PAR21 //Item inicial
	cNumPla	:= MV_PAR22 //Numero da Palqueta
	lAglutina := IIf(MV_PAR17 == 1, .T. , .F.)
	
	lContinua	:=	VldCanClas(mv_par01,mv_par02,mv_par03,mv_par04) //Verifica se o bem naa e em construç?o ou outros tipos(futuros realizar nessa mesma funç?o) para abortar programa.
	
	//Valida os parametros
	SNG->(dbSetOrder(1))
	If lContinua .And. Empty(cGrupo)
		Help(" ",1,"AF240GRPEMPTY",, STR0030, 1, 0) //"Codigo do grupo deve estar preenchido."
		lContinua	:= .F.
	Elseif lContinua .And. !SNG->(dbSeek(xFilial("SNG")+cGrupo))
		lContinua	:= .F.
		Help(" ",1,"AF240GRP",, STR0021, 1, 0) //"O grupo da classificação não existe."
	EndIf

	If lContinua .And. Empty(cCodBas)
		lContinua	:= .F.
		Help(" ",1,"AF240BEM",, STR0022, 1, 0) //"O Código Base deve estar preenchido."
	EndIf

	If lContinua .And. Empty(cItem)
		lContinua	:= .F.
		Help(" ",1,"AF240ITE",, STR0023, 1, 0) //"O Item Inicial deve estar preenchido."
	EndIf
	
	If lContinua .And. Empty(cNumPla)
		lContinua	:= .F.
		Help(" ",1,"AF240PLA",, STR0024, 1, 0) //"O Número da plaqueta deve estar preenchido."
	EndIf
	
	If lContinua .And. !Empty(cNumPla)
		dbSelectArea("SN1")
		SN1->(dbSetOrder(2))
		If SN1->(dbSeek(xFilial("SN1")+cNumPla)) .And. !lRepetChap
			lContinua	:= .F.
			Help(" ",1,"AF240PLA",, STR0029, 1, 0) //"O Número da plaqueta já existente"
		EndIf
		dbSelectArea("SN1")
		SN1->(dbSetOrder(1))
	EndIf 

	If lContinua

		cAliasMrk	:= A240ExcQr(lRepetChap)
		xAliasAux	:= cAliasMrk
 		//Define as colunas a serem apresentadas na markbrowse
		For nX := 1 To Len(aStru)
			If	aStru[nX][1] $ "N1_CODBAR|N1_CBASE|N1_ITEM|N1_DESCRIC|N1_PRODUTO|N1_AQUISIC|N1_QUANTD|N1_FORNEC|N1_LOJA|N1_NSERIE|N1_NFISCAL|N1_CHAPA|N1_GRUPO"
				//Pega o valor da coluna
				nCols += 1
		
				AAdd(aColumns,FWBrwColumn():New())
				aColumns[Len(aColumns)]:SetData( &("{||"+aStru[nX][1]+"}") )
				aColumns[Len(aColumns)]:SetTitle(RetTitle(aStru[nX][1]))
				aColumns[Len(aColumns)]:SetSize(aStru[nX][3])
				aColumns[Len(aColumns)]:SetDecimal(aStru[nX][4])
				aColumns[Len(aColumns)]:SetPicture(PesqPict("SN1",aStru[nX][1]))
		
				If aStru[nX][1] $ "N1_CODBAR|N1_CBASE|N1_ITEM|N1_DESCRIC|N1_GRUPO|N1_CHAPA"
					aColumns[Len(aColumns)]:SetEdit(.T.)
					aColumns[Len(aColumns)]:SetReadVar("(xAliasAux)->"+aStru[nX][1])
					//Validação de campo
					If aStru[nX][1] = "N1_GRUPO"
 						aColumns[Len(aColumns)]:SetValid({||ExistCpo("SNG")})
					Endif
					If aStru[nX][1] = "N1_CBASE"
 						aColumns[Len(aColumns)]:SetValid({|| Af240Chave((xAliasAux)->N1_CBASE, (xAliasAux)->N1_ITEM) .And. FreeForUse("SN1",(xAliasAux)->N1_CBASE) })
					Endif
					If aStru[nX][1] = "N1_ITEM"
						aColumns[Len(aColumns)]:SetValid({|| Af240Chave((xAliasAux)->N1_CBASE, (xAliasAux)->N1_ITEM)})
					Endif
					If aStru[nX][1] = "N1_DESCRIC"
						aColumns[Len(aColumns)]:SetPicture("@!") 
					Endif
					If aStru[nX][1] = "N1_CHAPA"
						aColumns[Len(aColumns)]:SetValid({|| AF240CHAPA(((xAliasAux)->N1_CHAPA), lRepetChap) })
					Endif
					//Inclui array para guardar colunas editaveis
					aAdd(aColsEdit, nCols )
				EndIf
		
				//Coloca consulta padrão no grupo de bens
				If aStru[nX][1] $ "N1_GRUPO"
					aColumns[Len(aColumns)]:SetF3("SNG")
				EndIf
			EndIf
		Next nX
			
 		If !(cAliasMrk)->(Eof())
				
				//DEFINE MSDIALOG oDlg TITLE STR0017 From 300,0 to 800,800 OF oMainWnd PIXEL //Situações de Cobrança
				//Tela de digitacao dos dados dos titulos a serem gerados pela liquidacao
			
			DEFINE MSDIALOG oDlgMrk TITLE STR0020 PIXEL FROM aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL //"Classificação em Lote"
			oDlgMrk:lMaximized := .T.

			oMrkBrowse:= FWMarkBrowse():New()
			oMrkBrowse:SetMark(cMarca, cAliasMrk, "N1_OK")
			
			
			(cAliasMrk)->(DbGoTop())
			While (cAliasMrk)->(!Eof())
				RecLock(cAliasMrk,.F.)
				(cAliasMrk)->N1_OK :=  oMrkBrowse:Mark()
				(cAliasMrk)->(MsUnlock())
				(cAliasMrk)->(DbSkip())
			End
			(cAliasMrk)->(DbGoTop())			
				
			oMrkBrowse:SetFieldMark("N1_OK")
			oMrkBrowse:SetOwner(oDlgMrk)
			oMrkBrowse:SetAlias(cAliasMrk)
			oMrkBrowse:SetCustomMarkRec({||EditaCell(oMrkBrowse,aColsEdit)})
			oMrkBrowse:oBrowse:SetEditCell(.T.)
			oMrkBrowse:SetMenuDef("")
			oMrkBrowse:AddButton(STR0035,bOk,,2) //Confirmar
			oMrkBrowse:AddButton(STR0036,bCancel,,2 ) //Cancelar
			oMrkBrowse:bMark	:= {||}
			oMrkBrowse:bAllMark	:= {|| AF240CMark(oMrkBrowse,cAliasMrk)}
			oMrkBrowse:SetDescription("")
			oMrkBrowse:SetColumns(aColumns)
			oMrkBrowse:DisableFilter()
			oMrkBrowse:DisableConfig()
			oMrkBrowse:Activate()
			ACTIVATE MSDIALOG oDlgMrk CENTERED

		Else	
	
			Help(" ",1,"AF240BEM",, STR0025, 1, 0) //"Não a há bens a ser classificado."
	
		Endif
		
	EndIf
EndIf

RestInter()
RestArea(aAreaSNG)
RestArea(aArea)
aRotina := aClone(aRotOld)

Return


/*{Protheus.doc}A240ExcQr
REALIZA FILRTO DO MARK
@author Mayara Alves da silva
@since 05/08/2015
@version P12
@project Inovação Controladoria
*/
Static Function A240ExcQr(lRepetChap)
Local cQuery	:= ""
Local cArqTrab	:= ""
Local cCampo	:= ""
Local nZ		:= 0
Local nPosCpo	:= 0
Local aArea		:= GetArea()
Local aStru		:= SN1->(DbStruct()) //Estrutura da tabela SN1
Local aChave	:= {}
//Variaveis do pergunte - AFA240L
Local cBaseDe	:= PadR(MV_PAR01, Len(SN1->N1_CBASE))
Local cItemDe	:= PadR(MV_PAR02, Len(SN1->N1_ITEM))
Local cBaseAte	:= PadR(MV_PAR03, Len(SN1->N1_CBASE))
Local cItemAte	:= PadR(MV_PAR04, Len(SN1->N1_ITEM))
Local cNotaDe	:= PadR(MV_PAR05, Len(SN1->N1_NFISCAL))
Local cSeriDe	:= PadR(MV_PAR06, Len(SN1->N1_NSERIE))
Local cFornDe	:= PadR(MV_PAR07, Len(SN1->N1_FORNEC))
Local cLojaDe	:= PadR(MV_PAR08, Len(SN1->N1_LOJA))
Local cNotaAte	:= PadR(MV_PAR09, Len(SN1->N1_NFISCAL))
Local cSeriAte	:= PadR(MV_PAR10, Len(SN1->N1_NSERIE))
Local cFornAte	:= PadR(MV_PAR11, Len(SN1->N1_FORNEC))
Local cLojaAte	:= PadR(MV_PAR12, Len(SN1->N1_LOJA ))
Local cProd		:= MV_PAR13
Local cAquiDe	:= DTOS(MV_PAR14)
Local cAquiAte	:= DTOS(MV_PAR15)

cQuery += "SELECT "
cQuery += "  N1_CODBAR, N1_CBASE, N1_ITEM, N1_PRODUTO, N1_QUANTD, "
cQuery += "  N1_FORNEC, N1_LOJA, N1_NSERIE, N1_NFISCAL, N1_CHAPA, N1_OK, "
cQuery += IIf( Empty(MV_PAR23), " N1_DESCRIC, ", " '" + MV_PAR23 + "' N1_DESCRIC, ")
cQuery += IIf( Empty(MV_PAR24), " '" + DtoS(dDataBase) + "' N1_AQUISIC, ", " '" + DtoS(MV_PAR24) + "' N1_AQUISIC, ")
cQuery += " '" + MV_PAR18 + "' N1_GRUPO, "		
cQuery += " SN1.R_E_C_N_O_ NRECNO "
cQuery += "  FROM "+	RetSqlName("SN1") + " SN1 "
cQuery += " WHERE N1_FILIAL = '"	+ XFilial("SN1")+ "' "
cQuery += " AND N1_CBASE||N1_ITEM BETWEEN '"     +cBaseDe+cItemDe+"' AND '"+cBaseAte+cItemAte+"' "
cQuery += " AND N1_FORNEC||N1_LOJA BETWEEN '"    +cFornDe+cLojaDe+"' AND '"+cFornAte+cLojaAte+" ' "
cQuery += " AND N1_NFISCAL||N1_NSERIE BETWEEN '" +cNotaDe+cSeriDe+"' AND '"+cNotaAte+cSeriAte+" ' "

If !Empty(cProd) //Produto  - tipo range
	cQuery += " AND " + cProd + CRLF
EndIf
cQuery += " AND N1_AQUISIC BETWEEN '"+cAquiDe+"' AND '"+cAquiAte+"'  " + CRLF
cQuery += " AND N1_STATUS = '0' "
cQuery += " AND SN1.D_E_L_E_T_ = ' ' "
cQuery := ChangeQuery(cQuery)

cChave		:= SN1->(IndexKey())
aChave		:= StrTokArr(cChave,"+")
Aadd(aStru, {"NRECNO","N",10,0})
cArqTrab := CriaTrab(,.F.) // Nome do alias temporario

If _oATFA0240 <> Nil
	_oATFA0240:Delete()
	_oATFA0240 := Nil
Endif

_oATFA0240 := FWTemporaryTable():New( cArqTrab )
_oATFA0240:SetFields(aStru)
_oATFA0240:AddIndex("1", aChave)
_oATFA0240:Create()
DbSetOrder(1)

DbUseArea(.T., "TOPCONN", TcGenQry(,, cQuery), "AFLOTE240")

While AFLOTE240->( !Eof() )
	
	dbSelectArea(cArqTrab)
	Reclock(cArqTrab,.T.)
	
	For nZ:=1 to len(aStru)
		cCampo	:=	AFLOTE240->(FieldName(nZ))
		nPosCpo	:=	(cArqTrab)->(FieldPos(cCampo))

		If nPosCpo > 0 
			( cArqTrab )->( FieldPut( nPosCpo, ( AFLOTE240->( FieldGet(nZ) ) ) ) )
		EndIf

	Next
	
	( cArqTrab )->( MsUnlock() )
	AFLOTE240->( DbSkip() )

EndDo

AFLOTE240->( DbCloseArea() )
DbSelectArea(cArqTrab)

// IndRegua (cArqTrab,cArqTrab,cChave,,,"STR0092"+"...")	//"Selecionando Registros"

//gera codigo, item e plaqueta apartir do paramentro
AFA240ATUTAB(@cArqTrab,lRepetChap)

RestArea(aArea)

Return (cArqTrab)



/*{Protheus.doc}EditaCell
Posiciona nas colunas que poderam ser editadas e faz o tratamento para a edição.
@author Mayara Alves da silva
@since 05/08/2015
@param oMark	- objeto mark
@param aColsEdit	- com as colunas q podem ser editadas.
@version P12
@project Inovação Controladoria
*/
Static function EditaCell(oMark,aColsEdit)
Local lRet:= .T.
Default oMark := Nil
Default aColsEdit := {}

If aScan(aColsEdit,oMark:oBrowse:ColPos()) > 0
		RecLock(oMark:Alias(),.F.)
		oMark:oBrowse:EditCell(oMark:oBrowse:ColPos())
		(oMark:Alias())->(MsUnLock())
Else
	
	RecLock(oMark:Alias(),.F.)
	If (oMark:Alias())->N1_OK != oMark:Mark()
		(oMark:Alias())->N1_OK  := oMark:Mark()
	Else
		(oMark:Alias())->N1_OK  := "  "
	Endif
	(oMark:Alias())->(MsUnLock())

Endif

Return lRet

/*{Protheus.doc}AF240LGrv
Faz a classificação em lote via excauto do ATFA012	
@author Mayara Alves da silva
@since 05/08/2015
@param cArqTrab	- Tabela temporaria
@param lAglutina	- Aglutina sim ou não
@version P12
@project Inovação Controladoria
*/
Static Function AF240LGrv(cAliasMrk,lAglutina,lRepetChap)
Local cArquivo			:= ""
Local cId				:= ""
Local cMensIni			:= STR0020 + " : "  // "Classificação em Lote: "
Local nY				:= 0
Local nHdlPrv			:= 0
Local nTotal			:= 0
Local aCab				:= {}
Local aItens			:= {}
Local aParam			:= {}
Local aLog				:= {}
Local aArea				:= GetArea() 
Local aAreaSN1			:= SN1->(GetArea())
Local aCtb				:= {}
Local lErro				:= .F.
Local lRet 				:= .T.
Local lContab 			:= IIf(MV_PAR16 == 1, .T. , .F.) //Contabilização on line sim ou não
Local dDtBaseAnt		:= dDataBase
Local dAquisic			:= MV_PAR24

Private lMsErroAuto 	:= .F.
Private lMsHelpAuto 	:= .T.
Private lAutoErrNoFile 	:= .T.

Default cAliasMrk		:= ""
Default lAglutina 		:= .F.

//Começa o log de processamento
ProcLogIni( {},__cProcPrinc,STR0020,@cId ) //	"Classificação em Lote "
	
//Abre o arquivo de contabilização 
cLote		:= LoteCont("ATF")
lLancPad	:= VerPadrao('801')
		
//Inicializa contabilizacao
If nHdlPrv <= 0 .And. lLancPad .And. lContab
	If !Empty(MV_PAR24)
		dDataBase	:=	MV_PAR24
	EndIf		 
	nHdlPrv := HeadProva(cLote,"ATFA240",Substr(cUsername,1,6),@cArquivo)
	If !Empty(MV_PAR24)
		dDataBase	:=	dDtBaseAnt
	EndIf	
EndIf

aAdd( aParam, {"MV_PAR01", 2			} ) //Mostra lancamento		(1-Sim/2-Nao)
aAdd( aParam, {"MV_PAR02", IIf(lRepetChap,1,2)			} ) //Repete Chapa			(1-Sim/2-Nao)
aAdd( aParam, {"MV_PAR03", 2			} ) //Copiar valores			(1-Sim/2-Nao)
AAdd( aParam, {"MV_PAR05", MV_PAR16	} ) //Contabilizar Online	(1-Sim/2-Nao)
AAdd( aParam, {"MV_PAR06", MV_PAR17	} ) //Aglutina Lançamentos	(1-Sim/2-Nao)

(cAliasMrk)->(dbGoTop())

While (cAliasMrk)->(!Eof())
	If !Empty((cAliasMrk)->N1_OK)
		
		//Carrega aCab para o excauto
		AAdd(aCab,{"N1_CBASE"  	, (cAliasMrk)->N1_CBASE		,NIL})
		AAdd(aCab,{"N1_ITEM"   	, (cAliasMrk)->N1_ITEM		,NIL})
		AAdd(aCab,{"N1_DESCRIC"	, (cAliasMrk)->N1_DESCRIC	,NIL})
		AAdd(aCab,{"N1_CHAPA" 	, (cAliasMrk)->N1_CHAPA	,NIL})
		AAdd(aCab,{"N1_GRUPO" 	, (cAliasMrk)->N1_GRUPO		,NIL})
		AAdd(aCab,{"N1_CODBAR" 	, (cAliasMrk)->N1_CODBAR		,NIL})
		If Empty(MV_PAR24)
			AAdd(aCab,{"N1_AQUISIC" 	, dDataBase		,NIL})
			AAdd(aCab,{"N1_INIAVP" 		, dDataBase		,NIL})
		Else
			AAdd(aCab,{"N1_AQUISIC" 	, dAquisic		,NIL})
			AAdd(aCab,{"N1_INIAVP" 		, dAquisic		,NIL})		
		Endif
		
		AAdd(aCab,{"N1_STATUS" 	, "1"			,NIL})
		
		aItens := {}
		//-- Preenche itens
		If Empty(MV_PAR24)
			AAdd(aItens,{{"N3_DINDEPR" , RetDinDepr(dDataBase) ,NIL},;
			{"N3_AQUISIC" , dDataBase ,NIL}})
		Else
			AAdd(aItens,{{"N3_DINDEPR" , RetDinDepr(dAquisic) ,NIL},;
			{"N3_AQUISIC" , dAquisic ,NIL}})						
		EndIf
		
		//Posiciona no registro gravado na SN1 para executar o excauto		
		SN1->(DbGoto((cAliasMrk)->NRECNO))
		
		//ATFA012(xCab,xItens,nOpcAuto,aParam,aCtb)
  		MSExecAuto({|x,y,z,w,a| Atfa012(x,y,z,w,a)},aCab,aItens,4,aParam,aCtb)
		
		If lMsErroAuto
			aLog := GETAUTOGRLOG()
			lMsErroAuto := .F.
			lErro := .T.

			cDetalhe := ""
			For nY := 1 to Len(aLog)
				cDetalhe += aLog[nY]
			Next nY
			
			ProcLogAtu(STR0026,cMensIni,cDetalhe,,.T. ) //"ERRO"
		Else
		
			If lLancPad .And. nHdlPrv > 0
				If !Empty(MV_PAR24)
					dDataBase	:=	MV_PAR24
				EndIf		 
			
				dbSelectArea("SN3")
				SN3->(dbSetOrder(1))
				If SN3->(dbSeek(xFilial("SN3")+(cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM))
					While SN3->(!Eof()) .And. (xFilial("SN3")+(cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM == SN3->N3_FILIAL+SN3->N3_CBASE+SN3->N3_ITEM)
						nTotal += DetProva(nHdlPrv, "801", "ATFA240", cLote)
						SN3->(dbSkip())
					End
				EndIf
				If !Empty(MV_PAR24)
					dDataBase	:=	dDtBaseAnt
				EndIf	 
				
			EndIf
		
		EndIf
		
		aCab := {}
	EndIf

	(cAliasMrk)->(dbSkip())
End

If lLancPad .And. nHdlPrv > 0 .And. nTotal > 0
	If !Empty(MV_PAR24)
		dDataBase	:=	MV_PAR24
	EndIf		 
			
	RodaProva(nHdlPrv,nTotal)
	cA100Incl(cArquivo, nHdlPrv, 2, cLote, .T., lAglutina)
	
	If !Empty(MV_PAR24)
		dDataBase	:= dDtBaseAnt
	EndIf	
Endif

ProcLogAtu(STR0027,cMensIni,,,.T.) //"FIM"

//mostra o log
ProcLogView(,__cProcPrinc)
RestArea(aAreaSN1)
RestArea(aArea)

Return lRet


/*{Protheus.doc}AFA240ATUTAB
Atualiza codigo do bem, item e plaqueta da tabela temporaria 
apartir do pergunte
@author Mayara Alves da silva
@since 05/08/2015
@param cArqTrab	- Tabela temporaria
@version P12
@project Inovação Controladoria
*/
Static Function AFA240ATUTAB(cArqTrab,lRepetChap)
Local nIncre	:= MV_PAR19
Local cCodIni	:= PadR(MV_PAR20,Len(SN1->N1_CBASE))
Local cItemIn	:= PadR(MV_PAR21,Len(SN1->N1_ITEM))
Local cPlacta	:= PadR(MV_PAR22,Len(SN1->N1_CHAPA))
Local lCodB		:= Iif(nIncre == 1, .T. ,.F. ) //1 - Codigo 2 - Item
Local aArea		:= GetArea()
Local aAreaSn1	:= SN1->(GetArea())

Default cArqTrab	:= ""

(cArqTrab)->(dbGoTop())

While (cArqTrab)->(!Eof())
	dbselectarea("SN1")
	dbSetOrder(1)//N1_FILIAL+N1_CBASE+N1_ITEM
	If lCodB
		If SN1->(DbSeek(xFilial("SN1")+cCodIni+cItemIn))
			cCodIni := Soma1(Alltrim(cCodIni))
		Else
			
			RecLock(cArqTrab,.F.)
			(cArqTrab)->N1_CBASE := alltrim(cCodIni)
			
			If !Empty((cArqTrab)->N1_ITEM)
				(cArqTrab)->N1_ITEM	:= cItemIn
			Endif
			
			cCodIni := SOMA1(cCodIni)
			(cArqTrab)->N1_CHAPA := cPlacta
			
			If !lRepetChap
				cPlacta:= SOMA1(cPlacta)
			EndIf

			(cArqTrab)->(MsUnLock())
			(cArqTrab)->(dbSkip())
		
		Endif
	Else
		If SN1->(DbSeek(xFilial("SN1")+cCodIni+cItemIn))
			cItemIn := Soma1(cItemIn)
		Else
		
			RecLock(cArqTrab,.F.)
			If !Empty((cArqTrab)->N1_CBASE)
				(cArqTrab)->N1_CBASE:= cCodIni
			Endif
			
			(cArqTrab)->N1_ITEM	:= cItemIn
			cItemIn := SOMA1(cItemIn)
		
			(cArqTrab)->N1_CHAPA := cPlacta

			If !lRepetChap
				cPlacta:= SOMA1(cPlacta)
			EndIf

			(cArqTrab)->(MsUnLock())
			(cArqTrab)->(dbSkip())
		
		Endif
	Endif
EndDo

If (cArqTrab)->(Eof())
	(cArqTrab)->(dbGoTop())
EndIf

RestArea(aAreaSN1)
RestArea(aArea)
Return 

/*{Protheus.doc}AF240LTOK
Valida codigo e itens duplicados
@author Mayara Alves da silva
@since 12/08/2015
@param cAliasMrk	- Tabela temporaria
@version P12
@project Inovação Controladoria
*/
Static Function AF240LTOK(cAliasMrk,oMrkBrowse,lRepetChap)
Local lRet := .T.
Local aBens := {} //Array com os bens e os itens
Local aArea := GetArea()
Local aAreaSN1    := SN1->(GetArea())
Local nMark	:= 0 //Intes marcados
 Local nX   := 1

Default cAliasMrk	:= ""
 
(cAliasMrk)->(dbGoTop())
 
dbSelectArea("SN1")
SN1->(dbSetOrder(1))
           
While (cAliasMrk)->(!Eof())
    If !Empty((cAliasMrk)->N1_OK)
		nMark := nMark + 1 
		//Carrega array com bem+item
		AAdd(aBens, {(cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM, (cAliasMrk)->N1_CHAPA})
		If nMark > 1    
			For nX := 2 to Len(aBens)  // VErifico a partir da segunda linha do MarkBRowse
				If aBens[nx-1][1] == ((cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM)
					lRet := .F.
					Help(" ",1,"AF240DUPLI",, STR0028, 1, 0) //"Existe linhas duplicadas (Cod. Base e Item iguais)."
					Exit
				EndIf
				If aBens[nx-1][2] == ((cAliasMrk)->N1_CHAPA) .And. !lRepetChap
					lRet := .F.
					Help(" ",1,"AF240CHAPA",,STR0039 , 1, 0)    //"Existe linhas duplicadas (Plaquetas iguais)."
					Exit
				EndIf
			Next    
		EndIf
    EndIf
	If !lRet	
		Exit 
	Endif
    (cAliasMrk)->(dbSkip())
End
 
If nMark == 0
	lRet := .F.
    Help(" ",1,"NOMARK",, STR0033, 1, 0) //"Não há nenhum item selecionado."
EndIf

//(cAliasMrk)->(dbGoTop())

oMrkBrowse:Refresh()
 
RestArea(aAreaSN1)
RestArea(aArea)

aSize(aBens, 0)
aBens := NIL

Return lRet


/*{Protheus.doc}AF240CMark
Marcaçao Multi-Registros
@author Kaique Olivero
@since 01/09/2015
@param oMrkBrowse	- Tabela temporaria
@param cAliasMrk	- Tabela temporaria
@version P12
@project Inovação Controladoria
*/
Static Function AF240CMark(oMrkBrowse,cAliasTRB)

DbSelectArea(cAliasTRB)
DbGoTop() 

While !(cAliasTRB)->(Eof())
	RecLock(oMrkBrowse:Alias(),.F.)
	If (oMrkBrowse:Alias())->N1_OK == "  "
		(oMrkBrowse:Alias())->N1_OK  := oMrkBrowse:Mark()
	Else
		(oMrkBrowse:Alias())->N1_OK  := "  "
	Endif
	(oMrkBrowse:Alias())->(MsUnLock())
	(cAliasTRB)->(dbSkip())
EndDo

oMrkBrowse:oBrowse:Refresh(.T.)

Return


Static Function VldCanClas(cBaseVini,cItemVini,cBaseVate,cItemVAte)
	
	Local aArea    	:= GetArea()
	Local aAreaSN1 	:= SN1->(GetArea())
	Local cQuery	:= ""
	Local lRet		:= .T.
	Local aBindSN1
	
	cQuery		:=	"SELECT COUNT(R_E_C_N_O_) QTDBEM "
	cQuery		+=	"FROM " + RetSqlName("SN1") + " SN1 "
	cQuery		+=	"WHERE N1_FILIAL		= ? " 
	cQuery		+=	"AND N1_CBASE||N1_ITEM	BETWEEN ? AND ? " 
	cQuery		+=	"AND N1_BMCONTR = ? "
	cQuery		+=	"AND SN1.D_E_L_E_T_		= ? "
	cQuery		:= ChangeQuery(cQuery)

	aBindSN1 :={}
	aADD(aBindSN1, xFilial('SN1'))
	aADD(aBindSN1, cBaseVini+cItemVini)
	aADD(aBindSN1, cBaseVate+cItemVAte)
	aADD(aBindSN1, '1')
	aAdd(aBindSN1, Space(1))

	dbUseArea(.T.,"TOPCONN",TcGenQry2(,,cQuery,aBindSN1),'cQryTrab')

	If cQryTrab->QTDBEM > 0
		lRet	:=	.F.	//Bem já foi classificado
		Help(" ",1,"AF240INVALID",, STR0038, 1, 0) //"N?o é possivel classificar bens em construç?o na funcionalidade em lote, Verifique se entre o range De/Ate existem bens com essas caracteristicas."
	EndIF

	cQryTrab->(DbCloseArea())
	aSize(aBindSN1,0)
	RestArea(aAreaSN1)
	RestArea(aArea)
	
Return lRet

/* {Protheus.doc}
	AF240CHAP -	Verifca se a Plaqueta;Chapa existe
	@author Totvs
	@since 
	@param (xAliasAux)->N1_CHAPA) - plaqueta digitada
	@param lRepetChap  - .T. permite a mesma plaqueta, .F. -n"ao permite plaquetas iguais
	@version P12
*/
Static Function AF240Chapa(cChapa, lRepetChap)
Local aArea 		:= GetArea()
Local aAreaSN1 		:= SN1->(GetArea())
Local lRet := .T.

If !lRepetChap
	If Empty(cChapa)
		Help(" ",1,"AF012ACHAP",,STR0040,1,0,,,,,,{STR0041 }) //"Plaqueta não informada."###"Preencha o campo Plaqueta."
		lRet := .F.
	Else
		DBSelectArea("SN1")
		DBSetOrder(2)
		If DBSeek(XFilial("SN1") + cChapa) //.And. cBase+cItem != SN1->(N1_CBASE+N1_ITEM)
			Help(" ",1,"AF012ACHAP",,STR0042,1,0,,,,,,{STR0043}) //"Plaqueta já existente no sistema."###"Defina um novo código no campo Plaqueta."
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aAreaSN1)
RestArea(aArea)

Return lRet

/* {Protheus.doc}
	Af240Chave -Verifca se a Ativo Existe no SN1
	@author Totvs
	@since 
	@param (xAliasAux)->N1_CBASE) - cBase
	@param (xAliasAux)->N1_ITEM)  - cItem
	@version P12
*/

Static Function Af240Chave(cBase,cItem)
Local lRet  := .T.
Local aArea 		:= GetArea()
Local aAreaSN1 		:= SN1->(GetArea())

DBSelectArea("SN1")
DBSetOrder(1)
If DBSeek(XFilial("SN1") + cBase+ cItem) 
	Help(" ",1,"AF240Chave",,STR0044,1,0,,,,,,{STR0045}) //"Ativo já existente no sistema."###"Defina um novo código no campo item."
	lRet := .F.
EndIf

RestArea(aAreaSN1)
RestArea(aArea)
Return lRet


