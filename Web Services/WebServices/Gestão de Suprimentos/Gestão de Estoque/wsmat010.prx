#INCLUDE "wsmat010.ch"
#INCLUDE "APWEBSRV.CH"
#INCLUDE "PROTHEUS.CH"
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³WSMAT010  ³ Autor ³Eduardo Riera          ³ Data ³18.03.2003  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Web Service responsavel pelo catalogo de produto             ³±±
±±³          ³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Atualizacoes sofridas desde a Construcao Inicial.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador  ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao do Web Service de Controle do Usuario                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSERVICE MtProduct        DESCRIPTION STR0001 NAMESPACE "http://webservices.microsiga.com.br/mtproduct.apw" //"Serviço de consulta a tabela de produtos e seus vinculos"
   WSDATA UserCode                 AS String
   WSDATA ProductCode              AS String
   WSDATA InventoryDate            As Date    OPTIONAL
   WSDATA TypeOfProductIn          As String  OPTIONAL
   WSDATA GroupOfProductIn         As String  OPTIONAL
   WSDATA TypeOfInventory          As Integer OPTIONAL
   WSDATA PageLen                  AS Integer OPTIONAL
   WSDATA PageFirst                AS Integer OPTIONAL
   WSDATA DescriptionLike          AS String  OPTIONAL
   WSDATA ProductCodeLike          As String  OPTIONAL
   WSDATA Header                   AS Array Of BrwHeader
   WSDATA HeaderType               AS String
   WSDATA Products                 AS Array Of ProductView
   WSDATA PriceTable               AS Array Of PriceView
   WSDATA Inventory                As Array Of InventoryView
   WSDATA ImageProduct             AS Base64Binary
   WSDATA TypeOfProductCollection  As Array Of GenericStruct
   WSDATA QueryAddWhere            As String OPTIONAL
   WSDATA IndexKey                 As String OPTIONAL
   WSDATA WareHouse                As String   
   WSDATA Stock                    As Array Of InventoryView OPTIONAL
   WSDATA CustomerID               As String OPTIONAL
   WSDATA PriceTableCode           As String
   WSDATA Quantity                 As Float
   WSDATA PaymentPlanCode          As String
   WSDATA DiscountType             As Integer
   WSDATA BasePrice                 As Float 
   WSDATA DisCountPercentage       As Float

   WSMETHOD GetHeader        DESCRIPTION STR0002 //"Método que descreve as estruturas de retorno do serviço"
   WSMETHOD GetImage         DESCRIPTION STR0003 //"Método de recuperacao da imagem de um produto"
   WSMETHOD GetCatalog       DESCRIPTION STR0004 //"Método de consulta ao catalogo de produtos"
   WSMETHOD GetPrice         DESCRIPTION STR0005 //"Método de consulta as tabelas de precos do produto"
   WSMETHOD GetInventory     DESCRIPTION STR0006 //"Método de consulta a posição de inventário de um produto"
   WSMETHOD GetStock         DESCRIPTION STR0007 //"Método de consulta a posição atual de estoque de um produto"
   WSMETHOD GetTypeOfProduct DESCRIPTION STR0008 //"Método de consulta aos tipos de produto"
   WSMETHOD GetDisCount      DESCRIPTION STR0009 //"Método de consulta a regra de desconto"
ENDWSSERVICE

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetHeader ³Autor  ³ Eduardo Riera         ³ Data ³20.05.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao do header do catalogo de produtos      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Nome da estrutura                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve o header de uma estrutura                ³±±
±±³          ³                                                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetHeader WSRECEIVE HeaderType WSSEND Header WSSERVICE MtProduct

Local aArea := GetArea()
Local nX    := 0

::Header := MtHeader(::HeaderType)
If Empty(::Header)
	::Header := {}
	
	aadd(::HEADER,WSClassNew("BrwHeader"))
	nX++
	::Header[nX]:HeaderTitle  := STR0010 //"Tipo de Produto"
	::Header[nX]:HeaderField   := "CODE"
	::Header[nX]:HeaderPicture := "@!"
	::Header[nX]:HeaderSize    := 6
	::Header[nX]:HeaderDec     := 0
	::Header[nX]:HeaderType    := "C"
	::Header[nX]:HeaderComboBox:= ""  
	::Header[nX]:HeaderOblig   := .F.
	
	aadd(::HEADER,WSClassNew("BrwHeader"))
	nX++
	::Header[nX]:HeaderTitle  := "Descripton"
	::Header[nX]:HeaderField   := "DESCRIPTION"
	::Header[nX]:HeaderPicture := "@!"
	::Header[nX]:HeaderSize    := 30
	::Header[nX]:HeaderDec     := 0
	::Header[nX]:HeaderType    := "C"
	::Header[nX]:HeaderComboBox:= ""	      
	::Header[nX]:HeaderOblig   := .F.
EndIf
RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetCatalog³Autor  ³ Eduardo Riera         ³ Data ³20.05.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao da tabela de produtos                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a tabela de produtos conforme a estrutura³±±
±±³          ³da mesma                                                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Atualizacoes sofridas desde a Construcao Inicial.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador  ³ Data   ³ BOPS ³  Motivo da Alteracao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Cleber M.    ³07/11/06³111579³Incluido P.E. WSMT010B para permitir adi-³±±
±±³              ³        ³      ³cionar filtro na query de produtos.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Tatiana C.   ³08/12/06³100121³Alterado o tamanho do campo B1_GRUPO para³±±
±±³              ³        ³      ³que a busca considere grupos com 2 campos³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Cleber M.    ³30/08/07³131586³Tratamento para voltar a considerar mais ³±±
±±³              ³        ³      ³de um grupo de produto na busca.         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetCatalog WSRECEIVE UserCode,TypeOfProductIn,GroupOfProductIn,ProductCodeLike,DescriptionLike,PageLen,PageFirst,QueryAddWhere,IndexKey,CustomerID WSSEND Products WSSERVICE MtProduct

Local aArea    := GetArea()				//Area atual
Local cCursor  := "SB1"					//Alias da tabela de produtos
Local cCursor2 := "SB5"					//Alias da tabela de compl. de produtos
Local cWSMT010B:= ""
Local cArquivo := ""					//Nome do arquivo temporario
Local lQuery   := .F.					//Indica se executou query
Local lRetorno := .T.					//Indica retorno do metodo
Local cTipoIn  := ::TypeOfProductIn		//Tipo do produto
Local nTamgrupo:= TamSX3("B1_GRUPO")[1]	//Tamanho do campo B1_GRUPO no SX3
Local cGrupoIn := ::GroupOfProductIn	//Grupo do produto
Local nX       := 0						//Usada em lacos For...Next
Local nY       := 0						//Usada em lacos For...Next
#IFDEF TOP
	Local aStruct  := {}									//Array com estrutura dos campos
	Local cQuery   := ""									//Expressao da query
#ENDIF

SB1->(dbSetOrder(1))

DEFAULT ::PageLen   := 0
DEFAULT ::PageFirst := 0
DEFAULT ::IndexKey  := SB1->(IndexKey())
DEFAULT ::CustomerID		:= ""
DEFAULT ::QueryAddWhere	:= ""
DEFAULT cTipoIn     := ""
DEFAULT cGrupoIn    := ""

dbSelectArea("SB1")
dbSelectArea("SB5")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento do In                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !"'" $ cTipoIn .And. !Empty(cTipoIn)
	cTipoIn := StrTran(cTipoIn,",","','")
	cTipoIn := "'"+AllTrim(cTipoIn)+"'"
EndIf
If !"," $ cGrupoIn .And. !Empty(cGrupoIn) .And. Len(cGrupoIn) < nTamgrupo
	cGrupoIn := PadR(cGrupoIn, nTamgrupo)
EndIf
If !"'" $ cGrupoIn .And. !Empty(cGrupoIn)
	cGrupoIn := StrTran(cGrupoIn,",","','")
	cGrupoIn := "'"+cGrupoIn+"'" 			//retirado o comando ALLTRIM para que o tamanho considerado seja o mesmo do SX3
EndIf

If ::QueryAddWhere == "MV_PVCODPV"
	::QueryAddWhere := SuperGetMv("MV_PVCODPV",.F.,"")
ElseIf ::QueryAddWhere == "MV_PVCODOC"
	::QueryAddWhere := SuperGetMv("MV_PVCODOC",.F.,"")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para adicionar filtro na query ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("WSMT010B")
	cWSMT010B := ExecBlock( "WSMT010B", .F., .F., { 1, ::CustomerID, ::UserCode } )
	If ValType(cWSMT010B) == "C" .And. !(Empty(cWSMT010B))
		If !(Empty(::QueryAddWhere))
			::QueryAddWhere += " And "
		EndIf
		::QueryAddWhere += cWSMT010B
	EndIf 
EndIf
   		
If PrtChkUser(::UserCode,"MTPRODUCT")
	dbSelectArea("SB1")
	dbSetOrder(1)
	#IFDEF TOP
		lQuery  := .T.
		cCursor := "GetCatalog"
		cCursor2:= "GetCatalog"
		cQuery  := "SELECT B1_FILIAL,B1_TIPO,B1_GRUPO,B1_COD,B1_DESC,B1_UM,B1_SEGUM,B1_POSIPI,"
		cQuery  += "B1_QE,B1_EMIN,B1_PESO,B1_PESBRU,B1_PE,B1_TIPE,B1_LE,B1_LM,B1_NOTAMIN,B1_PRVALID,"
		cQuery  += "B1_CODBAR,B1_LOCPAD,B5_CEME,B5_COMPRLC,B5_LARGLC,B5_ALTURLC,B5_FATARMA "
		cQuery  += GetUserFields("SB1")+GetUserFields("SB5")
		cQuery  += "FROM "+RetSqlName("SB1")+" SB1 LEFT JOIN "
		cQuery  += RetSqlName("SB5")+" SB5 ON (SB5.B5_FILIAL='"+xFilial("SB5")+"' AND SB1.B1_COD=SB5.B5_COD AND SB5.D_E_L_E_T_=' ') "
		cQuery  += "WHERE SB1.B1_FILIAL='"+xFilial("SB1")+"' AND "
		If !Empty(cTipoIn)
			cQuery  += "SB1.B1_TIPO IN("+cTipoIn+") AND "
		EndIf
		If !Empty(cGrupoIn)
			cQuery  += "SB1.B1_GRUPO IN("+cGrupoIn+") AND "
		EndIf
		If !Empty(::ProductCodeLike)
			cQuery  += "SB1.B1_COD LIKE '%"+::ProductCodeLike+"%' AND "
		EndIf		
		If !Empty(::DescriptionLike)
			cQuery  += "SB1.B1_DESC LIKE '%"+::DescriptionLike+"%' AND "
		EndIf
		cQuery  += "SB1.D_E_L_E_T_=' ' "
		cQuery  := WsQueryAdd(cQuery,::QueryAddWhere)
		cQuery  += "ORDER BY "+SqlOrder(::IndexKey)
		
		cQuery := ChangeQuery(cQuery)
		MemoWrite("WSMAT010.SQL", cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor)
		aStruct := SB1->(dbStruct())
		For nX := 1 To Len(aStruct)
			If aStruct[nX][2]<>"C" .And. FieldPos(aStruct[nX][1])<>0
				TcSetField(cCursor,aStruct[nX][1],aStruct[nX][2],aStruct[nX][3],aStruct[nX][4])
		    EndIf
		Next nX
	#ELSE
		cArquivo := CriaTrab( , .F. )
		
		cQuery := "B1_FILIAL == '" + xFilial( "SB1" ) + "' "

		If !Empty( cTipoIn )
			cQuery  += ".AND. B1_TIPO == " + cTipoIn + " "
		EndIf

		If !Empty( cGrupoIn )
			cQuery  += ".AND. B1_GRUPO == " + cGrupoIn + " "
		EndIf

		If !Empty( ::ProductCodeLike )
			cQuery += ".AND. B1_COD = '" + ::ProductCodeLike + "' "
		EndIf		

		If !Empty( ::DescriptionLike )
			cQuery += ".AND. B1_DESC = '" + ::DescriptionLike + "'"
		EndIf
		
		If ExistBlock("WSMT010B")
			cQuery += ExecBlock( "WSMT010B", .F., .F., { 2, ::CustomerID } )
		EndIf
		
		IndRegua("SB1",cArquivo,::IndexKey,,cQuery)
		dbGotop()
	#ENDIF
	::Products := {}
	nX := 0
	While !Eof() .And. (cCursor)->B1_FILIAL == xFilial("SB1")
		If ((cCursor)->B1_TIPO $ cTipoIn .Or. Empty(cTipoIn)).And.;
			((cCursor)->B1_GRUPO $ cGrupoIn .Or. Empty(cGrupoIn)).And.;
			IIf(!Empty(::ProductCodeLike).And.!lQuery,::ProductCodeLike$(cCursor)->B1_COD,.T.) .And.;
			IIf(!Empty(::DescriptionLike).And.!lQuery,::DescriptionLike$(cCursor)->B1_DESC,.T.)
					
			nY++
			
			If ::PageFirst==0 .Or. nY >= ::PageFirst

				nX++
				If nX > 500
					Exit
				EndIf
						
				dbSelectArea("SAH")
				dbSetOrder(1)
			
				dbSelectArea("SBM")
				dbSetOrder(1)
	
				dbSelectArea("SX5")
				dbSetOrder(1)
				MsSeek(xFilial("SX5")+'02'+(cCursor)->B1_TIPO)
				
				If !lQuery
					dbSelectArea("SB5")
					dbSetOrder(1)
					MsSeek(xFilial("SB5")+(cCursor)->B1_COD)				
				EndIf
	
				aadd(::Products,WSClassNew("ProductView"))
				::Products[nX]:ProductCode                  := (cCursor)->B1_COD
				::Products[nX]:Description                  := (cCursor)->B1_DESC
				::Products[nX]:ScienceDescription           := (cCursor2)->B5_CEME
				::Products[nX]:MeasureUnit                  := (cCursor)->B1_UM
				::Products[nX]:DescriptionMeasureUnit       := IIf(SAH->(MsSeek(xFilial("SAH")+(cCursor)->B1_UM)),SAH->AH_DESCPO,"")
				::Products[nX]:SecondMeasureUnit            := (cCursor)->B1_SEGUM
				::Products[nX]:DescriptionSecondMeasureUnit := IIf(SAH->(MsSeek(xFilial("SAH")+(cCursor)->B1_SEGUM)),SAH->AH_DESCPO,"")
				::Products[nX]:TypeOfProduct                := (cCursor)->B1_TIPO
				::Products[nX]:DescriptionTypeOfProduct     := X5Descri()
				::Products[nX]:GroupOfProduct               := (cCursor)->B1_GRUPO
				::Products[nX]:DescriptionGroupOfProduct    := IIf(SBM->(MsSeek(xFilial("SBM")+(cCursor)->B1_GRUPO)),SBM->BM_DESC,"")
				::Products[nX]:NCM	                         := (cCursor)->B1_POSIPI
				::Products[nX]:QuantityPerPackage           := (cCursor)->B1_QE
				::Products[nX]:OrderPoint                   := (cCursor)->B1_EMIN
				::Products[nX]:NetWeight                    := (cCursor)->B1_PESO
				::Products[nX]:GrossWeight                  := (cCursor)->B1_PESBRU
				::Products[nX]:LeadTime                     := (cCursor)->B1_PE
				::Products[nX]:TypeOfLeadTime               := (cCursor)->B1_TIPE
				::Products[nX]:EconomicLot                  := (cCursor)->B1_LE
				::Products[nX]:MinimumLot                   := (cCursor)->B1_LM
				::Products[nX]:MinimumGrade                 := (cCursor)->B1_NOTAMIN
				::Products[nX]:TermOfValidaty               := (cCursor)->B1_PRVALID
				::Products[nX]:BarCode                      := (cCursor)->B1_CODBAR
				::Products[nX]:StorageLenght                := (cCursor2)->B5_COMPRLC
				::Products[nX]:StorageWidth                 := (cCursor2)->B5_LARGLC
				::Products[nX]:StorageHeight                := (cCursor2)->B5_ALTURLC
				::Products[nX]:StorageMaximumPiling         := (cCursor2)->B5_FATARMA
				::Products[nX]:StandardWareHouse            := (cCursor)->B1_LOCPAD 
				UserFields("SB1",@::Products[nX]:UserFields,cCursor)
				
				If ExistBlock("WSMT010A")
					::Products[nX] := ExecBlock("WSMT010A",.F.,.F.,{cCursor,::Products[nX]})
				EndIf
						
				If nX >= ::PageLen .And. ::PageLen <> 0
					Exit
				EndIf
			EndIf
		EndIf
		dbSelectArea(cCursor)
		dbSkip()
			
	EndDo
	If lQuery
		dbSelectArea(cCursor)
		dbCloseArea()
		dbSelectArea("SB1")
	Else
		RetIndex("SB1")
		FErase(cArquivo+OrdBagExt())
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetImage  ³Autor  ³ Eduardo Riera         ³ Data ³20.05.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao da imagem de um produto do catalogo    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a imagem de um produto                   ³±±
±±³          ³                                                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetImage WSRECEIVE UserCode,ProductCode WSSEND ImageProduct WSSERVICE MtProduct

Local aArea    := GetArea()
Local lRetorno := .T.
Local cBmpPict := ""
Local cPathPict:= GetSrvProfString("Startpath","")
Local cBitMap  := ""
Local cLeitura := ""
Local cExtensao:= ".BMP"
Local nHandle  := 0
Local nLidos   := 0

If PrtChkUser(::UserCode,"MTPRODUCT")
	dbSelectArea("SB1")
	dbSetOrder(1)
	If MsSeek(xFilial("SB1")+::ProductCode)
		If !Empty( cBmpPict := Upper( AllTrim( SB1->B1_BITMAP ) ) )
			If RepExtract(cBmpPict,cPathPict+cBmpPict)
				If !File(cPathPict+cBmpPict+cExtensao)
					cExtensao := ".JPG"
				EndIf
				nHandle := FOpen(cPathPict+cBmpPict+cExtensao)
				If nHandle <> 0
					nLidos := 1
					While nLidos > 0
						cLeitura := ""
						nLidos := Fread(nHandle,@cLeitura,4096)
						cBitMap += cLeitura
					EndDo
					::ImageProduct := cBitMap
				Else
					lRetorno := .F.
					SetSoapFault("GETIMAGE",STR0011) //"Erro de leitura no repositorio de imagem"
				EndIf
				FClose(nHandle)
				Ferase(cPathPict+cBmpPict+cExtensao)
			Else
				lRetorno := .F.
				SetSoapFault("GETIMAGE",STR0011) //"Erro de leitura no repositorio de imagem"
			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault("GETIMAGE",STR0012) //"Produto nao cadastrado"
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetPrice  ³Autor  ³ Eduardo Riera         ³ Data ³21.05.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao da tabela de precos de um produto      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do produto                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a tabela de preco em sua respectiva estru³±±
±±³          ³tura                                                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Atualizacoes sofridas desde a Construcao Inicial.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador  ³ Data   ³ BOPS ³  Motivo da Alteracao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Cleber M.    ³21/11/06³113345³-Inclusao de UserFields() para tratar os ³±±
±±³              ³        ³      ³campos de usuario.                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetPrice WSRECEIVE UserCode,ProductCode,QueryAddWhere WSSEND PriceTable WSSERVICE MtProduct

Local aArea   := GetArea()			//Guarda a area atual
Local nX      := 0					//Usada em lacos For...Next
Local cCursor := "DA1"				//Alias da tabela da query
Local lQuery  := .F.				//Indica se executou query
Local lRetorno := .T.				//Indica retorno da funcao
#IFDEF TOP
Local aStru   := {}					//Array com estrutura do DA1
Local cQuery  := ""					//Query a ser executada
Local nY      := 0					//Usada em lacos For...Next
#ENDIF
If PrtChkUser(::UserCode,"MTPRODUCT")
	dbSelectArea("SB1")
	dbSetOrder(1)
	If MsSeek(xFilial("SB1")+::ProductCode)
		::PriceTable := {}
		nX := 0
		If SB1->B1_PRV1 <> 0
			aadd(::PriceTable,WSClassNew("PriceView"))
			nX++
			::PriceTable[nX]:ProductCode    := SB1->B1_COD
			::PriceTable[nX]:PaymentPlanCode := ""
			::PriceTable[nX]:PriceTableCode := "1  "
			::PriceTable[nX]:Price          := SB1->B1_PRV1
			::PriceTable[nX]:QuantityLimit  := 0
			::PriceTable[nX]:Currency       := 1
			::PriceTable[nX]:CurrencySimbol := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
		EndIf
		dbSelectArea("DA1")
		dbSetOrder(2)
		#IFDEF TOP
			lQuery  := .T.
			cCursor := "GetPrice"
			aStru   := DA1->(dbStruct())
			
			cQuery := "SELECT DA1_FILIAL,DA1_CODPRO,DA1_CODTAB,DA1_PRCVEN,DA1_QTDLOT,DA1_MOEDA,DA1_VLRDES "
			cQuery += GetUserFields("DA1")
			cQuery += "FROM "+RetSqlName("DA1")+" DA1 "
			cQuery += "WHERE "
			cQuery += "DA1.DA1_FILIAL='"+xFilial("DA1")+"' AND "
			cQuery += "DA1.DA1_CODPRO='"+SB1->B1_COD+"' AND "
			cQuery += "( DA1_DATVIG <= '"+Dtos(dDataBase)+ "' OR DA1_DATVIG = '"+Dtos(Ctod(""))+ "' ) AND "
			cQuery += "DA1_ATIVO = '"+"1"+"' AND  "
			cQuery += "DA1.D_E_L_E_T_=' ' "
			cQuery := WsQueryAdd(cQuery,::QueryAddWhere)
			cQuery += "ORDER BY "+SqlOrder(DA1->(IndexKey()))
			
			cQuery := ChangeQuery(cQuery)
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor)
			
			For nY := 1 To Len(aStru)
				If aStru[nY][2]<>"C".And. FieldPos(aStru[nY][1])<>0
					TcSetField(cCursor,aStru[nY][1],aStru[nY][2],aStru[nY][3],aStru[nY][4])
				EndIf
			Next nY		
		#ELSE
		    MsSeek(xFilial("DA1")+SB1->B1_COD)
		#ENDIF
		While !Eof() .And. xFilial("DA1") == (cCursor)->DA1_FILIAL .And.;
			SB1->B1_COD == (cCursor)->DA1_CODPRO			
			If MaVldTabPrc((cCursor)->DA1_CODTAB,"","sem help",dDatabase)
				dbSelectArea("DA0")
				dbSetOrder(1)
				MsSeek(xFilial("DA0")+(cCursor)->DA1_CODTAB)
				aadd(::PriceTable,WSClassNew("PriceView"))
				nX++
				::PriceTable[nX]:ProductCode    := SB1->B1_COD
				::PriceTable[nX]:PaymentPlanCode:= DA0->DA0_CONDPG
				::PriceTable[nX]:PriceTableCode := (cCursor)->DA1_CODTAB
				::PriceTable[nX]:Price          := (cCursor)->DA1_PRCVEN
				::PriceTable[nX]:QuantityLimit  := (cCursor)->DA1_QTDLOT
				::PriceTable[nX]:Currency       := (cCursor)->DA1_MOEDA
				::PriceTable[nX]:CurrencySimbol := SuperGetMV("MV_SIMB"+AllTrim(Str((cCursor)->DA1_MOEDA,2)))
				::PriceTable[nX]:DiscountValue  := (cCursor)->DA1_VLRDES
				UserFields("DA1",@::PriceTable[nX]:UserFields,cCursor)
			EndIf
			dbSelectArea(cCursor)
			dbSkip()
		End
		If lQuery
			dbSelectArea(cCursor)
			dbCloseArea()
			dbSelectArea("DA1")
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault("GETPRICE",STR0013) //"Produto nao encontrado"
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetInvento³Autor  ³ Eduardo Riera         ³ Data ³21.05.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao dos saldos em estoque                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do produto                                     ³±±
±±³          ³ExpD3: Data do estoque                                       ³±±
±±³          ³       Se a data de estoque for igual a data base sera retor-³±±
±±³          ³       nado o saldo atual, caso contrario o historico        ³±±
±±³          ³ExpN4: [1] - Estoque por empresa                             ³±±
±±³          ³       [2] - Estoque por almoxarifado                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a tabela de preco em sua respectiva estru³±±
±±³          ³tura                                                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Atualizacoes sofridas desde a Construcao Inicial.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador  ³ Data   ³ BOPS ³  Motivo da Alteracao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Cleber M.    ³21/11/06³113345³-Inclusao de UserFields() para tratar os ³±±
±±³              ³        ³      ³campos de usuario.                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetInventory WSRECEIVE UserCode,ProductCode,InventoryDate,TypeOfInventory,QueryAddWhere WSSEND Inventory WSSERVICE MtProduct

Local aArea     := GetArea()				//Guarda a area atual
Local aSaldo    := {}						//Array dos saldos em estoque
Local aTipo     := {STR0014,STR0015,STR0016} //"Estoque proprio em poder do contribuinte"###"Estoque proprio em poder de terceiros"###"Estoque de terceiros em poder do contribuinte"
Local aRetorno  := {}						//Array de retorno da CalcEst()
Local lRetorno  := .T.						//Indica retorno da funcao
Local lQuery    := .F.						//Indica se executou query
Local dData     := ::InventoryDate			//Data de estoque
Local cQuery    := ""						//Query a ser executada
Local cChave    := ""						//Chave de indice para DBF
Local cIndSB6   := ""						//Arq. de trabalho (DBF)
Local cAliasSB2 := "SB2"					//Alias do arq. SB2
Local nX        := 0						//Usada em lacos For...Next	
Local nY        := 0						//Usada em lacos For...Next
Local lLocal    := .F.						//Indica se usa localizacao

DEFAULT ::TypeOfInventory := 1
dData := IIf(Empty(dData),dDataBase,dData)
lLocal    := ::TypeOfInventory == 2
::Inventory := {}

If PrtChkUser(::UserCode,"MTPRODUCT")
	dbSelectArea("SB2")
	dbSetOrder(1)
	#IFDEF TOP
		cAliasSB2 := "GETINVENTORY"
		lQuery    := .T.
		cQuery := "SELECT B2_FILIAL,B2_COD,B2_LOCAL "
		cQuery += GetUserFields("SB2")
		cQuery += "FROM "+RetSqlName("SB2")+" SB2 "
		cQuery += "WHERE SB2.B2_FILIAL='"+xFilial("SB2")+"' AND "
		cQuery += "SB2.B2_COD='"+::ProductCode+"' AND "
		cQuery += "SB2.D_E_L_E_T_=' ' "
		cQuery := WsQueryAdd(cQuery,::QueryAddWhere)
		cQuery += "ORDER BY "+SqlOrder(SB2->(IndexKey()))

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB2)

	#ELSE
	
		MsSeek(xFilial("SB2")+::ProductCode)	
		PRIVATE nIndSb6 := 0
		dbSelectArea("SB6")
		cIndSB6 := CriaTrab(Nil,.F.)
		cChave := "B6_FILIAL+B6_PRODUTO+B6_LOCAL+B6_TIPO+DTOS(B6_DTDIGIT)"
		cQuery := 'B6_FILIAL="'+xFilial("SB6")+'" .And. DtoS(B6_DTDIGIT)<="'+Dtos(SuperGetMV("MV_ULMES"))+'"'
		IndRegua("SB6",cIndSB6,cChave,,cQuery)
		nIndSB6:=RetIndex("SB6")
		dbSetIndex(cIndSB6+OrdBagExt())
		dbSetOrder(nIndSB6+1)
		dbGoTop()

		dbSelectArea("SB2")
	#ENDIF
	While (!Eof() .And. (cAliasSB2)->B2_FILIAL == xFilial("SB2") .And.;
		(cAliasSB2)->B2_COD == ::ProductCode )
		
		aRetorno := CalcEst(::ProductCode,(cAliasSB2)->B2_LOCAL,dData)

		If !lLocal
			nY := aScan(aSaldo,{|x| x[3] == 1 .And. x[4]==""})
			If nY==0
				aadd(aSaldo,{aRetorno[1],aRetorno[2],1,""})
			Else
				aSaldo[nY][1] += aRetorno[1]
				aSaldo[nY][2] += aRetorno[2]
				aSaldo[nY][3] := 1
				aSaldo[nY][4] := ""
			EndIf
		Else
			aadd(::Inventory,WsClassNew("InventoryView"))
			::Inventory[nX]:ProductCode              := Self:ProductCode
			::Inventory[nX]:Quantity                 := aRetorno[1]
			::Inventory[nX]:Cost                     := aRetorno[2]
			::Inventory[nX]:Currency                 := 1
			::Inventory[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
			::Inventory[nX]:typeofBalance            := 1
			::Inventory[nX]:DescriptiontypeofBalance := aTipo[1]
			::Inventory[nX]:WareHouse                := (cAliasSB2)->B2_LOCAL
			UserFields("SB2",@::Inventory[nX]:UserFields,cAliasSB2)
		EndIf
		aRetorno := SaldoTerc(::ProductCode,(cAliasSB2)->B2_LOCAL,"T",dData,(cAliasSB2)->B2_LOCAL,.F.) //De terceiro
		If !lLocal
			nY := aScan(aSaldo,{|x| x[3] == 2 })
			If nY==0
				aadd(aSaldo,{aRetorno[1],aRetorno[2],2,""})
			Else
				aSaldo[nY][1] += aRetorno[1]
				aSaldo[nY][2] += aRetorno[2]
				aSaldo[nY][3] := 2
			EndIf			
		Else
			aadd(::Inventory,WsClassNew("InventoryView"))
			::Inventory[nX]:ProductCode              := Self:ProductCode
			::Inventory[nX]:Quantity                 := aRetorno[1]
			::Inventory[nX]:Cost                     := aRetorno[2]
			::Inventory[nX]:Currency                 := 1
			::Inventory[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
			::Inventory[nX]:typeofBalance            := 2
			::Inventory[nX]:DescriptiontypeofBalance := aTipo[2]
			::Inventory[nX]:WareHouse                := (cAliasSB2)->B2_LOCAL
			UserFields("SB2",@::Inventory[nX]:UserFields,cAliasSB2)
		EndIf
		aRetorno := SaldoTerc(::ProductCode,(cAliasSB2)->B2_LOCAL,"D",dData,(cAliasSB2)->B2_LOCAL,.f.) //Em terceiro
		If !lLocal
			nY := aScan(aSaldo,{|x| x[3] == 3})
			If nY==0
				aadd(aSaldo,{aRetorno[1],aRetorno[2],3,""})
			Else
				aSaldo[nY][1] += aRetorno[1]
				aSaldo[nY][2] += aRetorno[2]
				aSaldo[nY][3] := 3
				aSaldo[nY][4] := ""
			EndIf
		Else
			aadd(::Inventory,WsClassNew("InventoryView"))
			::Inventory[nX]:ProductCode              := Self:ProductCode
			::Inventory[nX]:Quantity                 := aRetorno[1]
			::Inventory[nX]:Cost                     := aRetorno[2]
			::Inventory[nX]:Currency                 := 1
			::Inventory[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
			::Inventory[nX]:typeofBalance            := 3
			::Inventory[nX]:DescriptiontypeofBalance := aTipo[3]
			::Inventory[nX]:WareHouse                := (cAliasSB2)->B2_LOCAL
			UserFields("SB2",@::Inventory[nX]:UserFields,cAliasSB2)
		EndIf

		dbSelectArea(cAliasSB2)
		dbSkip()
	End
	If lQuery
		dbSelectArea(cAliasSB2)
		dbCloseArea()
		dbSelectArea("SB2")
	EndIf
	If !lLocal
		If Empty(aSaldo)
			aSaldo := {{0,0,1,""}}
		EndIf
	Else
		If Empty(::Inventory)
			aSaldo := {{0,0,1,""}}
		EndIf
	EndIf
	For nX := 1 To Len(aSaldo)
		aadd(::Inventory,WsClassNew("InventoryView"))
		::Inventory[nX]:ProductCode              := Self:ProductCode
		::Inventory[nX]:Quantity                 := aSaldo[nX][1]
		::Inventory[nX]:Cost                     := aSaldo[nX][2]
		::Inventory[nX]:Currency                 := 1
		::Inventory[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
		::Inventory[nX]:TypeofBalance            := aSaldo[nX][3]
		::Inventory[nX]:DescriptiontypeofBalance := aTipo[aSaldo[nX][3]]
	Next nX
Else
	lRetorno := .F.
EndIf	
RestArea(aArea)
Return(lRetorno)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetTypeOfP³Autor  ³ Eduardo Riera         ³ Data ³31.07.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao dos tipode de produto                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a tabela de preco em sua respectiva estru³±±
±±³          ³tura                                                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetTypeOfProduct WSRECEIVE UserCode WSSEND TypeOfProductCollection WSSERVICE MtProduct

Local aArea     := GetArea()
Local lRetorno  := .T.
Local lQuery    := .F.
Local cAliasSX5 := "SX5"
Local nX        := 0 
#IFDEF TOP
Local cQuery    := ""
#ENDIF

If PrtChkUser(::UserCode,"MTPRODUCT")

	dbSelectArea("SX5")
	dbSetOrder(1)
	#IFDEF TOP
	
		lQuery    := .T.
		cAliasSX5 := "GetTypeOfProduct"
		
		cQuery := "SELECT * "
		cQuery += "FROM "+RetSqlName("SX5")+" SX5 "
		cQuery += "WHERE SX5.X5_FILIAL='"+xFilial("SX5")+"' AND "
		cQuery += "SX5.X5_TABELA='02' AND "
		cQuery += "SX5.D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(SX5->(IndexKey()))
		
		cQuery := ChangeQuery(cQuery)
		
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSX5)	
	
	#ELSE
		dbSeek(xFilial("SX5")+"02")
	#ENDIF
	While !Eof() .And. (cAliasSX5)->X5_FILIAL == xFilial("SX5") .And. (cAliasSX5)->X5_TABELA == "02"
		
		aadd(::TypeOfProductCollection,WsClassNew("GenericStruct"))
		nX++
		::TypeOfProductCollection[nX]:Code        := ( cAliasSX5 )->X5_CHAVE
		::TypeOfProductCollection[nX]:Description := X5Descri(cAliasSX5)
	
		dbSelectArea(cAliasSX5)
		dbSkip()
		
	EndDo
	If lQuery
		dbSelectArea(cAliasSX5)
		dbCloseArea()
		dbSelectArea("SX5")
	EndIf
EndIf

RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetStock  ³Autor  ³ Eduardo Riera         ³ Data ³15.09.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao do saldo em estoque                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do produto                                     ³±±
±±³          ³ExpC3: Almoxarifado                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a tabela de preco em sua respectiva estru³±±
±±³          ³tura                                                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Atualizacoes sofridas desde a Construcao Inicial.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador  ³ Data   ³ BOPS ³  Motivo da Alteracao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Cleber M.    ³16/10/06³106158³Alteracao para pegar o custo unitario do ³±±
±±³              ³        ³      ³campo B2_CM1.                            ³±±
±±³ Cleber M.    ³21/11/06³113345³Inclusao de UserFields() para tratar os  ³±±
±±³              ³        ³      ³campos de usuario.                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetStock WSRECEIVE UserCode,ProductCode,WareHouse WSSEND Stock WSSERVICE MtProduct

Local aArea    := GetArea()		//Guarda a area atual
Local lRetorno := .T.			//Variav. de retorno da funcao
Local nX       := 0				//Usada como indice de array

DEFAULT WareHouse := ""

If PrtChkUser(::UserCode,"MTPRODUCT","GetStock")

	dbSelectArea("SB1")
	dbSetOrder(1)
	If MsSeek(xFilial("SB1")+::ProductCode)
	
		dbSelectArea("SB2")
		dbSetOrder(1)

		If MsSeek(xFilial("SB2")+PadR( ::ProductCode, TAMSX3("B2_COD")[1] )+::WareHouse)
			While !Eof() .AND. xFilial("SB2") == SB2->B2_FILIAL .AND.;
				AllTrim( ::ProductCode ) == AllTrim( SB2->B2_COD ) .AND.;
				(::WareHouse == "" .OR. ::WareHouse == SB2->B2_LOCAL)
			
				aAdd(::Stock,WsClassNew("InventoryView"))
				nX++
				::Stock[nX]:ProductCode              := SB2->B2_COD
				::Stock[nX]:WareHouse                := SB2->B2_LOCAL
				::Stock[nX]:Quantity                 := SaldoSB2()
				::Stock[nX]:Cost                     := SB2->B2_CM1
				::Stock[nX]:Currency                 := 1
				::Stock[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
				::Stock[nX]:TypeofBalance            := 1
				::Stock[nX]:DescriptiontypeofBalance := STR0014 //"Estoque proprio em poder do contribuinte"
				UserFields("SB2",@::Stock[nX]:UserFields,"SB2")
	
				dbSelectArea("SB2")
				dbSkip()
			End
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault("GETSTOCK",STR0013)		 //"Produto nao encontrado"
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ-ÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GetDisCount³ Autor ³Nilton Pereira        ³ Data ³30.09.2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ-ÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Metodo de avaliacao da regra de desconto para os modulos    ³±±
±±³          ³que possuem pedido de venda                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Produto                                              ³±±
±±³          ³ExpC2: Cliente/Loja                                         ³±±
±±³          ³ExpC3: Tabela de Preco                                      ³±±
±±³          ³ExpC4: Quantidade                                           ³±±
±±³          ³ExpC5: Condicao de Pagamento                                ³±±
±±³          ³ExpN6: Tipo de Desconto                                     ³±±
±±³          ³       1 - Desconto por Item                                ³±±
±±³          ³       2 - Desconto por Total                               ³±±
±±³          ³ExpN8: Preco base do Item  (Unitario)                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Percentual de Desconto da Regra                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo avaliar a regra de descontos  ³±±
±±³          ³conforme os parametros da rotina                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetDisCount WSRECEIVE UserCode,ProductCode,CustomerID,PriceTableCode,Quantity,PaymentPlanCode,DiscountType,BasePrice WSSEND DisCountPercentage WSSERVICE MtProduct

Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)
Local lRetorno  := .T.

If PrtChkUser(::UserCode,"MTPRODUCT","GetDisCount")
	::DisCountPercentage := MaRgrDesc(::ProductCode,cCliente,cLoja,::PriceTableCode,::Quantity,::PaymentPlanCode,,::DiscountType,/*aProds*/,/*aExc*/, /*cCodRegDe*/, ::BasePrice)
Else
	lRetorno := .F.
EndIf

Return(lRetorno)

Function wsmat010()
Return