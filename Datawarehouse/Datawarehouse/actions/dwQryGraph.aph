<%
// ######################################################################################
// Projeto: DATA WAREHOUSE
// Modulo : Actions
// Fonte  : dwQryGraph - Processa consultas de gráfico
// ---------+-------------------+--------------------------------------------------------
// Data     | Autor             | Descricao
// ---------+-------------------+--------------------------------------------------------
// 01.06.01 | 0548-Alan Candido |
// 25.04.08 | 0548-Alan Candido | BOPS 144808
//          |                   | Correção no tratamento de indicadores, em consultas de 
//          |                   | gráfico com DD e gráfico pizza.
// 12.08.08 |0548-Alan Cândido  | BOPS 146580 (habilitado pelo define DWCACHE)
//          |                   | Implementação de novo sistema de leitura da consulta (uso de cache).
// 09.12.08 | 0548-Alan Candido | FNC 00000149278/811 (8.11) e 00000149278/912 (9.12)
//          |                   | Adequação de procedimentos para ranking por nível de drill-down
// --------------------------------------------------------------------------------------

#include "dwincs.ch"
#INCLUDE "m1execon.ch"
#INCLUDE "dwQryGraph.ch"

#define VAZIO        "{VAZIO}"
#define A_NEGATIVO   "("
#define F_NEGATIVO   ")"
#define EXTDOWN      ".htm"
#define EXTIMG       ".jpeg"

//constantes para carga das propriedades

#define QTDPROPSY	23
#define YTITULO		1
#define YBASE		2
#define YMETA		3
#define YESCLOG		4
#define YLOGBASE	5
#define YESCAUTO	6
#define YVLMIN		7
#define YVLMAX		8
#define YINC		9
#define Y2EIXO		10
#define Y2TITULO	11
#define Y2ESCLOG	12
#define Y2LOGBASE	13
#define Y2ESCAUTO	14
#define Y2VLMIN		15
#define Y2VLMAX		16
#define Y2INC		17
#define DDNOVAJAN	18
#define PONTPAG		19
#define YTITMARCA	20
#define Y2TITMARCA	21
#define Y2BASE		22
#define Y2META		23

#define QTDPROPS	29
#define SERIEFONTE	1
#define SERIETAM	2
#define SERIECOR	3
#define XYFONTE		4
#define XYTAM		5
#define XYCOR		6
#define XYINTENS	7
#define XYSOBRE		8
#define CORFUNDO	9
#define CORGRAF		10
#define IMAGEM		11
#define VERVALOR	12
#define VERLEG		13
#define VERZONA		14
#define PZTIT		15
#define PZVLINI		16
#define PZVLFIM		17
#define PZCOR  		18
#define SZTIT		19
#define SZVLINI		20
#define SZVLFIM		21
#define SZCOR  		22
#define TZTIT		23
#define TZVLINI		24
#define TZVLFIM		25
#define TZCOR  		26
#define TZDECIMAL	27
#define TZFORMIND 	28
#define TZFORMUNIC	29

#define SPACE_PER_CHAR 	8 // espaço necessário para exibir 1 caracter em tela

//variáveis para uso com o gráfico
local nQtdDim 		:= 0 //qtde de dimensoes
local nLenDim 		:= 0 //qtde de dimensoes selecionadas
local nOcor 		:= 0 //qtde de ocorrencia na grafico de pizza
local nRMargem 		:= 20 //margem direita
local nLMargem 		:= 125 //margem esquerda
local nTMargem 		:= 25 //margem esquerda
local nBMargem 		:= 50 //margem esquerda
local nLegTam 		:= 100
local nTamPad 		:= 300
local lBarra 		:= .f. //eixo
local cTitulo 		:= "" //titulo do drill-down
local cValTit 		:= "" //parte de titulo do drill-down
local cLabel 		:= "" //titulo do eixo
local cDesc 		:= "" //serie a ser exibida
local cTogether 	:= "" //define se a pizza sera junta ou separada
local lQuebra 		:= .f. //forca a quebra de linha
local lArea 		:= .f. //define o gráfico de area
local lLegenda 		:= .t. //habilita a legenda
local nTipoGraf 	:= 0 //define o tipo do grafico
local aTypeGraph 	:= { "BAR", "BAR3D","BAR", "BAR3D", "LINE", "LINE3D", "PIE", "RADAR", "GAUGE" } //array com os tipos de graficos
local aTypeFont 	:= { "ARIAL", "TIMES NEW ROMAN", "COURIER", "SANSSERIF" }
local nIndTamChart 	:= 1000 //area a ser resevada para exibicao do grafico
local nAtrTamChart 	:= 1000 //area a ser resevada para exibicao do grafico
local aBuffer 		:= {}
local nDim 			:= 0
local aCorPie 		:= {}
local cAux, aAux 	:= {}
local nTam, nNDec

// parametros
local nConsID 		:= dwval(HTTPGET->Id) //ID da consulta
local nType 		:= 2 //Tipo da consulta 1=tabela / 2=grafico

local aPaginTrack 	:= DwToken(isNull(HttpGet->PaginTrack, ""), "_", .F.) //array com os valores do rastreamento da paginação
local aValY 		:= DWToken(strtran(strtran(isNull(HTTPGET->Valuey, ""),"\n", ";"),"§", ";"), ";", .f.) //array com os valores enviados (paginacao)
local aValDrill 	:= DWToken(strtran(strtran(isNull(HTTPGET->VAL_DRILL, ""),"\n", ";"),"§", ";"), ";", .f.) //array com os valores enviados (drill)
local aPageValues 	:= {}, aCurrKeys := {}, aCurrValues := {}
local lDrilldown 	:= isNull(HTTPGET->Drilldown, "") == "on" //define se e drilldown
local lDrillup 		:= isNull(HTTPGET->Drillup, "") == "on" //define se e drillup (primeiro nivel)
local lPaginar 		:= isNull(HTTPGET->Paginar, "") == "on" //define se e paginacao
local nqtdproc 		:= dwval(HTTPGET->Baserow) //qtde de registros processados
local nInterval 	:= dwval(HTTPGET->Valinterv) //valor de intervalo exibido no grafico
local nMaior 		:= 0 //maior valor exibido no grafico
local nMenor 		:= 0 //menor valor exibido no grafico
local aValX 		:= DWToken(isNull(HTTPGET->Valuex, ""), ";", .f.) //sempre será vazio
local nIndic 		:= dwval(HTTPGET->Indic) //indice do indicador clicado no drilldown
local cJPEGFile 	:= isNull(HTTPPOST->edArquivo, "") //nome do arquivo
local cTexto 		:= isNull(HTTPPOST->edOcorrenc, "") //texto de ocorrencia
local nMaiDesc 		:= dwval(HTTPGET->MaiorDesc) //maior descricao ate o momento
local cTipoPag 		:= isNull(HTTPGET->Naveg,"next")
local cJPEGCont 	:= isNull(HTTPPOST->cbase64, "")
local cOrigem 		:= isNull(HTTPPOST->origem, "")   
local oExport 		:= InitTable(TAB_EXPORT) /*Abre a tabela de exportação.*/
local aResult 		:= {}, aAuxResult := {}, aAuxValue := {}
local cCorPreta 	:= "-256"
local cCorBranca 	:= "99999
local cFontGraph 	:= "ARIAL|BOLD|10"
local cFontSerie 	:= cFontGraph
local cFontEixo 	:= cFontGraph
local cCorSerie 	:= cCorPreta
local cCorEixo 		:= cCorPreta
local cCorFundo 	:= cCorBranca
local cCorGraph 	:= cCorBranca
local cIntens 		:= "128"
local nSobrepor 	:= 0
local cPrimSerie 	:= ""
local cUltSerie 	:= ""
local cval_max 		:= ""
local cval_min 		:= ""
local cval_interv 	:= ""
local nMaiLeg 		:= 0

// variaveis de trabalho local
local nInd
local nInd2
local aProps 		:= {}
local aPropsY 		:= {}
local aPropsY2 		:= {}
local nRow
local cInd
local nInic 		:= 1
local nMenDesc 		:= 0
local aFilter 		:= {}
local nValY 		:= len(aValY)
local nValDrill 	:= len(aValDrill)
local aRetVal 		:= {}
local aDesc 		:= {}, nGreatestDesc := 0
local aValInd 		:= {}
local aValInds 		:= {}
local aValAgrup 	:= {}
local nAgrup 		:= 0
local aAgrup 		:= {}
local cSelect 		:= ""
local cWhereAux 	:= ""
local aWhereAux 	:= {}
local cRealValor 	:= ""
local cAdjValor 	:= ""
local nValor 		:= 0
local lHasDrill 	:= .f.
local nQtdEixo 		:= 0
local nQtdPagina 	:= 0
local nQtdPrevPage
local nQtdLinTit 	:= 0
local lFirst 		:= .f.
local nQtAtPN 		:= 0
local nDrillOrig, nDrillLevel
local aData 		:= {}
local cPath, cRandom
local cRootPath, cSitePath
local nQtdSerie 	:= 0  
/*Lista de anexos de e-mail do processo de exportação.*/
local aAnexo 		:= {} 
Local cExpFilDir	:= ""

// variaveis de trabalho privativas
private aDimY, aInd, aInd2, lIndVirt := .F.
private oConsulta, oBrowse

if upper(cOrigem) == "JAVA"
	
	if oExport:Seek(2, { EX_GRAF, nConsID })
		cJPEGFile 	:= oExport:value("arquivo")
		cTexto		:= oExport:value("ocorrenc")
	endif
	
	if empty(cJPEGFile)
		cJPEGFile := "chart"+dwstr(oUserDW:LoginName())+dwstr(nConsID)
	endif
endif

cRandom := randByDate() + randByTime()

if cJPEGFile <> ""   

	cPath := "\expfiles\"
	cFileHtml := fileFisicalDirectory(DwFixPath(DwExpFilesPath()) + cJPEGFile + cRandom + EXTDOWN)
	
	cSitePath := GetPvProfString(getWebHost(), "Path", "web/sigadw3", GetADV97())
	cRootPath := GetPvProfString(getEnvServer(), "RootPath", "", GetADV97())
	cExpFilDir	:= strTran( cSitePath, cRootPath )+ cPath
	
	//-------------------------------------------------------------------------
	// Cria diretório de arquivos exportados caso ele não exista.
	//------------------------------------------------------------------------- 
	If !( ExistDir( cExpFilDir ) )
		WFForceDir( cExpFilDir )
	EndIf

	cFileJpeg := fileFisicalDirectory(cExpFilDir + cJPEGFile + cRandom)
	
	aRetVal := DwToken(cJPEGCont, "§", .F., .T.)
	for nInd := 1 to len(aRetVal)
		oFile := TDWFileIO():New(cFileJpeg + DwStr(nInd) + EXTIMG)
		oFile:Create()
		oFile:WriteLN(decode64(aRetVal[nInd]))
		oFile:Close()
		oFile:Free()
	next
	
	cAux := "<HTML>" 
	cAux += "<BODY>"  
	cAux += "<b><h2>" + STR0001 + "</h2></b>" //###"Exportação de Ocorrência"
	cAux +=	STR0002 + " <b>" + oSigaDW:DWCurr()[DW_DESC] + " (" + oSigaDW:DWCurr()[DW_NAME] + ")</b>" //###"Datawarehouse"
	
	oConsulta := InitTable(TAB_CONSULTAS)
	oConsulta:Seek(1, {nConsID})
	if !oConsulta:EoF() .and. oConsulta:value("id") == nConsID
		cAux += "<br>" + STR0003 + " <b>" + oConsulta:value("descricao") + " (" + oConsulta:value("nome") + ")</b>" //###"Consulta"
	endif
	
	cAux += "<br>" + STR0004 + " <b>" + DWStr(Date()) + " - " + DWStr(time()) + "</b> "  //###"Gerada em"
	cAux += STR0005 + " <b>" + oUserDW:UserName() + " (" + oUserDW:LoginName() + ")</b> " //###"Gerada por"
	
	/*Verifica se foi informado algum conteúdo no campo ocorrência.*/
	If !(DWStr(cTexto) == "")
		/*Insere o conteúdo de ocorrência no corpo do e-mail.*/
		cAux += "<br><br><b>" + STR0006 + " </b> <i><pre>" + DWStr(cTexto) + "</pre></i>" //###"Ocorrência:"
	EndIf
	
	/*Posiciona nos dados de exportação da consulta corrente.*/	
	oExport:Seek(2, { EX_GRAF, nBIVal(dwGetProp("idtipo", "h_dwQryXport.aph")) })
	
	/*Verifica se o grafico será enviado como anexo no e-mail.*/
	If (oExport:value("AttachFile"))
		/*Insere informação no corpo do e-mail.*/
		cAux += "<br><br>" + STR0012 /*Por favor, caso a imagem não apareça no corpo de email verifique o arquivo anexo."*/   		

		for nInd := 1 to len(aRetVal)  
			/*Adiciona a imagem como anexo passando o caminho completo do servidor.*/
	   		aAdd(aAnexo , cFileJpeg + DwStr(nInd) + EXTIMG)
   		next		
	EndIf
	
	for nInd := 1 to len(aRetVal)
		/*Insere o link no corpo do e-mail.*/
		cAux += "<br><img src=http://" + GetWebHost() + "/expfiles/" + cJPEGFile+cRandom+DwStr(nInd)+EXTIMG+">"
	next      
	
	cAux += "</BODY>" 
	cAux += "</HTML>"  

	oFile := TDWFileIO():New(cFileHtml)
	oFile:Create()
	oFile:WriteLn(cAux)
	oFile:Close()
	oFile:Free()
	
	if !empty(HttpPost->edMailList)
		DWSendMail(STR0007 + " " + cJPEGFile+cRandom+EXTDOWN, cAux, HttpPost->edMailList, nil, aAnexo) //###"SigaDW - Arquivo exportado:"
	endif
	
	if upper(cOrigem) == "JAVA"
		cAux := strTran(strTran(makeAction(AC_DOWNLOAD, { {"fileName", cJPEGFile+cRandom+EXTDOWN}, {"fileRelativePath", DwFixPath(DwExpFilesPath())}, {"extensFile", ""}, {"_forceReload", cRandom} }), "amp;", "&"), '"', "")
	else
		oSigaDW:buildCabec(aBuffer)
		oSigaDW:buildBeginBody(aBuffer)
		cAux := dwConcatWSep(CRLF, aBuffer) + buildDownload(cJPEGFile+cRandom+EXTDOWN, DwFixPath(DwExpFilesPath()),,.T.)
	endif
	
	return cAux
else
	#ifdef DWCACHE
		oConsulta := dwNewCons(nConsID, nType)
	#else
		oConsulta := TConsulta():New(nConsID, nType, .f.)
		oConsulta:UpdCacheRuntime()
	#endif
	oConsulta:FieldList()
	oConsulta:AlertOn(.f.)
	
	aDimY := oConsulta:DimFieldsY()
	nQtdDimY := oConsulta:DimCountY()
	nLenDim := nQtdDimY
	aInd  := oConsulta:Indicadores(.t.)
	
	// qualquer indicador utilizado em campo virtual e que foi adicionado automaticamente será colocado no fim do array
	// (necessário pois os dados virão da consulta nesta ordem)
	aInd2 := {}
	for nInd := 1 to 2
		for nInd2 := 1 to len(aInd)
			if (!lIndVirt .and. aInd[nInd2]:Ordem() > 0) .or. (lIndVirt .and. aInd[nInd2]:Ordem() < 1)
				aAdd(aInd2, aInd[nInd2])
			endif
		next
		lIndVirt := !lIndVirt
	next
	aInd := aInd2
	
	aPageValues := aClone(aValDrill)
	aScan(aValY, {|aElem| aAdd(aPageValues, aElem)})
	
	aProps := DWToken(oConsulta:GraphProps(), ";", .f.)
	aPropsY := DWToken(oConsulta:GraphYProps(), ";", .f.)
	
	setGraphYPropsDefault(aPropsY)
	setGraphPropsDefault(aProps)
	
	cCorPreta := "000000"
	cCorBranca := "FFFFFF"
	
	lHasDrill := oConsulta:HaveDrillDown()
	nDrillOrig := oConsulta:DrillLevel()
	nQtAtPN := aScan(aDimY, { |x| x:DrillDown() == .t. } )
	
	if !lHasDrill
		if !lPaginar
			lFirst := .t.
		endif
		nInic := 1
		nQtdDim := len(aDimY)
		nDrillLevel := len(aDimY)
		for nInd := len(aValDrill)+1 to len(aPageValues)
			aPageValues[nInd] := dwStr(dwConvTo(aDimY[nInd-len(aValDrill)]:Tipo(), aDimY[nInd-len(aValDrill)]:RealValue(allTrim(aPageValues[nInd]))),.f.)
		next
	else
		if !lPaginar .and. !lDrillDown .and. !lDrillUp
			lFirst := .t.
			nInic := 1
			nQtdDim := nQtAtPN
			nDrillLevel := 1
		else
			if lPaginar
				if !isNull(aValDrill) .and. len(aValDrill) > 0
					nTMargem := 75
				endif
				
				if (nQtAtPN+(nDrillOrig-1)) > 0 .and. (nQtAtPn <> (nValY+nValDrill))
					if nQtAtPN <= nValDrill
						oConsulta:PrepDrill(DRILLRESET)
						for nInd := nQtAtPN to nValDrill
							oConsulta:PrepDrill(DRILLDOWN)
						next
					endif
					
					nValY := nInd
					nQtdLinTit := int(nValY/3)
					if mod(nValY,3) > 0
						nQtdLinTit := nQtdLinTit + 1
					endif
					nInd2 := 1
					
					if nValDrill > 0
						for nInd := 1 to nValY-1
							if len(aPageValues) >= nInd .and. left(aPageValues[nInd],1) == A_NEGATIVO .and. right(aPageValues[nInd],1) == F_NEGATIVO
								aPageValues[nInd] := substr(aPageValues[nInd], 2, len(aPageValues[nInd])-2)
							endif
							if aDimY[nInd]:Tipo() == "D"
								cAdjValor := aDimY[nInd]:RealValue(allTrim(aPageValues[nInd]))
								cRealValor := dwstr(right(cAdjValor,4) + substr(cAdjValor,4,2) + left(cAdjValor,2))
							else
								cAdjValor := dwStr(dwConvTo(aDimY[nInd]:Tipo(), aDimY[nInd]:RealValue(allTrim(aPageValues[nInd]))),.f.)
								cRealValor := dwStr(dwConvTo(aDimY[nInd]:Tipo(), aDimY[nInd]:RealValue(allTrim(aPageValues[nInd]))),.f.)
								if cRealValor == VAZIO
									cRealValor := ""
								endif
							endif
							
							cValTit := DWStr(cAdjValor)
							cValTit := strtran(cValTit, "-", "\-")
							cValTit := strtran(cValTit, "..", "\..")
							cTitulo := cTitulo + QBE2Html(aDimY[nInd]:Name(), "C", { aDimY[nInd]:AdjustValue(cValTit) }, aDimY[nInd]:Desc(), {}, {}, .t., , , .t.) + " E "
							
							if nInd2 == nQtdLinTit
								cTitulo := cTitulo + " "
								nInd2 = 1
							else
								nInd2 := nInd2 + 1
							endif
							
							aValDrill[nInd] := cRealValor
							if aDimY[nInd]:Tipo() == "N"
								aAdd(aFilter, aDimY[nInd]:Alias() + '=' + cRealValor)
							else
								aAdd(aFilter, aDimY[nInd]:Alias() + '='+ "'" + cRealValor + "'")
							endif
						next
						
						if len(cTitulo) > 0
							cTitulo := left(cTitulo, len(cTitulo)-3)
						endif
						
						if !empty(aData)
							aAdd(aFilter, MakeData(aData))
						endif
					endif
				endif
				
				// redefine a variável nValY
				nValY := len(aValY)
				if ((((nValY - nQtAtPN) == 0) .and. (nQtAtPN > 1))) .or. (nValY == 1 .and. nQtAtPN > 1 .and. oConsulta:DrillLevel() == oConsulta:DrillOrig())
					nInic := 1
				else
					nInic := oConsulta:DrillLevel()
				endif
				nDrillLevel := oConsulta:DrillLevel()
				nQtdDim := nDrillLevel
				
				for nInd := 1 to len(aPageValues)
					if aDimY[nInd]:Tipo() != "D"
						aPageValues[nInd] = aDimY[nInd]:RealValue(allTrim(aPageValues[nInd]))
					endif
				next
			elseif lDrillDown
				// desvio para quando for drill down e for em outra janela
				nTMargem := 75
				if (nValDrill - nQtAtPN) > 0
					oConsulta:PrepDrill(DRILLRESET)
					for nInd := nQtAtPN to nValDrill
						oConsulta:PrepDrill(DRILLDOWN)
					next
				else
					oConsulta:PrepDrill(DRILLRESET)
					oConsulta:PrepDrill(DRILLDOWN)
				endif
				nInic := oConsulta:DrillLevel()
				nQtdDim := oConsulta:DrillLevel()
				nDrillLevel := oConsulta:DrillLevel()
				
				nQtdLinTit := int(nValDrill/3)
				if mod(nValDrill,3) > 0
					nQtdLinTit := nQtdLinTit + 1
				endif
				nInd2 := 1
				for nInd := 1 to nValDrill
					if left(aValDrill[nInd],1) == A_NEGATIVO .and. right(aValDrill[nInd],1) == F_NEGATIVO
						aValDrill[nInd] := substr(aValDrill[nInd], 2, len(aValDrill[nInd])-2)
					endif
					if aDimY[nInd]:Tipo() == "D"
						cAdjValor := aDimY[nInd]:RealValue(allTrim(aValDrill[nInd]))
						cRealValor := dwstr(right(cAdjValor,4) + substr(cAdjValor,4,2) + left(cAdjValor,2))
					else
						cAdjValor := dwStr(dwConvTo(aDimY[nInd]:Tipo(), aDimY[nInd]:RealValue(allTrim(aValDrill[nInd]))),.f.)
						cRealValor := cAdjValor //dwStr(dwConvTo(aDimY[nInd]:Tipo(), aDimY[nInd]:RealValue(allTrim(aValDrill[nInd]))),.f.)
						if cRealValor == VAZIO
							cRealValor := ""
						endif
					endif
					aValDrill[nInd] := cRealValor
					if aDimY[nInd]:Tipo() == "N"
						aAdd(aFilter, aDimY[nInd]:Alias() + '=' + cRealValor)
					else
						aAdd(aFilter, aDimY[nInd]:Alias() + '='+ "'" + cRealValor + "'")
					endif
					cValTit := DWStr(cAdjValor)
					cValTit := strtran(cValTit, "-", "\-")
					cValTit := strtran(cValTit, "..", "\..")
					cTitulo := cTitulo + QBE2Html(aDimY[nInd]:Name(), "C", { aDimY[nInd]:AdjustValue(cValTit) }, aDimY[nInd]:Desc(), {}, {}, .t., , , .t.) + " E "
					if nInd2 == nQtdLinTit
						cTitulo := cTitulo + " "
						nInd2 = 1
					else
						nInd2 := nInd2 + 1
					endif
				next
				if !empty(aData)
					aAdd(aFilter, MakeData(aData))
				endif
				if len(cTitulo) > 0
					cTitulo := left(cTitulo, len(cTitulo)-3)
				endif
				oConsulta:DDFilter(aFilter)
			endif
		endif
	endif
	
	oConsulta:DrillParms(len(aValDrill), DWConcatWSep("!", aValDrill))
	
	aNewValY := {}
	for nInd := 1 to nDrillLevel
		if lPaginar
			aAdd(aNewValY, aPageValues[nInd])
		else
			if nInd > len(aValY)
				aAdd(aNewValY, NIL)
			else
				aAdd(aNewValY, aValY[nInd])
			endif
		endif
	next
	
	oConsulta:KeyValues({ aclone(aNewValY) , aclone(aNewValY) })
	if lFirst
		aResult := oConsulta:FirstPage(.F.)
	elseif !lPaginar
		aResult := oConsulta:FirstPage(.t.)
	else
		if cTipoPag == "next"
			aResult := oConsulta:NextPage(, .T.)
		else
			oConsulta:pageSize( DwVal(aPaginTrack[len(aPaginTrack) - 1]) )
			aResult := oConsulta:PriorPage(.T.)
		endif
	endif
	
	if SGDB() == DB_INFORMIX
		nQtdSerie := 1
	else
		nQtdSerie := oConsulta:RecCount()
	endif
	
	if len(aResult) > PAGE_SIZE
		for nInd := 1 to PAGE_SIZE
			aAdd(aAuxResult, aResult[nInd])
		next
		aResult := aAuxResult
	endif
	
	nQtdPagina := len(aResult)
	if cTipoPag == "next"
		nQtdProc := nQtdProc + nQtdPagina
	elseif cTipoPag == "prior"
		// recupero o valor da qtde de registros da pagina anterior (da qual estou voltando)
		nQtdPrevPage := DwVal(aPaginTrack[len(aPaginTrack)])
		// limpo o valor da qtde de registros da última e penúltima 	paginação (daquela de qual estou vindo e aquela para onde vou)
		aPaginTrack[len(aPaginTrack)] 	:= NIL
		aPaginTrack[len(aPaginTrack)-1] := NIL
		aPaginTrack := packArray(aPaginTrack)
		
		// cálculo da quantidade processada
		nQtdProc := nQtdProc - nQtdPrevPage
	endif
	// guardo o valor da página atual
	aAdd(aPaginTrack, nQtdPagina)
	nQtdEixo := nQtdPagina
	
	// Envia os dados para o "navegador"
	__Response := ""
	
	if len(aResult) > 0
		
		if lHasDrill .and. nDrillLevel > nQtAtPN .and. !lFirst
			nTipoGraf := iif( DWval(aDimY[nDrillLevel]:GraphColor()) < 0, 0, DWval(aDimY[nDrillLevel]:GraphColor()))
		else
			nTipoGraf := iif( dwval(oConsulta:GraphClass()) < 0, 0, dwval(oConsulta:GraphClass()))
		endif
		
		if nTipoGraf == CHART_BAR .or. nTipoGraf == CHART_BAR3D
			lBarra := .t.
		endif
		
		if lHasDrill .and. !lFirst
			cLabel := aDimY[nDrillLevel]:Desc()
		else
			for nInd := nInic to nQtdDim
				cLabel := cLabel + aDimY[nInd]:Desc() + " § "
			next
			cLabel := left(cLabel, len(cLabel)-3)
		endif
		
		aDesc := {}
		aValInds := {}
		nValor := 0
		for nInd := 1 to len(aInd)
			aValInd := {}
			for nRow := 1 to len(aResult)
				if nInd == 1
					cDesc := ""
					if (lHasDrill .or. (!lHasDrill .and. nQtdDimY == 1) ) .and. mod(nRow,2) == 0 .and. lQuebra .and. nTipoGraf <> CHART_BAR .and. nTipoGraf <> CHART_BAR3D .and. nTipoGraf <> CHART_PIE
						cDesc := cDesc + "\n"
					endif
					aAuxResult := {}
					aAuxValue := {}
					for nDim := nInic to nQtdDim
						nMaiDesc := nTamDesc(nMaiDesc, DWStr(aDimY[nDim]:AdjustValue(aResult[nRow,nDim])), .f.)
						nMenDesc := nTamDesc(nMenDesc, DWStr(aDimY[nDim]:AdjustValue(aResult[nRow,nDim])), .t.)
						cDesc := cDesc + DWStr(aDimY[nDim]:AdjustValue(aResult[nRow,nDim])) + "\n"
						aAdd(aAuxResult, { "S."+aDimY[nDim]:Alias(), aDimY[nDim]:Tipo(), aDimY[nDim]:Tam() })
						aAdd(aAuxValue, DWConvTo(aDimY[nDim]:Tipo(), aResult[nRow,nDim]))
					next
					cDesc := left(cDesc, len(cDesc)-2)
					if nTipoGraf == CHART_PIE .and. DWVal(aResult[nRow,nLenDim+nInd,1]) < 0
						cDesc := A_NEGATIVO + cDesc + F_NEGATIVO
					endif
					aAdd(aDesc, strtran(cDesc, "\n", " §"))
					
					if nGreatestDesc < len(aDesc[len(aDesc)])
						nGreatestDesc := len(aDesc[len(aDesc)])
					endif
					
					aAdd(aCurrKeys, aAuxResult)
					aAdd(aCurrValues, aAuxValue)
				endif
				nValor := DWVal(aResult[nRow,nQtdDimY+nInd,1])
				
				if aInd[nInd]:ShowInd(nQtdDim) .and. aInd[nInd]:Ordem() > -1
					if nMaior < nValor
						nMaior := nValor
					endif
					if nMenor > nValor
						nMenor := nValor
					endif
				endif
				
				if nValor < 0 .and. nTipoGraf == CHART_PIE
					aAdd(aValInd, DWStr(abs(nValor)))
				else
					aAdd(aValInd, DWStr(nValor))
				endif
			next
			aAdd(aValInds, aValInd)
		next
	endif
	
	lSoIndPart := .t.
	nInd := 1
	while lSoIndPart .and. nInd <= len(aInd)
		if aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),"") <> "[%]" .and. ;
			aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),"") <> "[%T]"
			lSoIndPart := .f.
		endif
		nInd := nInd + 1
	enddo
	
	if lSoIndPart
		nMaior := 100
		nMenor := 0
	endif
	
	aRetVal := aEscala(nMenor, nMaior)
	
	nMenor := aRetVal[1]
	nInterval := aRetVal[2]
	nMaior := aRetVal[3]
	
	if len(aDesc) > 0
		aEval(aCurrValues[1], { |cValue| cPrimSerie += iif(valType(cValue) == "D", DTOS(cValue), iif(empty(cValue), "VAZIO", DwStr(cValue))) + " §" })
		aEval(aCurrValues[len(aDesc)], { |cValue| cUltSerie += iif(valType(cValue) == "D", DTOS(cValue), iif(empty(cValue), "VAZIO", DwStr(cValue))) + " §" })
		
		cPrimSerie := left(cPrimSerie, len(cPrimSerie) - 2)
		cUltSerie := left(cUltSerie, len(cUltSerie) - 2)
		
		// tem que ter paginação para construir a query para recuperar o max, min e sum
		if nQtdSerie > PAGE_SIZE
			aWhereAux := {}
			aAdd(aWhereAux, prepKeyList(aCurrKeys[1]) + ">=" + prepKeyValue(aCurrKeys[1], aCurrValues[1]))
			aAdd(aWhereAux, prepKeyList(aCurrKeys[1]) + "<=" + prepKeyValue(aCurrKeys[len(aDesc)], aCurrValues[len(aDesc)]))
		endif
	endif
	
	oQuery := TQuery():New(DWMakeName("TRA"))
	aAgrup := {"max","min", "sum"}
	aValAgrup := {}
	for nInd := 1 to len(aInd)
		if aInd[nInd]:Ordem() > 0
			aValInd := {}
			for nAgrup := 1 to len(aAgrup)
				cSelect := aAgrup[nAgrup] + "(" + aInd[nInd]:Alias() + ") " + aInd[nInd]:Alias() + " "
				if nAgrup == 3 .and.  aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),"") == "[%T]"
					oQuery := oConsulta:SQLTotal(0,aWhereAux,cSelect, , , cWhereAux)
				elseif nAgrup == 3 .and. aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),"") == "[%]"
					oQuery := oConsulta:SQLTotal(nQtdDim-1,aWhereAux,cSelect,, aInd[nInd]:Alias())
				else
					oQuery := oConsulta:SQLTotal(nQtdDim,aWhereAux,cSelect,,aInd[nInd]:Alias())
				endif
				aAdd(aValInd, oQuery:Value(aInd[nInd]:Alias()))
				oQuery:Close()
			next
			aAdd(aValAgrup, aValInd)
		else
			aAdd(aValAgrup, {0,0,0})
		endif
	next
	
	lSoIndPart := .t.
	nInd := 1
	while lSoIndPart .and. nInd <= len(aInd)
		if aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),"") <> "[%]" .and. ;
			aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),"") <> "[%T]"
			lSoIndPart := .f.
		endif
		nInd := nInd + 1
	enddo
	
	for nRow := 1 to len(aResult)
		for nDim := nInic to nQtdDim
			cAdjValor := cAtribFormat(aResult[nRow, nDim], aDimY[nDim]:Tipo())
			aResult[nRow, nDim] := cAdjValor
		next
		for nInd := nQtdDimY+1 to nQtdDimY+len(aInd)
			//nValor := nIndFormat(aResult[nRow, nInd, 1], "N", aInd[nInd-nQtdDim]:Tam(), aInd[nInd-nQtdDim]:nDec())
			nValor := aResult[nRow, nInd, 1]
			if aInd[nInd-nQtdDimY]:AggTit(aInd[nInd-nQtdDimY]:AggFunc(),"") == "[%]" .or. aInd[nInd-nQtdDimY]:AggTit(aInd[nInd-nQtdDimY]:AggFunc(),"") == "[%T]"
				nValor := (nValor * 100) / DWVal(aValAgrup[nInd-nQtdDimY][3])
			endif
			aResult[nRow, nInd,1] := nValor
			aResult[nRow, nInd,2] := transform(nValor, aInd[nInd-nQtdDimY]:Mascara())
			aValInds[nInd-nQtdDimY, nRow] := nValor
		next
	next
	
	nInd2 := 0
	aAdd(aBuffer, "INISTRDW=OK")
	
	nTam  := 0
	nNDec := 0
	if len(aResult) > 0
		for nInd := 1 to len(aInd)
			if aInd[nInd]:ShowInd(nQtdDim) .and. aInd[nInd]:Ordem() > -1
				nInd2 := nInd2 + 1
				cInd := DWStr(nInd2)
				
				if nMaiLeg < len(aInd[nInd]:Desc() + aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),""))
					nMaiLeg := len(aInd[nInd]:Desc() + aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),""))
					nLegTam := nMaiLeg * SPACE_PER_CHAR
				endif
				
				aAdd(aBuffer, "SERIE_DATA_" + cInd + "=" + DWConcatWSep("|",aValInds[nInd]))
				aAdd(aBuffer, "SERIE_COR_" + cInd + "=" + dwstr(aInd[nInd]:GraphColor()))
				aAdd(aBuffer, "SERIE_" + cInd + "=" + aInd[nInd]:Desc() + aInd[nInd]:AggTit(aInd[nInd]:AggFunc(),""))
				
				if aInd[nInd]:Tam() > nTam
					nTam := aInd[nInd]:Tam()
				endif
				if aInd[nInd]:NDec() > nNDec
					nNDec := aInd[nInd]:NDec()
				endif
				
				cAux := cMascara(aInd[nInd]:Tam(), aInd[nInd]:NDec())
				aAdd(aBuffer, "SERIE_FORMAT_" + cInd + "=" + cAux)
				aAdd(aBuffer, "SERIE_TYPE_" + cInd + "=" + aTypeGraph[nTipoGraf+1])
			endif
		next
		aAdd(aBuffer, "SERIE_FORMAT=" + cMascara(nTam, nNDec))
		
		if nTipoGraf == CHART_PIE
			aAdd(aBuffer, "SERIECOR=" + aProps[XYCOR])
			aAdd(aBuffer, "SERIEFONTE=" + aProps[XYFONTE])
			aAdd(aBuffer, "SERIETAM=" + aProps[XYTAM])
		else
			aAdd(aBuffer, "SERIECOR=" + aProps[SERIECOR])
			aAdd(aBuffer, "SERIEFONTE=" + aProps[SERIEFONTE])
			aAdd(aBuffer, "SERIETAM=" + aProps[SERIETAM])
			aAdd(aBuffer, "TZDECIMAL=" + aProps[TZDECIMAL])
			aAdd(aBuffer, "TZFORMIND=" + aProps[TZFORMIND])
			aAdd(aBuffer, "TZFORMUNIC=" + aProps[TZFORMUNIC])
		endif
		
		aAdd(aBuffer, "QTDIND=" + dwstr(nInd2))
		aAdd(aBuffer, "IDCONS=" + dwstr(nConsID))
		aAdd(aBuffer, "DW_OPENDRILL=" + Upper(aPropsY[DDNOVAJAN]))
		aAdd(aBuffer, "RANKING=" + "0")
		aAdd(aBuffer, "IDRNK=0")
		if lHasDrill .and. ( (!lPaginar .and. len(aValDrill)+1 < nQtdDimY) .or. (lPaginar .and. len(aValDrill) + len(aValY) < nQtdDimY))
			aAdd(aBuffer, "DRILL_ON=" + "TRUE")
			aAdd(aBuffer, "URLDRILLPARAMS=" + strTran(makeAction(AC_QUERY_GRAPH, { {"id", oConsulta:ID()}, {"tipo", "2"}, {"oper", "6"} , {"drilldown", "on"}, {"_forceReload", cRandom} }, .f.), "&amp;", "&") )
		else
			aAdd(aBuffer, "DRILL_ON=" + "FALSE")
		endif
		
		aEval(aValDrill, { |cDrill, nIndex| iif(empty(cDrill), aValDrill[nIndex] := VAZIO, NIL) })
		aAdd(aBuffer, "VAL_DRILL=" + DWConcatWSep(";", aValDrill))
		
		aAdd(aBuffer, "CORGRAF=" + aProps[CORGRAF])
		aAdd(aBuffer, "CORFUNDO=" + aProps[CORFUNDO])
		aAdd(aBuffer, "VERVALOR=" + aProps[VERVALOR])
		aAdd(aBuffer, "XYINTENS=" + aProps[XYINTENS])
		aAdd(aBuffer, "XYSOBRE=" + aProps[XYSOBRE])
		aAdd(aBuffer, "IMAGEM=" + aProps[IMAGEM])
		
		aAdd(aBuffer, "YBASE=" + aPropsY[YBASE])
		aAdd(aBuffer, "YMETA=" + aPropsY[YMETA])
		aAdd(aBuffer, "YTITMARCA=" + aPropsY[YTITMARCA])
		
		aAdd(aBuffer, "VERZONA=" + aProps[VERZONA])
		
		aAdd(aBuffer, "PZTIT=" + aProps[PZTIT])
		aAdd(aBuffer, "PZVLINI=" + aProps[PZVLINI])
		aAdd(aBuffer, "PZVLFIM=" + aProps[PZVLFIM])
		aAdd(aBuffer, "PZCOR=" + aProps[PZCOR])
		
		aAdd(aBuffer, "SZTIT=" + aProps[SZTIT])
		aAdd(aBuffer, "SZVLINI=" + aProps[SZVLINI])
		aAdd(aBuffer, "SZVLFIM=" + aProps[SZVLFIM])
		aAdd(aBuffer, "SZCOR=" + aProps[SZCOR])
		
		aAdd(aBuffer, "TZTIT=" + aProps[TZTIT])
		aAdd(aBuffer, "TZVLINI=" + aProps[TZVLINI])
		aAdd(aBuffer, "TZVLFIM=" + aProps[TZVLFIM])
		aAdd(aBuffer, "TZCOR=" + aProps[TZCOR])
		
		aAdd(aBuffer, "TIP_CHART=" + dwstr(nTipoGraf))
		
		aAdd(aBuffer, "QTD_SERIE=" + DWStr(nQtdSerie))
		
		aAdd(aBuffer, "QTD_PAG=" + DwStr(PAGE_SIZE))
		
		aAdd(aBuffer, "PRIMSERIE=" + cPrimSerie)
		aAdd(aBuffer, "ULTSERIE=" + cUltSerie)
		aAdd(aBuffer, "YESCAUTO=" + aPropsY[YESCAUTO])
		aAdd(aBuffer, "YESCLOG=" + aPropsY[YESCLOG])
		
		if Alltrim(Upper(aPropsY[YESCAUTO])) == "TRUE" .or. Alltrim(Upper(aPropsY[YESCLOG])) == "TRUE"
			//aumenta 10% só para deixar um espaço em branco
			nMaior += nMaior * 0.1
			if nMenor < 0 // só deixa espaço caso esteja abaixo da linha de 0
				nMenor += nMenor * 0.1
			endif
			
			cval_max := dwstr(nMaior)
			cval_min := dwstr(nMenor)
			cval_interv := dwstr(nInterval)
		else
			cval_max := aPropsY[YVLMAX]
			cval_min := aPropsY[YVLMIN]
			cval_interv := aPropsY[YINC]
		endif
		
		aAdd(aBuffer, "VAL_MAX=" + cval_max)
		aAdd(aBuffer, "VAL_MIN=" + cval_min)
		aAdd(aBuffer, "VAL_INTERV=" + cval_interv)
		
		aAdd(aBuffer, "MAIORDESC=" + dwstr(nMaiDesc))
		aAdd(aBuffer, "DW_VALOR=1")
		aAdd(aBuffer, "QTD_PROC=" + DWStr(nQtdProc))
		aAdd(aBuffer, "QTD_ITENS=" + DWStr(len(aDesc)))
		aAdd(aBuffer, "QTD_IND=" + isNull(cInd, ""))
		
		aAdd(aBuffer, "URLPAGEPARAMS=" + strTran(makeAction(AC_QUERY_GRAPH, { {"drilldown", "off"}, {"paginar", "on"}, {"valuex", ""}, {"type", "2"}, {"baserow", DWStr(nQtdProc)}, {"PaginTrack", DwConcatWSep("_", aPaginTrack)}, {"QtdItensPrev", DwStr(nQtdPagina)}, {"id", oConsulta:ID()}, {"tipo", "2"}, {"oper", "6"}, {"valmax", cval_max}, {"valmin", cval_min}, {"valinterv", cval_interv}, {"loadpgdw", HttpGet->loadpgdw}, {"_forceReload", cRandom} }, .f.), "&amp;", "&") )
		aAdd(aBuffer, "PARAMPREVPAGE=" + "&naveg=prior")
		aAdd(aBuffer, "PARAMNEXTPAGE=" + "&naveg=next")
		aAdd(aBuffer, "PARAMVALUEY=" + "&valuey=")
		aAdd(aBuffer, "PARAMDRILL=" + "&val_drill=")
		
		aAdd(aBuffer, "IDCONS=" + dwstr(oConsulta:Id()))
		aAdd(aBuffer, "CHARTEXP=" + "chart_" + oConsulta:Cube():Name() + "_" + oConsulta:AccessType() + "_" + oConsulta:Name() + "_" + dwstr(iif(valType(oUserDW) == "O", oUserDW:UserID(), "")))
		
		lLegenda := (Upper(aProps[VERLEG])=="TRUE")
		
		if nTipoGraf == CHART_PIE
			nAtrTamChart := 370
			if len(aInd) == 1
				nIndTamChart := 170
			else
				nIndTamChart := 160
			endif
			
			nLegTam := 0
			if lLegenda
				nLegTam := nMaiDesc * int(dwval(aProps[XYTAM]))
			endif
			
			nLMargem := nRMargem := 0
			nRaio := 115
			nTamSerie := (nMaiDesc + len(dwstr(nMaior))) * 10 + 100
			nAltTam := nTMargem + nIndTamChart + nRaio + 80 + nBMargem
			nLargTam := nAtrTamChart + nRaio + nTamSerie + iif(lLegenda, nLegTam, 10)
			
			if nLargTam < 880
				nLargTam := 880
			endif
		else
			if lBarra
				nIndTamChart := (nQtdEixo * len(aInd)) * 15
				nAtrTamChart := 530
				if nIndTamChart < 370
					nIndTamChart := 370
					nAtrTamChart := 520
				endif
				nRMargem := 0
				
				nTam := int(DwVal(aProps[XYTAM]) / SPACE_PER_CHAR)
				if (nGreatestDesc * (SPACE_PER_CHAR + nTam)) > nLMargem
					nLMargem := nGreatestDesc * (SPACE_PER_CHAR + nTam)
				else
					if !lDrilldown
						nAtrTamChart := 740
					else
						nAtrTamChart := 580
					endif
				endif
				
				nLargTam := nLMargem + nAtrTamChart
				if nLargTam < 870
					nLargTam := 870
				endif
				
				nLegTam := 0
				if lLegenda
					nLegTam := nMaiLeg * int(dwval(aProps[XYTAM])-4)
				endif
				
				nAtrTamChart := nAtrTamChart - nLMargem - nRMargem
				if (nAtrTamChart + nLegTam) > (nLargTam-150)
					nAtrTamChart -= nLegTam
				endif
			else
				nAtrTamChart := (nMaiDesc * nQtdEixo ) * int(dwval(aProps[SERIETAM]))
				nIndTamChart := 350
				if nAtrTamChart < 520
					nAtrTamChart := 520
					nIndTamChart := 370
				endif
				
				nLargTam := nLMargem + nAtrTamChart + iif(lLegenda, 50 + nLegTam, 10) + nRMargem
				if nLargTam < 890
					nLargTam := 890
				endif
			endif
			nAltTam := nTMargem + nIndTamChart + nBMargem
		endif
		
		if nAltTam < 440
			nAltTam := 440
		endif
		
		//TITULO
		aAdd(aBuffer, "TITLE="+oConsulta:Desc())
		aAdd(aBuffer, "TITLE_COLOR=" + cCorPreta)
		aAdd(aBuffer, "TITLE_SIZE=" + "12")
		aAdd(aBuffer, "TITLE_FONT=" + "Arial")
		
		if !empty(cTitulo)
			// calcula a quantidade de caracteres disponível para o título
			nTitleWidth := int(nLargTam / 9)
			aResult := DwToken(cTitulo, " ", .F., .F.)
			cAux := ""
			cTitulo := ""
			for nInd := 1 to len(aResult)
				if (len(cAux) + len(aResult[nInd])) > nTitleWidth
					cTitulo += cAux
					cTitulo += "<*br*>"
					cAux := ""
				endif
				cAux += DwStr(aResult[nInd])
			next
			if !empty(cAux)
				cTitulo += cAux
			endif
		endif
		aAdd(aBuffer, "TITLECHART=" + cTitulo)
		
		//LEGENDA
		aAdd(aBuffer, "VERLEG=" + aProps[VERLEG])
		aAdd(aBuffer, "LEGFONTE=" + aProps[XYFONTE])
		aAdd(aBuffer, "LEGTAM=" + DWStr(DWVal(aProps[XYTAM])-2))
		aAdd(aBuffer, "LEGCOR=" + aProps[XYCOR])
		if isNull(HttpGet->loadpgdw, CHKBOX_OFF) == CHKBOX_ON
			nIndTamChart := 85
			nAltTam := 151
			nLargTam := nLargTam - 135
			nAtrTamChart := nAtrTamChart - 135
			
			if nTipoGraf == CHART_BAR .or. nTipoGraf == CHART_BAR3D
				nLargTam := nLargTam + 8
				if nQtdSerie > nQtdProc
					nLargTam := nLargTam - 10
					nAltTam := nIndTamChart := (nQtdEixo * len(aInd)) * 15
					nAltTam := nAltTam + nBMargem
				endif
			elseif (nTipoGraf == CHART_COLUMN .or. nTipoGraf == CHART_COLUMN3D ;
				.or. nTipoGraf == CHART_LINE .or. nTipoGraf == CHART_LINE3D) ;
				.and. ((nQtdSerie-len(aDesc)) > 0 .OR. nQtdSerie > nQtdProc)
				nIndTamChart := nIndTamChart - 20
				if nAltTam > 151
					nAltTam := 151
				endif
				nAltTam := nAltTam - 20
				nLargTam := nLargTam + 8
				nAtrTamChart := nAtrTamChart + 8
			elseif nTipoGraf == CHART_PIE
				nTMargem := 0
				nRaio := int(nRaio / 2.5)
				nAltTam := nTMargem + nIndTamChart + nRaio + nBMargem + iif(nQtdProc > 10, ((nQtdProc - 10)*2), 0)
				nLargTam := nLargTam - 17
			endif
		endif
		
		//MARGEM
		aAdd(aBuffer, "LEFT_MARGIN=" + DWStr(nLMargem))
		aAdd(aBuffer, "RIGHT_MARGIN=" + DWStr(nRMargem))
		aAdd(aBuffer, "TOP_MARGIN=" + DWStr(nTMargem))
		aAdd(aBuffer, "BOTTOM_MARGIN=" + DWStr(nBMargem))
		aAdd(aBuffer, "LEGENDTAM=" + DWStr(nLegTam))
		
		aAdd(aBuffer, "CHART_WIDTH=" + dwstr(nAtrTamChart))
		aAdd(aBuffer, "CHART_HEIGHT=" + dwstr(nIndTamChart))
		aAdd(aBuffer, "WIDTH=" + DWStr(nLargTam))
		aAdd(aBuffer, "HEIGHT=" + DWStr(nAltTam))
		
		if nTipoGraf <> CHART_PIE
			aAdd(aBuffer, "AXIS_LABELS=" + DWConcatWSep("|",aDesc))
			aAdd(aBuffer, "LABEL=" + cLabel)
			aAdd(aBuffer, "INDLABEL=" + aPropsY[YTITULO])
			aAdd(aBuffer, "XYFONTE=" + aProps[XYFONTE])
			aAdd(aBuffer, "XYTAM=" + aProps[XYTAM])
			aAdd(aBuffer, "XYCOR=" + aProps[XYCOR])
			
			aAdd(aBuffer, "XAXIS_FONT=" + cFontGraph)
			aAdd(aBuffer, "XAXIS_FONT_COLOR=" + cCorPreta)
			aAdd(aBuffer, "XLABEL_COLOR=" + iif(!lBarra, cCorEixo, "0"))
			
			aAdd(aBuffer, "YAXIS_FONT=" + cFontGraph)
			aAdd(aBuffer, "YAXIS_FONT_COLOR=" + cCorPreta)
			aAdd(aBuffer, "YLABEL_COLOR=" + iif(lBarra, cCorEixo, "0"))
			
			aAdd(aBuffer, "Y2AXIS_FONT=" + cFontGraph)
			aAdd(aBuffer, "Y2AXIS_FONT_COLOR=" + cCorPreta)
			aAdd(aBuffer, "Y2AXIS_LABELS=" + cFontGraph)
			aAdd(aBuffer, "Y2LABEL=" + iif(lBarra, "", aPropsY[Y2TITULO]))
			aAdd(aBuffer, "Y2LABEL_COLOR=" + cCorPreta)
			aAdd(aBuffer, "Y2LABEL_FONT=" + cFontGraph)
			
			if nTipoGraf == CHART_COLUMN .or. nTipoGraf == CHART_COLUMN3D
				aAdd(aBuffer, "BARWIDTH=60")
			endif
			
		else
			
			aAdd(aBuffer, "CHART_RAIO=" + dwstr(nRaio))
			aAdd(aBuffer, "CHART_SERIE=" + dwstr(nTamSerie))
			aAdd(aBuffer, "MSGPIZZA=" + STR0008) //###"Existem mais dados a serem exibidos, favor utilizar outro tipo de gráfico!"
			
			aAdd(aBuffer, "AXIS_LABELS=" + DWConcatWSep("|",aDesc))
			aAdd(aBuffer, "LABEL=" + cLabel)
			aAdd(aBuffer, "TXTATRIB=" + "Atributo(s): ")
			aAdd(aBuffer, "TXTINDIC=" + "Indicador: ")
			
		endif
		
	else
		
		aAdd(aBuffer, "DW_VALOR=0")
		aAdd(aBuffer, "CHART_WIDTH=300")
		aAdd(aBuffer, "CHART_HEIGHT=500")
		aAdd(aBuffer, "DW_OPENDRILL=" + Upper(aPropsY[DDNOVAJAN]))
	endif
	
	aAdd(aBuffer, "FIMSTRDW=OK")
	aAdd(aBuffer, " ")
	
	__Response := DWConcatWSep(CRLF, aBuffer)
	
	if DWIsDebug()
		Conout(__Response)
	endif
	
	return __Response
endif

static function aEscala(nMenor, nMaior)
	local aRet :={}
	local nTotal := 0
	local nInterv := 0
	local nTam := 0
	local cValor := ""
	local nNewInterv := 0
	local nNewMenor := 0
	local nInc := 0
	local nValor := 0
	local nFator := 1.1
	
	if nMaior > 0 .and. nMenor > 0
		nMenor := 0
		nMaior := int(nMaior * nFator)
	elseif nMaior > 0 .and. nMenor < 0
		nMaior := int(nMaior * nFator)
		nMenor := int(nMenor * nFator)
	elseif nMaior < 0 .and. nMenor < 0
		nMaior := 0
		nMenor := int(nMenor * nFator)
	endif
	
	nTotal := nMaior - nMenor
	nInterv := int(nTotal / 10)
	
	nTam := 2
	nValor := 10
	nNewInterv := DWVal(cValor)
	
	while nNewInterv <= nInterv
		if nValor < 50 .and. nValor < (nMaior/2)
			nValor := nValor + 40
		elseif nValor > (nMaior/2)
			nValor /= 2
		else
			nValor := 10
			nTam := nTam + 1
		endif
		
		cValor := DWStr(nValor) + replicate("0",nTam-2)
		nNewInterv := DWVal(cValor)
	enddo
	
	if nMenor < 0 .and. (nNewInterv * -1) < nMenor
		nNewMenor := (nNewInterv * -1)
		nInc := 1
		while nNewMenor > nMenor
			nInc := nInc + 1
			nNewMenor := (nNewInterv * -1) * nInc
		enddo
		nInc := nInc + 1
		nNewMenor := (nNewInterv * -1) * nInc
		nMenor := nNewMenor
	endif
	
	aAdd(aRet, nMenor)
	aAdd(aRet, nNewInterv)
	aAdd(aRet, nMaior)

return aRet

function nTamDesc(nTam, cDesc, lMenor)
   local nRet := nTam
   if (lMenor .and. len(cDesc) < nTam) .or. (!lMenor .and. len(cDesc) > nTam)
      nRet := len(cDesc)
   endif
return nRet

function cAtribFormat(cValor, cTipo)
	local cRet := cValor
	if cTipo == "D" .and. len(cValor) == 8
		cRet := right(cValor,2) + "/" + substr(cValor,5,2) + "/" + left(cValor,4)
	elseif cTipo == "C"
		if len(trim(cValor)) == 0
			cValor := VAZIO
		endif
		cRet := cValor
	elseif cTipo == "N"
		cRet := DWStr(cValor)
	endif

return cRet

function cMascara(nTam, nDec)

return "{value|" + DwStr(nDec) + ".,}"

function makedata(aDTFilter)
	local cData := ""
	local nInd := 1
	local aItem := {}
	local cDia := "31"
	local cMes := "12"
	local cAno := "9999"
	
	for nInd := 1 to len(aDTFilter)
		aItem := aDTFilter[nInd]
		do case 
			case aItem[3] == DT_ANO
				cAno := aItem[1]
			case aItem[3] == DT_PERIODO				
			case aItem[3] == DT_ESTACAO
				if aItem[1] == 1
					cDia := "21"
					cMes := "2"
				elseif aItem[1] == 2
					cDia := "21"
					cMes := "5"
				elseif aItem[1] == 3
					cDia := "21"
					cMes := "8"
				else
					cDia := "31"
					cMes := "12"
				endif
			case aItem[3] == DT_SEMESTRE
				cMes := DWStr(DWVal(aItem[1]) * 6)
			case aItem[3] == DT_QUADMESTRE
				cMes := DWStr(DWVal(aItem[1]) * 4)
			case aItem[3] == DT_TRIMESTRE
				cMes := DWStr(DWVal(aItem[1]) * 3)
			case aItem[3] == DT_BIMESTRE
				cMes := DWStr(DWVal(aItem[1]) * 2)
			case aItem[3] == DT_MES
				cMes := DWStr(DWVal(aItem[1]))
			case aItem[3] == DT_QUINZENA
				if aItem[1] == "1"
					cDia := "15"
				endif
			case aItem[3] == DT_SEMANA
	   		case aItem[3] == DT_SEQSEMANA //Semana do ano. 
			case aItem[3] == DT_DIA
				cDia := aItem[1]
			case aItem[3] == DT_DOW
			case aItem[3] == DT_DOY		
    end case
	next

	if DWVal(cDia) < 10
		cDia := "0" + cDia
	endif

	if DWVal(cMes) < 10
		cMes := "0" + cMes
	endif
	
	cData := left(aDTFilter[1][2],1)+substr(aDTFilter[1][2],4,len(aDTFilter[1][2])-3) + " <= " + cAno+cMes+cDia

return cData

function setGraphYPropsDefault(aaPropsY)

	if len(aaPropsY) == 19 // valor para até o release 3
		aAdd(aaPropsY, "")
		aAdd(aaPropsY, "")
		aAdd(aaPropsY, "FALSE")
		aAdd(aaPropsY, "0")
	elseif len(aaPropsY) <> QTDPROPSY
		aaPropsY := {}
		aAdd(aaPropsY, "")
		aAdd(aaPropsY, "FALSE")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "FALSE")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "TRUE")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "FALSE")
		aAdd(aaPropsY, "")
		aAdd(aaPropsY, "FALSE")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "TRUE")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "FALSE")
		aAdd(aaPropsY, "0")
		aAdd(aaPropsY, "")
		aAdd(aaPropsY, "")
		aAdd(aaPropsY, "FALSE")
		aAdd(aaPropsY, "0")
	endif
   
return

function setGraphPropsDefault(aaProps)
	Local nInd
	
	for nInd := 1 to (QTDPROPS-len(aaProps))
		aAdd(aaProps, "")
	next
	
	if empty(aaProps[SERIEFONTE])
		aaProps[SERIEFONTE] := "Arial Black"
	endif
	if DWVal(aaProps[SERIETAM]) < 1
		aaProps[SERIETAM] := "10"
	endif
	if empty(aaProps[SERIECOR])
		aaProps[SERIECOR] := "-14606047"
	endif
	if empty(aaProps[XYFONTE])
		aaProps[XYFONTE] := "Arial Black"
	endif
	if DWVal(aaProps[XYTAM]) < 1
		aaProps[XYTAM] := "10"
	endif
	if empty(aaProps[XYCOR])
		aaProps[XYCOR] := "-14606047"
	endif
	if empty(aaProps[XYINTENS])
		aaProps[XYINTENS] := "0"
	endif
	if empty(aaProps[XYSOBRE])
		aaProps[XYSOBRE] := "0"
	endif
	if empty(aaProps[CORFUNDO])
		aaProps[CORFUNDO] := "0x22EEEEEE"
	endif
	if empty(aaProps[CORGRAF])
		aaProps[CORGRAF] := "0x22FFFFFF"
	endif
	if empty(aaProps[IMAGEM])
		aaProps[IMAGEM] := ""
	endif
	if empty(aaProps[VERVALOR])
		aaProps[VERVALOR] := ""
	endif
	if empty(aaProps[VERLEG])
		aaProps[VERLEG] := "TRUE"
	endif
	if empty(aaProps[VERZONA])
		aaProps[VERZONA] := "FALSE"
	endif
	if empty(aaProps[PZTIT])
		aaProps[PZTIT] := ""
	endif
	if empty(aaProps[PZVLINI])
		aaProps[PZVLINI] := "0"
	endif
	if empty(aaProps[PZVLFIM])
		aaProps[PZVLFIM] := "0"
	endif
	if empty(aaProps[PZCOR])
		aaProps[PZCOR] := "-50"
	endif
	if empty(aaProps[SZTIT])
		aaProps[SZTIT] := ""
	endif
	if empty(aaProps[SZVLINI])
		aaProps[SZVLINI] := "50"
	endif
	if empty(aaProps[SZVLFIM])
		aaProps[SZVLFIM] := "0"
	endif
	if empty(aaProps[SZCOR])
		aaProps[SZCOR] := "-50"
	endif
	if empty(aaProps[TZTIT])
		aaProps[TZTIT] := ""
	endif
	if empty(aaProps[TZVLINI])
		aaProps[TZVLINI] := "0"
	endif
	if empty(aaProps[TZVLFIM])
		aaProps[TZVLFIM] := "0"
	endif
	if empty(aaProps[TZCOR])
		aaProps[TZCOR] := "-50"
	endif
	if empty(aaProps[TZDECIMAL])
		aaProps[TZDECIMAL] := "0"
	endif
	if empty(aaProps[TZFORMIND])
		aaProps[TZFORMIND] := "-50"
	endif
	if empty(aaProps[TZFORMUNIC])
		aaProps[TZFORMUNIC] := "-50"
	endif

return

%>
