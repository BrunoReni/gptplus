<%
// ######################################################################################
// Projeto: DATA WAREHOUSE
// Modulo : Actions
// Fonte  : dwToolMeta - Seleção para geração de meta-dados e modelo gráfico (esquema/schema)
// ---------+-------------------+--------------------------------------------------------
// Data     | Autor             | Descricao
// ---------+-------------------+--------------------------------------------------------
// 01.06.01 | 0548-Alan Candido | Criação
// 01.11.05 |2481-Paulo R Vieira| Novo Layout Fase 3
// 22.11.07 | 0548-Alan Candido | BOPS 136453 - Ajuste na geração do meta-dados para uso pelo
//          |                   |   processo de migração de versão anteriores a R4
// 07.12.07 | 0548-Alan Candido | BOPS 137338 - Exportação do "dono" da consulta              
//          |                   |             - Correção no procedimento de exportação de 
//          |                   |   fontes de dados dos cubos
// 29.05.08 | 0548-Alan Candido | BOPS 146059
//          |                   | Exportação das propriedade "rankSubTotal" e "rankTotal" da
//          |                   | consulta
// 28.10.05 | 0548-Alan Candido | FNC 00000004148/2008 (8.11) 00000004172/2008 (9.12)
//          |                   | Ajuste na verificação da existência ou não da conexão
//          |                   | na lista de conexões a serem processadas
// 09.12.08 | 0548-Alan Candido | FNC 00000149278/811 (8.11) e 00000149278/912 (9.12)
//          |                   | Adequação de procedimentos para suportar ranking por
//          |                   | nivel de drill-down
// --------------------------------------------------------------------------------------

#include "dwincs.ch"
#include "dwToolMeta.ch"

// constantes de dimensionamento/posicionamento (em caso de alteração, favor revisar starSchema.js)
#define PAT_HEIGHT     22
#define PAT_WIDTH      155
#define PAD_TEXT_LEFT  5
#define PAD_TEXT_TOP   3

#define DIM_WIDTH      PAT_WIDTH
#define DIM_HEIGHT     PAT_HEIGHT

#define CUB_WIDTH      PAT_WIDTH
#define CUB_HEIGHT     PAT_HEIGHT

#define ATT_WIDTH      PAT_WIDTH - 10
#define ATT_HEIGHT     PAT_HEIGHT
#define ATT_MARGIN_BOTTOM  4

#define DSN_WIDTH      PAT_WIDTH
#define DSN_HEIGHT     PAT_HEIGHT
#define DSN_DESLOC     60
// fim (starSchema.js)

local lDimensao := HttpSession->Dimensions
local lCubo     := HttpSession->Cubes
local lConsulta := HttpSession->Queries
local lTemplate	:= iif (!empty(HttpPost->cbTemplate), CHKBOX_ON, CHKBOX_OFF) == CHKBOX_ON

if Httpget->Action == AC_SHOW_SCHEMA
	HttpGet->w := CHKBOX_ON
<%= showSchema(HttpGet->ObjType, dwVal(HttpGet->ID), dwVal(HttpGet->oper)) %>
	HttpGet->w := CHKBOX_OFF%>
	<%=tagJS()%>
	function u_setWindowPosSize()
	{
	  setWindowSize(650, 650);
	}
	</script>
<%else%>
	<%= buildTMetaInSteps(lDimensao, lCubo, lConsulta, lTemplate) %>
<%endif%>
<%
/*
--------------------------------------------------------------------------------------
Monta a página de ferramentas com passo a passo para apresentação e processamento dos dados
Args: alDimensao, booleano, contendo se deve ou não exibir as dimensões
		alCubo, booleano, contendo se deve ou não exibir os cubos
		alConsulta, booleano, contendo se deve ou não exibir as consultas
		alTemplate, booleano, contendo se deve ou não exibir o campo template no arquivo xml
--------------------------------------------------------------------------------------
*/
static function buildTMetaInSteps(alDimensao, alCubo, alConsulta, alTemplate)
	Local cFunctionReturn
 	Local nStep 	:= HttpPost->dw_step
 	Local lSaveXml := iif (HttpPost->cbFilename == CHKBOX_ON, lSaveXml := .T., lSaveXml := .F.)
   
	if DWVal(nStep) == 2
		cFunctionReturn := buildTMSecondStep(alDimensao, alCubo, alConsulta, alTemplate, lSaveXml)
	else
		cFunctionReturn := buildTMFirstStep(alDimensao, alCubo, alConsulta, alTemplate)
	endif
	
return cFunctionReturn

/*
--------------------------------------------------------------------------------------
Monta a página de ferramentas de meta-dados com o primeiro passo (apresentação de dados)
Args: alDimensao, booleano, contendo se deve ou não exibir as dimensões
		alCubo, booleano, contendo se deve ou não exibir os cubos
		alConsulta, booleano, contendo se deve ou não exibir as consultas
		alTemplate, booleano, contendo se deve ou não exibir o campo template no arquivo xml
--------------------------------------------------------------------------------------
*/
static function buildTMFirstStep(alDimensao, alCubo, alConsulta, alTemplate)
	Local aBuffer 		:= {}
	Local cTitle	    := STR0001 //"Geração de Meta-dados"
	Local oCubes
	Local oDimensao
	Local oQuery
	Local aButtons		:= {}
	Local cMsgNotFound 	:= STR0002 //"Não existem dados para serem visualizados"
	Local lShowNotFound := .T.
	Local aDispTitle, aDispData
	Local cHtml

	aDispTitle 	:= { STR0003 } //"Parametros opcionais"
	aDispData	:= { makeCheckField(NIL, "cbFilename", STR0004, .F.) } //"Salvar arquivo localmente"
	
	if alTemplate
		aAdd(aDispData, makeCheckField(NIL, "cbTemplate", STR0005, .F.)) //"Template"
	endif
    
 	makeText(aBuffer, displayData(aDispData, 1, aDispTitle))
   	
	// Apresenta Consultas
	if alConsulta
		aDispData	:= {}
		aDispTitle	:= {}

		oQuery := TQuery():New(DWMakename("TRA"))
		oQuery:FromList(TAB_CONSULTAS)
		oQuery:FieldList("ID, NOME, DESCRICAO")	
		oQuery:WhereClause("TIPO = '"+QUERY_PREDEF+"' and ID_DW=" + dwStr(oSigaDW:DWCurrID()))	
		oQuery:OrderBy("NOME")	

		oQuery:Open()    
		while !oQuery:Eof()
			lShowNotFound := .F.
			aAdd(aDispData, makeHCheckField(NIL, "cbP" + DwStr(oQuery:value("id")), oQuery:Value("nome")+'-'+oQuery:Value("descricao"), .F., .T.))
			oQuery:_Next()
		enddo
		oQuery:Close()
		
		// exibe os dados sobre consultas
		if len(aDispData) > 0
			aAdd(aDispTitle, makeHCheckField(NIL, "cbP0000", STR0006, .F., .F.)) //"Consultas Pre-definidas"
			makeText(aBuffer, displayData(aDispData, 3, aDispTitle))
		endif
		
		aDispData	:= {}
		aDispTitle	:= {}

		oQuery:FromList(TAB_CONSULTAS)
		oQuery:FieldList("ID, NOME, DESCRICAO")	
		oQuery:WhereClause("TIPO = '"+QUERY_USER+"' and ID_DW=" + dwStr(oSigaDW:DWCurrID()))	
		oQuery:OrderBy("NOME")	

		oQuery:Open()

		while !oQuery:Eof()
			lShowNotFound := .F.
			aAdd(aDispData, makeHCheckField(NIL, "cbU" + DwStr(oQuery:value("id")), oQuery:Value("nome")+"-"+oQuery:Value("descricao"), .F., .T.))
			oQuery:_Next()
		enddo
		oQuery:close()
		
		// exibe os dados sobre consultas
		if len(aDispData) > 0
			aAdd(aDispTitle, makeHCheckField(NIL, "cbU0000", STR0007, .F., .F.)) //"Consultas de Usuarios"
			makeText(aBuffer, displayData(aDispData, 3, aDispTitle))
		endif
	endif
	     
	// Apresenta Cubos
	if alCubo
		oCubes := oSigaDW:Cubes():CubeList()
		
		aDispData 	:= {}
		aDispTitle	:= {}
		__DWIDTemp := oSigaDW:DWCurrID()
		oCubes:Seek(2, { "" })
		while !oCubes:Eof()  .and. oCubes:value("id_dw") == oSigaDW:DWCurrID()
			lShowNotFound := .F.
			aAdd(aDispData, makeHCheckField(NIL, "cbC" + DwStr(oCubes:value("id")), oCubes:Value("descricao",.t.), .T.))
			oCubes:_Next()
		enddo
		__DWIDTemp := -1
		
		// exibe os dados sobre cubos
		if len(aDispData) > 0
			aAdd(aDispTitle, makeHCheckField(NIL, "cbC0000", STR0008, .F., .F.)) //"Cubos"
			makeText(aBuffer, displayData(aDispData, 3, aDispTitle))
		endif
	endif
	
	// Apresenta Dimensões
	if alDimensao
		aDispTitle 	:= {}
		aDispData	:= {}
		oDimensao := InitTable(TAB_DIMENSAO)
		
		__DWIDTemp := oSigaDW:DWCurrID()
		oDimensao:Seek(2, { "" })
		while !oDimensao:EoF() .and. oDimensao:value("id_dw") == oSigaDW:DWCurrID()
			lShowNotFound := .F.
			aAdd(aDispData, makeHCheckField(NIL, "cbD" + DwStr(oDimensao:value("id")), oDimensao:Value("descricao",.t.), .T.))
			oDimensao:_Next()
		enddo
		__DWIDTemp := -1
		
		// exibe os dados sobre dimensão
		if len(aDispData) > 0
			aAdd(aDispTitle, makeHCheckField(NIL, "cbD0000", STR0009, .F., .F.)) //"Dimensões"
			makeText(aBuffer, displayData(aDispData, 3, aDispTitle))
		endif
	endif
	
	makeHidden(aBuffer, "dw_step", "2")
	
 	// monta os botões necessários
 	makeButton(aButtons, BT_PROCESS)
   	   	
 	// verifica se existem dados para serem visualizados
	if lShowNotFound
		aBuffer := {}
		aButtons:= {}
		makeTitle(aBuffer, cMsgNotFound)
 	endif
   	
 	// realiza a construção do código html de retorno entre divs de 80% de largura
	cHtml := buildCheckList('frmTools', cTitle, AC_TOOLS_META, "", aButtons, aBuffer)
	
	// monta a função JavaScript para validar a seleção de algum checkbox e submeter o form em outra página
	aBuffer := {}
	aAdd(aBuffer, cHTML)
	aAdd(aBuffer, tagJS())
	aAdd(aBuffer, "function frmTools_valid(oSender)")
	aAdd(aBuffer, "{")
	if lShowNotFound
		aAdd(aBuffer, "defineMessage('" + cMsgNotFound + "');")
	else
		aAdd(aBuffer, 'var lCheckSelected = false;')
		aAdd(aBuffer, 'var oElements = getElement("frmTools").elements;')
		aAdd(aBuffer, 'var descartados = new Array("cbTemplate", "cbFilename");')
		aAdd(aBuffer, 'var lDescartar;')
		aAdd(aBuffer, 'var prefix;')
		aAdd(aBuffer, 'for (var nInd = 0; nInd < oElements.length; nInd++)')
		aAdd(aBuffer, '{')
		aAdd(aBuffer, '  if (oElements[nInd].type == "checkbox" && oElements[nInd].checked)')
		aAdd(aBuffer, '  {')
		aAdd(aBuffer, '    oElements[nInd].value = "'+CHKBOX_ON+'";')
    	// verifica a lista de dcomponentes checkboxes descartados, pois são opcionais 
		aAdd(aBuffer, '    lDescartar = false;')
		aAdd(aBuffer, '    for (var nInd2 = 0; !lDescartar && nInd2 < descartados.length; nInd2++)')
		aAdd(aBuffer, '    {')
		aAdd(aBuffer, '      if (oElements[nInd].name == descartados[nInd2])')
		aAdd(aBuffer, '        lDescartar = true;')
		aAdd(aBuffer, '    }')
		aAdd(aBuffer, '    if (!lDescartar)')
		aAdd(aBuffer, '      lCheckSelected = true;')
		aAdd(aBuffer, '    prefix = oElements[nInd].name.substring(0, 3);')
		aAdd(aBuffer, '    switch (prefix)')
		aAdd(aBuffer, '    {')
		aAdd(aBuffer, '      case "cbP":')
		aAdd(aBuffer, '        getElement("cbP0000").value = "'+CHKBOX_ON+'";')
		aAdd(aBuffer, '        break;')
		aAdd(aBuffer, '      case "cbU":')
		aAdd(aBuffer, '        getElement("cbU0000").value = "'+CHKBOX_ON+'";')
		aAdd(aBuffer, '        break;')
		aAdd(aBuffer, '      case "cbC":')
		aAdd(aBuffer, '        getElement("cbC0000").value = "'+CHKBOX_ON+'";')
		aAdd(aBuffer, '        break;')
		aAdd(aBuffer, '      case "cbD":')
		aAdd(aBuffer, '        getElement("cbD0000").value = "'+CHKBOX_ON+'";')
		aAdd(aBuffer, '        break;')
		aAdd(aBuffer, '    }')
		aAdd(aBuffer, '  }')
		aAdd(aBuffer, '}')
		aAdd(aBuffer, 'if (!lCheckSelected) {')
		aAdd(aBuffer, ' defineMessage("' + STR0010 + '");') //"Por favor, selecione pelo menos uma das opções de geração de meta-dados"
		aAdd(aBuffer, '} else {')
		//aAdd(aBuffer, '	doLoad("", "_DwPrint", window, "winDWPrint", ' + DwStr(TARGET_75_WINDOW) + ', ' + DwStr(TARGET_75_WINDOW) + ');')
		//aAdd(aBuffer, '	getElement("frmTools").target = "winDWPrint";')
		aAdd(aBuffer, '	getElement("frmTools").submit();')
		aAdd(aBuffer, '	enableAllButtons();')
		aAdd(aBuffer, '}')
	endif
	aAdd(aBuffer, 'return false;')
	aAdd(aBuffer, '}')
	aAdd(aBuffer, '</script>')
return dwConcatWSep(CRLF, aBuffer)

/*
--------------------------------------------------------------------------------------
Monta a página de ferramentas de meta-dados com o primeiro passo (apresentação de dados)
Args: alDimensao, booleano, contendo se deve ou não exibir as dimensões
		alCubo, booleano, contendo se deve ou não exibir os cubos
		alConsulta, booleano, contendo se deve ou não exibir as consultas
		alTemplate, booleano, contendo se deve ou não exibir o campo template no arquivo xml
		alSaveXml, booleano, contendo a opção de exibir botão para download do arquivo xml
--------------------------------------------------------------------------------------
*/
static function buildTMSecondStep(alDimensao, alCubo, alConsulta, alTemplate, alSaveXml)
	Local aBuffer 			:= {}
	Local oXmlMetaDados 	:= TDWXmlMetaDado():New(alTemplate)
	Local aButtons 			:= {}
	Local cXmlName, cXmlPath 
	
	if !DWWizardMode()
		makeTitle(aBuffer, STR0011 + oSigaDW:DWCurr()[2]) //"Datawarehouse "
		makeH2(aBuffer, STR0012 + dtoc(date()) + " " + time() + STR0013 + oUserDW:UserName() + ; //"Gerado em "###" por "
          "<br>" + DWBuild() + " &copy; " + link2Todos(.f.))
	else
		makeTitle(aBuffer, STR0014) //"Definição"
	endif
	
	// gera dimensões 
	if HttpIsConnected() .and. alDimensao
		if !DWWizardMode()
			buildDimension(aBuffer, oXmlMetaDados)
		endif
   endif
   
   // gera cubos
	if HttpIsConnected() .and. alCubo
		if !DWWizardMode()
			buildCube(aBuffer, oXmlMetaDados)
		endif
	endif
	
	// processa consultas
	if HttpIsConnected() .and. alConsulta
		buildQuery(aBuffer, QUERY_PREDEF, oXmlMetaDados)
		buildQuery(aBuffer, QUERY_USER, oXmlMetaDados)
	endif	
	
	if alSaveXml
		cXmlName 		:= DWMakeName("md") + ".DWM"
		cXmlPath 		:= fileFisicalDirectory()
		doSaveXML(oXmlMetaDados, DwMetaPath() + "\" + cXmlName, alTemplate)
		makeButton(aButtons, BT_DOWNLOAD, , makeAction(AC_DOWNLOAD, { {"fileName", cXmlName}, {"fileRelativePath", strTran(DwMetaPath(),"\","/") +"/"}, {"extensFile", "XML"}} ))
	endif  
	
	makeButton(aButtons, BT_PREVIOUS)
		
return buildPrint(aBuffer, aButtons)

/*
--------------------------------------------------------------------------------------
Salva o arquivo xml
Args: 	aoXmlMetaDados, objeto, arquivo xml a ser gravado
		acXmlFile, nome/caminho completo do arquivo
		alTemplate, booleano, contendo se deve ou não exibir o campo template no arquivo xml
--------------------------------------------------------------------------------------
*/
function doSaveXML(aoXmlMetaDados, acXmlFile, alTemplate)
	aoXmlMetaDados:SaveFile(acXmlFile)
	if alTemplate
		MSCOMPRESS(acXmlFile, DWChgFileExt(acXmlFile, ".DWZ"))
		fErase(acXmlFile)
		acXmlFile := DWChgFileExt(acXmlFile, ".DWZ")
	endif
return

/*
--------------------------------------------------------------------------------------
Monta a página de exibição de modelo gráfico (schema)
Args: alDimensao, booleano, contendo se deve ou não exibir as dimensões
		alCubo, booleano, contendo se deve ou não exibir os cubos
		alConsulta, booleano, contendo se deve ou não exibir as consultas
		alTemplate, booleano, contendo se deve ou não exibir o campo template no arquivo xml
		alSaveXml, booleano, contendo a opção de exibir botão para download do arquivo xml
	  anOper, númerico, contém o tipo de operação sendo realizada (wizard ou não)
--------------------------------------------------------------------------------------
*/
static function showSchema(acObjType, anID, anOper)
	local aBuffer := {}
	local aFields := {}
	local cTitle := "", aButtons := {}
	local cAction

	if acObjType == OBJ_DIMENSION
		cAction := AC_DIM_KEY
		buildDimension(aBuffer, nil, .f., .f., .t.)
		cTitle := " - " + STR0036 //###"Dimensão"
	else
		cAction := AC_DIM_CUB_RECMAN
		buildCube(aBuffer, nil, .f., .f., .t.)
		cTitle := " - " + STR0037 //###"Cubo"
	endif

	makeCustomField(aFields, "edSchema", dwConcatWSep(CRLF, aBuffer))
	
	if anOper == OP_REC_STEPS
		makeButton(aButtons, BT_PREVIOUS, , cAction, , {{"oper", anOper}})
		makeButton(aButtons, BT_CLOSE, STR0035) //###"finalizar"
	else
		makeButton(aButtons, BT_CLOSE)
	endif
	
return buildForm("frmSchema", STR0038 + cTitle, AC_NONE, , aButtons, aFields) //###"Modelo gráfico"

/*
--------------------------------------------------------------------------------------
Monta/exibe as dimensões escolhidas pelo usuário. A exibição é feita das seguintes seções da dimensão:
- Definição
- Atributos
- Fonte de Dados
- Roteiro
- Agendamento
Args: aaBuffer, array, array contendo a montagem dos camos a serem exibidas
		aoXmlMetaDados, objeto, contendo o objeto responsável pelo arquivo Xml
--------------------------------------------------------------------------------------
*/
static function buildDimension(aaBuffer, aoXmlMetaDados, alAll, alID, alOnlySchema)
	Local oDimensao 	:= InitTable(TAB_DIMENSAO)
	Local oDimFields 	:= InitTable(TAB_DIM_FIELDS)
	Local oDSN       	:= InitTable(TAB_DSN)
	Local oConexao 		:= oSigaDW:Connections()
	Local oDSNConf   	:= InitTable(TAB_DSNCONF)
	Local oSXM       	:= InitTable(TAB_SXM)
	Local oField
	Local lCb01
	Local nIDSel := iif(DWWizardMode(), dwVal(HttpGet->id), 0)
	Local lDispDimTitle	:= .T.
	Local lDispTitle	:= .T.
	Local lDispTitle2	:= .T.
	Local nId, lExistServer, aTemp, cType
	local nYDSN := 0, nQtdeServer := 0
	local aSchema := {}, aAtts := {{}, {}}
  	local nIdDW := oSigaDW:DWCurrID()
  	
  	if nIdDW == -1
    	nIdDW := 0
  	endif
 	
	default alAll := .f.
	default alID := .t.
	default alOnlySchema := .f.
	
	__DWIDTemp := oSigaDW:DWCurrID()
	
	oDimensao:Seek(2, { "" })
	while !oDimensao:eof() .and. oDimensao:value("id_dw") == nIdDW
		nId := oDimensao:value("ID")
	  	
		if !DWWizardMode()
			lCb01 := isNull(&("HttpPost->cbD" + DwStr(nId)),"") == CHKBOX_ON
	   	else
	   		lCb01 := nIDSel == nId
	   	endif
	   	
		if lCb01 .or. alAll
			conout("... " + STR0040 + " " + oDimensao:value("nome")) //###"metadados dimensao"
			if !alOnlySchema
				if lDispDimTitle
					makeH1(aaBuffer, STR0009) //"DIMENSÕES"
					lDispDimTitle := .F.
				endif
				
				// definição
				makeH2(aaBuffer, oDimensao:Value("nome",.t.) + "-" + oDimensao:Value("descricao", .t.))
				
				// exibe a definição da dimensão na tela
				makeSubTitle(aaBuffer, STR0014) //"Definição"
				makeText(aaBuffer, displayData(oDimensao:Record(6, { "id*", "F_l_a_g_w", "docto" })))
			endif
						
			// define as propriedades da dimensão no objeto de xml
			if valType(aoXmlMetaDados) == "O"
				if alID
					aEval(oDimensao:Record(7, { "id", "ID_DW", "docto", "id_docto" }), { |aElem| iif(!empty(aElem[2]), aoXmlMetaDados:addDimProperty(aElem[1], aElem[2]),nil) })
				else
					aEval(oDimensao:Record(7, { "id*", "docto"}), { |aElem| iif(!empty(aElem[2]), aoXmlMetaDados:addDimProperty(aElem[1], aElem[2]),nil) })
				endif
				aoXmlMetaDados:addDimProperty("tableid", oDimensao:value("id"))
				aoXmlMetaDados:addDimProperty("dwprefixo", __DWPrefixo)
			endif
						
			// estrutura de campos
			lDispTitle := .T.
			oDimFields:Seek(2, { nId })
			while !oDimFields:eof() .and. oDimFields:value("id_dim") == nId
				if !alOnlySchema
					if lDispTitle
						makeSubTitle(aaBuffer, STR0015) //"Atributos"
						lDispTitle := .F.
					endif
				
					// exibe os atributos da dimensão na tela
					makeText(aaBuffer, displayData(oDimFields:Record(6, { "id*", "indexar", "ID_DW" } )))
				endif
								
				// define os atributos da dimensão no objeto de xml
				if valType(aoXmlMetaDados) == "O"
					aTemp := {}
					if alID
						aEval(oDimFields:Record(7, { "id*", "ID_DW" }), { |aElem| iif(.t. .or. !empty(aElem[2]), aAdd(aTemp, {aElem[1], aElem[2]}), nil) } )
					else
						aEval(oDimFields:Record(7, { }), { |aElem| iif(.t. .or. !empty(aElem[2]), aAdd(aTemp, {aElem[1], aElem[2]}), nil) } )
					endif
					aoXmlMetaDados:addDimAttribute(aTemp)
				endif
             
				if oDimFields:value("keyseq") <> 0
					aAdd(aAtts[1], { oDimFields:value("nome"), oDimFields:value("keyseq") })
				else
					aAdd(aAtts[2], oDimFields:value("nome"))
				endif
				
				oDimFields:_Next()
			enddo
			
			// Fonte de dados
			lDispTitle := .T.
			oDSN:Seek(2, { OBJ_DIMENSION, nId } )
			while !oDSN:eof() .and. oDSN:value("tipo") == OBJ_DIMENSION .and. oDSN:value("id_table") == nId
				if !alOnlySchema
					if lDispTitle
						makeSubTitle(aaBuffer, STR0016) //"Fonte de dados"
						lDispTitle := .F.
					endif
				
					// exibe os datasources da dimensão na tela
					makeText(aaBuffer, displayData(oDSN:Record(6, { "id*", "tipo", "fullsql" } )))
				endif
								
				// define o datasource da dimensão no objeto de xml
				if valType(aoXmlMetaDados) == "O"
					aTemp := {}
					if alID
						aEval(oDSN:Record(7, { "id*" }), { |aElem| iif(.t. .or. !empty(aElem[2]), aAdd(aTemp, {aElem[1], aElem[2]}), nil) } )
					else
						aEval(oDSN:Record(7, { }), { |aElem| iif(.t. .or. !empty(aElem[2]), aAdd(aTemp, {aElem[1], aElem[2]}), nil) } )				
					endif					
					aAdd(aTemp, {"tipo_conn", oDSN:value("tipo_conn")})
					aAdd(aTemp, {"connector", oDSN:value("connector")})
					aoXmlMetaDados:addDimDataSource(aTemp)
				
					// Conector / Server
					oConexao:Seek(1, { oDSN:value("id_connect") })
					lExistServer := aoXmlMetaDados:verifyServers( { "nome", "tipo" }, { oConexao:value("nome", .t.), oConexao:value("tipo", .t.) }, 1)
					if !lExistServer
						aTemp := {}
						if alID
							aEval(oConexao:Record(7, { "id" }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
						else
							aEval(oConexao:Record(7, { }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
						endif
						aoXmlMetaDados:addServer(aTemp)
					endif
				
					// define os atributos do tipo MultiLineText do datasource da dimensão
					cType := aoXmlMetaDados:getTypeMultiLineText()
					aoXmlMetaDados:addDimGenericAttrDS(cType, {"sql", oDSN:value("sql",.t.)})
					aoXmlMetaDados:addDimGenericAttrDS(cType, {"sqlstruc", oDSN:value("sqlstruc",.t.)})
					aoXmlMetaDados:addDimGenericAttrDS(cType, {"filter", oDSN:value("filter",.t.)})
					aoXmlMetaDados:addDimGenericAttrDS(cType, {"beforeExec", oDSN:value("beforeExec",.t.)})
					aoXmlMetaDados:addDimGenericAttrDS(cType, {"afterExec", oDSN:value("afterExec",.t.)})
					aoXmlMetaDados:addDimGenericAttrDS(cType, {"forZap", oDSN:value("forZap",.t.)})
					aoXmlMetaDados:addDimGenericAttrDS(cType, {"valida", oDSN:value("valida",.t.)})
  			endif

				if alOnlySchema .or. oDimensao:value("id_docto") <> 0               
					aAdd(aSchema, drawServer(oDSN, 250, nYDSN, OBJ_ID(OBJ_DIMENSION, oDimensao:value("id"))))
					nYDSN += DSN_DESLOC
				endif
		         
				// Roteiros
				lDispTitle2 := .T.
				oDSNConf:Seek(2, { oDSN:value("id") } )
				while !oDSNConf:eof() .and. oDSNConf:value("id_dsn") == oDSN:value("id")
					if !alOnlySchema
						if !empty(oDSNConf:value("cpoorig",.t.)) .or. !empty(delAspas(oDSNConf:value("expressao",.t.)))
							if lDispTitle2
								makeSubTitle(aaBuffer, STR0017) //"Roteiro"
								lDispTitle2 := .F.
							endif
						
							// exibe o roteiro/scripts na tela
							aAux := oDSNConf:Record(6, { "id*" })
							aSize(aAux, len(aAux) + 1)
							aIns(aAux, 1)
							aAux[1] := { STR0018, oDimFields:value("nome",.t.)} //"campo"
							makeText(aaBuffer, displayData(aAux))
						
							// define os atributos do tipo Script do datasource da dimensão no objeto xml
							if valType(aoXmlMetaDados) == "O"
								oDimFields:Seek(1, { oDSNConf:value("id_field") })
								aTemp := {}
								aAdd(aTemp, {"field", oDimFields:value("nome",.t.)})
								aAdd(aTemp, {"cpoorig", oDSNConf:value("cpoorig",.t.)})
								aAdd(aTemp, {aoXmlMetaDados:getTypeValida(), oDSNConf:value("valida",.t.)})
								aAdd(aTemp, {aoXmlMetaDados:getTypeEx(), delAspas(oDSNConf:value("expressao",.t.))})
							
								aoXmlMetaDados:addDimGenericAttrDS(aoXmlMetaDados:getTypeScript(), aTemp)
							endif
						endif
			        endif
          
					oDSNConf:_Next()
				end
								
				// Agendamento
				lDispTitle2 := .T.
				oSXM:Seek(2, { 0, oDSN:value("id") })
				while !oSXM:eof() .and. oSXM:value("id_dsn") == oDSN:value("id")
					if !alOnlySchema
						if lDispTitle2
							makeText(aaBuffer, STR0019) //"Agendamento"
							lDispTitle2 := .F.
						endif
					
						// exibe o Agendamento/Scheduler do datasource da dimensão na tela
						makeText(aaBuffer, displayData(oSXM:Record(6, { "id*", "agtipo", "xm_semana", "xm_mensal", "xm_proxexec"} )))
					
						// define os atributos do tipo Agendamento/Scheduler do datasource da dimensão no objeto xml
						if valType(aoXmlMetaDados) == "O"
							aTemp := {}
							if alID
								aEval(oSXM:Record(7, { "id*" }), { |aElem| iif(.t. .or. !empty(aElem[2]), aAdd(aTemp, {aElem[1], aElem[2]}), nil)})
							else
								aEval(oSXM:Record(7, { "id*" }), { |aElem| iif(.t. .or. !empty(aElem[2]), aAdd(aTemp, {aElem[1], aElem[2]}), nil)})
							endif
							aoXmlMetaDados:addDimGenericAttrDS(aoXmlMetaDados:getTypeScheduler(), aTemp)
						endif
					endif
										
					oSXM:_Next()
				enddo
				
				oDSN:_Next()
			enddo			
			
			if valType(aoXmlMetaDados) == "O"
				aoXmlMetaDados:addDimension()
			endif
         
			if alOnlySchema .or. oDimensao:value("id_docto") <> 0
				aAdd(aSchema, drawDim(oDimensao, aAtts[1], aAtts[2]))
				if alOnlySchema
					aAdd(aaBuffer, prepStx(OBJ_DIMENSION, oDimensao:value("id"), "", aSchema))
				else
					makeCustomField(aaBuffer, '', prepStx(OBJ_DIMENSION, oDimensao:value("id"), oDimensao:value("docto"), aSchema))
				endif
			endif

		endif			

		if !alOnlySchema
			sendBuffer(aaBuffer)
  	endif
  	
 		oDimensao:_Next()
		
	enddo
	__DWIDTemp := -1
	
return

/*
--------------------------------------------------------------------------------------
Monta/exibe os cubos escolhidas pelo usuário.
Args: aaBuffer, array, array contendo a montagem dos camos a serem exibidas
		aoXmlMetaDados, objeto, contendo o objeto responsável pelo arquivo Xml
--------------------------------------------------------------------------------------
*/
static function buildCube(aaBuffer, aoXmlMetaDados, alAll, alID, alOnlySchema)
	Local oTable, oCubo, oField, oDS, oRot, oXMLAtt, lCb01, oAux
	Local oCalc 		:= InitTable(TAB_FACTVIRTUAL)
	Local oCubes 		:= oSigaDW:Cubes():CubeList()
	Local oFactFields	:= InitTable(TAB_FACTFIELDS)
	Local oDSN       	:= InitTable(TAB_DSN)
	Local oConexao 	:= oSigaDW:Connections()
	Local oDSNConf   	:= InitTable(TAB_DSNCONF)
	Local oSXM       	:= InitTable(TAB_SXM)
	Local lDispCubTitle	:= .T.
	Local lDispTitle	:= .T.
	Local lDispTitle2	:= .T.
	Local aTemp
	Local cType
	local aSchema := {}, aDims := {}, aInds := {{}, {}}
	local nYDSN := 0, nYDim := 0
	local nInd
	local nIDSel := iif(DWWizardMode(), dwVal(HttpGet->id), 0)
	local nIdDW := oSigaDW:DWCurrID()
	
	if nIdDW == -1
		nIdDW := 0
	endif
	
	default alAll := .f.
	default alID := .t.
	default alOnlySchema := .f.
	
	__DWIDTemp := oSigaDW:DWCurrID()
	oCubes:Seek(2, { "" })
	while !oCubes:Eof() .and. oCubes:value("id_dw") == nIdDW
		if !DWWizardMode()
			lCb01 := isNull(&("HttpPost->cbC" + DwStr(oCubes:value("id"))),"") == CHKBOX_ON
		else
			lCb01 := nIDSel == oCubes:value("id")
		endif
		
		if lCb01 .or. alAll
			conout("... " + STR0041 + " " + oCubes:value("nome")) //###"metadados cubo"
			if !alOnlySchema
				if lDispCubTitle
					makeH1(aaBuffer, STR0008) //"CUBOS"
					lDispCubTitle := .F.
				endif
				
				// definição
				makeH2(aaBuffer, oCubes:Value("nome",.t.))
				
				// exibe a definição do cubo na tela
				makeSubTitle(aaBuffer, STR0014) //"Definição"
				makeText(aaBuffer, displayData(oCubes:Record(6, { "id", "ID_DW" })))
			endif
			
			// define a lista de propriedades para este atributo no objeto xml
			if valType(aoXmlMetaDados) == "O"
				if alID
					aEval(oCubes:Record(7, { "id", "ID_DW" }), { |x| iif(.t. .or. !empty(x[2]), aoXmlMetaDados:addCubeProperty(x[1], x[2]),nil) })
				else
					aEval(oCubes:Record(7, { "id", "ID_DW" }), { |x| iif(.t. .or. !empty(x[2]), aoXmlMetaDados:addCubeProperty(x[1], x[2]),nil) })
				endif
				aoXmlMetaDados:addCubeProperty("tableid", oCubes:value("id"))
				aoXmlMetaDados:addCubeProperty("dwprefixo", __DWPrefixo)
			endif
			
			// estrutura de campos
			lDispTitle := .T.
			oFactFields:Seek(2, { oCubes:value("id") })
			while !oFactFields:eof() .and. oFactFields:value("id_cubes") == oCubes:value("id")
				if !alOnlySchema
					if lDispTitle
						makeSubTitle(aaBuffer, STR0015) //"Atributos"
						lDispTitle := .F.
					endif
					
					// exibe os atributos do cubo na tela
					makeText(aaBuffer, displayData(oFactFields:Record(6, { "id*", "dimensao", "keyseq", "ID_DW" } )))
				endif
				
				// define as propriedades desse atributo no objeto xml
				if valType(aoXmlMetaDados) == "O"
					aTemp := {}
					if alID
						aEval(oFactFields:Record(7, { "id*", "dimensao", "keyseq" }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
					else
						aEval(oFactFields:Record(7, { }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
					endif
					aAdd(aTemp, { "dimName", oFactFields:value("dimName") })
					aoXmlMetaDados:addCubeAttribute(aTemp)
				endif
				
				if oFactFields:value("dimensao") == 0
					aAdd(aInds[1], oFactFields:value("nome") )
				else
					nPos := ascan(aDims, { |x| x[1] == oFactFields:value("dimensao") })
					if nPos == 0
						aAdd(aDims, { oFactFields:value("dimensao"), oFactFields:value("dimName"), {} } )
						nPos := len(aDims)
					endif
					aAdd(aDims[nPos, 3], oFactFields:value("nome") )
				endif
				
				oFactFields:_Next()
			enddo
			
			for nInd := 1 to len(aDims)
				aAdd(aSchema, drawDim2(10, nYDim, aDims[nInd,1], aDims[nInd,2], aDims[nInd, 3], OBJ_ID(OBJ_CUBE, oCubes:value("id"))))
				nYDim += (66 + (len(aDims[nInd, 3]) * 22))
			next
			
			// estrutura de campos virtuais
			lDispTitle := .T.
			oCalc:Seek(2, { oCubes:value("id") })
			while !oCalc:eof() .and. oCalc:value("id_cubes") == oCubes:value("id")
				if !alOnlySchema
					if lDispTitle
						makeSubTitle(aaBuffer, STR0020) //"Atributos virtuais"
						lDispTitle := .F.
					endif
					
					// exibe os atributos virtuais do cubo na tela
					makeText(aaBuffer, displayData(oCalc:Record(6, { "id*" } )))
					
					// define as propriedades desse atributo virtual no objeto xml
					aTemp := {}
					if alID
						aEval(oCalc:Record(7, { "id*" }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
					else
						aEval(oCalc:Record(7, { }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
					endif
				endif
				
				// campos especial de subexpression
				if valType(aoXmlMetaDados) == "O"
					aAdd(aTemp, {aoXmlMetaDados:getTypeSubExpression(), oCalc:value("expressao",.t.), "isSQL", dwStr(oCalc:value("isSQL"))})
					
					// define o objeto xml
					aoXmlMetaDados:addCubeVirtualAttribute(aTemp)
				endif
				
				aAdd(aInds[2], oCalc:value("nome") )
				
				oCalc:_Next()
			enddo
			// Fonte de dados
			lDispTitle := .T.
			oDSN:Seek(2, { OBJ_CUBE, oCubes:value("id") } )
			while !oDSN:eof() .and. oDSN:value("tipo") == OBJ_CUBE .and. oDSN:value("id_table") == oCubes:value("id")
				if !alOnlySchema
					if lDispTitle
						makeSubTitle(aaBuffer, STR0016) //"Fonte de dados"
						lDispTitle := .F.
					endif
					
					// exibe o datasource do cubo na tela
					makeText(aaBuffer, displayData(oDSN:Record(6, { "id*", "tipo", "fullsql"} )))
				endif
				
				// define o datasource no objeto xml
				if valType(aoXmlMetaDados) == "O"
					aTemp := {}
					if alID
						aEval(oDSN:Record(7, { "id*" }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}), nil)})
					else
						aEval(oDSN:Record(7, {  }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}), nil)})
					endif
					aAdd(aTemp, {"tipo_conn", oDSN:value("tipo_conn")})
					aAdd(aTemp, {"connector", oDSN:value("connector")})
					aoXmlMetaDados:addCubeDataSource(aTemp)
					
					// Conector / Server
					oConexao:Seek(1, { oDSN:value("id_connect") })
					lExistServer := aoXmlMetaDados:verifyServers( { "nome", "tipo" }, { oConexao:value("nome", .t.), oConexao:value("tipo", .t.) }, 1)
					if !lExistServer
						aTemp := {}
						if alID
							aEval(oConexao:Record(7, { "id" }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
						else
							aEval(oConexao:Record(7, { }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
						endif
						aoXmlMetaDados:addServer(aTemp)
					endif
					
					// define os atributos do tipo MultiLineText do datasource da dimensão
					cType := aoXmlMetaDados:getTypeMultiLineText()
					aoXmlMetaDados:addCubeGenericAttrDS(cType, {"sql", oDSN:value("sql",.t.)})
					aoXmlMetaDados:addCubeGenericAttrDS(cType, {"sqlstruc", oDSN:value("sqlstruc",.t.)})
					aoXmlMetaDados:addCubeGenericAttrDS(cType, {"filter", oDSN:value("filter",.t.)})
					aoXmlMetaDados:addCubeGenericAttrDS(cType, {"beforeExec", oDSN:value("beforeExec",.t.)})
					aoXmlMetaDados:addCubeGenericAttrDS(cType, {"afterExec", oDSN:value("afterExec",.t.)})
					aoXmlMetaDados:addCubeGenericAttrDS(cType, {"forZap", oDSN:value("forZap",.t.)})
					aoXmlMetaDados:addCubeGenericAttrDS(cType, {"valida", oDSN:value("valida",.t.)})
				endif
				
				// Roteiros
				lDispTitle2 := .T.
				oDSNConf:Seek(2, { oDSN:value("id") } )
				while !oDSNConf:eof() .and. oDSNConf:value("id_dsn") == oDSN:value("id")
					if !alOnlySchema
						if lDispTitle2
							makeSubTitle(aaBuffer, STR0017) //"Roteiro"
							lDispTitle2 := .F.
						endif
						
						// exibe o roteiro/script do cubo na tela
						makeText(aaBuffer, displayData(oDSNConf:Record(6, { "id*"} )))
					endif
					
					// define o atributo script do datasource no objeto xml
					
					// campos especiais
					if valType(aoXmlMetaDados) == "O"
						aTemp := {}
						aAdd(aTemp, {"field", oDSNConf:value("field",.t.)})
						aAdd(aTemp, {"cpoorig", oDSNConf:value("cpoorig",.t.)})
						aAdd(aTemp, {aoXmlMetaDados:getTypeValida(), oDSNConf:value("valida",.t.)})
						aAdd(aTemp, {aoXmlMetaDados:getTypeEx(), delAspas(oDSNConf:value("expressao",.t.))})
						// define o objeto xml
						aoXmlMetaDados:addCubeGenericAttrDS(aoXmlMetaDados:getTypeScript(), aTemp)
					endif
					
					oDSNConf:_Next()
				end
				
				// Agendamento
				lDispTitle2 := .T.
				oSXM:Seek(2, { 0, oDSN:value("id") })
				while !oSXM:eof() .and. oSXM:value("id_dsn") == oDSN:value("id")
					if !alOnlySchema
						if lDispTitle2
							makeSubTitle(aaBuffer, STR0019) //"Agendamento"
							lDispTitle2 := .F.
						endif
						
						// exibe o Agendamento/Scheduler do datasource da dimensão na tela
						makeText(aaBuffer, displayData(oSXM:Record(6, { "id*", "agtipo", "xm_semana", "xm_mensal", "xm_proxexec"} )))
						
						// define os atributos do tipo Agendamento/Scheduler do datasource da dimensão no objeto xml
						if valType(aoXmlMetaDados) == "O"
							aTemp := {}
							if alID
								aEval(oSXM:Record(7, { "id*" }), { |aElem| iif(.t. .or. !empty(aElem[2]), aAdd(aTemp, {aElem[1], aElem[2]}), nil)})
							else
								aEval(oSXM:Record(7, { "id*" }), { |aElem| iif(.t. .or. !empty(aElem[2]), aAdd(aTemp, {aElem[1], aElem[2]}), nil)})
							endif
							aoXmlMetaDados:addCubeGenericAttrDS(aoXmlMetaDados:getTypeScheduler(), aTemp)
						endif
					endif
					
					oSXM:_Next()
				enddo
				
				if oCubes:value("id_docto") <> 0
					aAdd(aSchema, drawServer(oDSN, 450, nYDSN, OBJ_ID(OBJ_CUBE, oCubes:value("id"))))
					nYDSN += DSN_DESLOC
				endif
				
				oDSN:_Next()
			enddo
			
			if alOnlySchema .or. oCubes:value("id_docto") <> 0
				aAdd(aSchema, drawCube(oCubes, aInds[1], aInds[2]))
				if alOnlySchema
					aAdd(aaBuffer, prepStx(OBJ_CUBE, oCubes:value("id"), "", aSchema))
				else
					makeCustomField(aaBuffer, '', prepStx(OBJ_CUBE, oCubes:value("id"), oCubes:value("docto"), aSchema))
				endif
			endif
			
			// adiciona o cubo ao xml
			if valType(aoXmlMetaDados) == "O"
				aoXmlMetaDados:addCube()
			endif
		endif
		
		if !alOnlySchema
			sendBuffer(aaBuffer)
		endif
		
		oCubes:_Next()
	enddo
	__DWIDTemp := -1	

return

/*
--------------------------------------------------------------------------------------
Monta/exibe as consultas escolhidas pelo usuário.
Args: aaBuffer, array, array contendo a montagem dos camos a serem exibidas
		acQueryType, string, contendo o tipo de consulta (P=Pre-Definida ou U=Usuário)
		aoXmlMetaDados, objeto, contendo o objeto responsável pelo arquivo Xml
--------------------------------------------------------------------------------------
*/
static function buildQuery(aaBuffer, acQueryType, aoXmlMetaDados, alAll, alID)
	Local oWhere, xWhere, oWhereCond, xWhereCond
	Local oConsulta := InitTable(TAB_CONSULTAS)
	Local lCb01 
	Local cAux
	Local lDispTitle := .T.
  	local nIdDW := oSigaDW:DWCurrID()
  
  	if nIdDW == -1
    	nIdDW := 0
  	endif

	default alAll := .f.
	default alID := .t.
	
	__DWIDTemp := oSigaDW:DWCurrID()
	oConsulta:Seek(5, { acQueryType })
	while !oConsulta:Eof() .and. oConsulta:value("tipo") == acQueryType .and. oConsulta:value("id_dw") == nIdDW
		oConsulta:SavePos()
		if !DWWizardMode()
			cAux := acQueryType + DWStr(oConsulta:value("id"))
			lCb01 := isNull(&("HttpPost->cb" + cAux),"") == CHKBOX_ON
		else
		   lCb01 := nIDSel == oConsulta:value("id")
		endif
      
		if lCb01 .or. alAll
			conout("... " + STR0042 + " " + oConsulta:value("nome") + ' - Prop. ' + iif(isNull(oConsulta:value("login")), STR0043 /*Indefinido*/ , oConsulta:value("login"))) //###"metadados consulta"
			if lDispTitle
				makeH1(aaBuffer, STR0021 + iif (acQueryType == QUERY_PREDEF, STR0022, STR0023)) //"Consultas"###"Pré-Definidas"###"Definidas pelo Usuário"
				lDispTitle := .F.
			endif
			
			// constroi esta consulta
			buildOneQuery(aaBuffer, aoXmlMetaDados, oConsulta)
		endif
		
		oConsulta:RestPos()
		
		sendBuffer(aaBuffer)
		
		oConsulta:_Next()
   enddo
   __DWIDTemp := -1
	
return

/*
--------------------------------------------------------------------------------------
Monta/exibe UMA consulta passada como argumento (aoConsulta)
Args: 	aaBuffer, array, array contendo a montagem dos camos a serem exibidas
		aoXmlMetaDados, objeto, contendo o objeto responsável pelo arquivo Xml
		aoConsulta, objeto, contendo a consulta a ser construída
--------------------------------------------------------------------------------------
*/
function buildOneQuery(aaBuffer, aoXmlMetaDados, aoConsulta, alID)
	Local oCons, aAux
	Local oCalc := InitTable(TAB_CALC)
	Local oCubes := oSigaDW:Cubes():CubeList(), oAtt
	Local nCont, lTitle := .t.
	Local aFilters := {}, aAlertSel := {}, aAlertId := {}
	Local aTemp
	Local oAlerta
	Local aProp := {}, aDimX := {}, aDimY := {}, aInd := {}
	Local cAux
  	local lCache := iif(oSigaDW:DWCurrID() == -1, .f., nil)
	
	default alID := .t.

	// definição                
	makeH2(aaBuffer, aoConsulta:Value("nome",.t.) + "-" + aoConsulta:Value("descricao", .t.))
	
	makeSubTitle(aaBuffer, STR0014) //"Definição"

	// exibe a definição da consulta na tela
	makeText(aaBuffer, displayData(aoConsulta:Record(6, { "id*", "conspai", "ID_DW" } )))
	
	// define as propriedades da consulta no objeto xml
	if valType(aoXmlMetaDados) == "O"
		if alID
			aEval(aoConsulta:Record(7, { "id*", "conspai", "ID_DW" }), { |x| iif(.t. .or. !empty(x[2]), aoXmlMetaDados:addQueryProperty(x[1], x[2]),nil) })
		else
			aEval(aoConsulta:Record(7, { }), { |x| iif(.t. .or. !empty(x[2]), aoXmlMetaDados:addQueryProperty(x[1], x[2]),nil) })
		endif
    aoXmlMetaDados:addQueryProperty("login", aoConsulta:value("login"))
	endif
   	
	oCons := TConsulta():New(aoConsulta:value("id"), , lCache)
	aAlertSel := oCons:Alerts()
	for nCont := 1 to len(aAlertSel)
		aAdd(aAlertId, aAlertSel[nCont]:faprops[1])
	next
	
	// define a propriedade cubo para esta consulta no objeto xml
	if valType(aoXmlMetaDados) == "O"
		if (oCons:HaveCube())
			oCubes:Seek(1, { oCons:Cube():ID() })
			aoXmlMetaDados:addQueryProperty("cube", oCubes:value("nome",.t.))
		else
			aoXmlMetaDados:addQueryProperty("cube", "")
		endif
	endif
	
	// campos virtuais
	oCalc:Seek(2, { oCons:ID() } )
	while !oCalc:Eof() .and. oCalc:value("id_cons") == oCons:ID()
		if lTitle
			makeSubTitle(aaBuffer, STR0024) //"Campos virtuais"
			lTitle := .f.
		endif
		
		// exibe os campos virtuais da consulta na tela
		makeText(aaBuffer, displayData(oCalc:Record(6, { "id*" } )))
		
		// define os atributos da consulta no objeto xml
		aTemp := {}
		if alID
			aEval(oCalc:Record(7, { "id*"}), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
		else
			aEval(oCalc:Record(7, { }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
		endif
		// campos especial de subexpression
		if valType(aoXmlMetaDados) == "O"
			// verifica se o campo virtual (indicador) é do cubo
			If !(oCalc:value("id_virtual") == 0)
				aAdd(aTemp, { "virtual", "T" })
			EndIf
			
			aAdd(aTemp, {aoXmlMetaDados:getTypeSubExpression(), oCalc:value("expressao",.t.), "isSQL", dwStr(oCalc:value("isSQL"))})
			
			// define o objeto xml
			aoXmlMetaDados:addQueryVirtualAttribute(aTemp)
		endif
		oCalc:_Next()
	enddo
	
	if oCons:HaveTable()
		aProp := {}
		aDimX := {}
		aDimY := {}
		aInd  := {}

		oCons := TConsulta():New(aoConsulta:value("id"), TYPE_TABLE, lCache)
		
		// tabela
		makeSubTitle(aaBuffer, STR0025) //"Tabela"
		
		buildComponent(aaBuffer, oCons, aProp, aDimX, aDimY, aInd)
		if valType(aoXmlMetaDados) == "O"
			aoXmlMetaDados:addQueryTable(aProp, aDimX, aDimY, aInd)
		endif
	endif			

	if oCons:HaveGraph()
		aProp := {}
		aDimX := {}
		aDimY := {}
		aInd  := {}
		
		// gráfico
		oCons := TConsulta():New(aoConsulta:value("id"), TYPE_GRAPH, lCache)
		makeSubTitle(aaBuffer, STR0026) //"Gráfico"
		
		// define as propriedades do gráfico no objeto xml
		aAdd(aProp, {"GraphClass", oCons:GraphClass()})
		aAdd(aProp, {"GraphProps", oCons:GraphProps()})
		aAdd(aProp, {"GraphYProps", oCons:GraphYProps()})
		aAdd(aProp, {"GraphY2Props", oCons:GraphY2Props()})
		
		// exibe o gráfico na tela
		buildComponent(aaBuffer, oCons, aProp, aDimX, aDimY, aInd)
		if valType(aoXmlMetaDados) == "O"
			aoXmlMetaDados:addQueryGraphic(aProp, aDimX, aDimY, aInd)
		endif
  	endif
	
	// recupera os filtros para a consulta
	aFilters := oCons:Where(.t.)
	
	// filtros opcionais
	cAux := buildFilters(FILTER_NORMAL, aClone(aFilters), oCons, aoXmlMetaDados)
	if !empty(cAux)
		makeCustomField(aaBuffer, "opcionalFilter", cAux)
	endif

	// filtros obrigatórios
	cAux := buildFilters(FILTER_SECURE, aClone(aFilters), oCons, aoXmlMetaDados)
	if !empty(cAux)
		makeCustomField(aaBuffer, "compulsoryFilter", cAux)
	endif
	
	// filtros segmentos
	cAux := buildFilters(FILTER_SEGTO, aClone(oCons:Segto()), oCons, aoXmlMetaDados)
	if !empty(cAux)
		makeCustomField(aaBuffer, "segmentFilter", cAux)
	endif
	
	// alertas
	aAux := aClone(oCons:Alerts(.t.))
	if len(aAux) > 0
		makeSubTitle(aaBuffer, STR0027) //"Alertas"
		aEval(aAux, { |x,i| aAux[i] := x:ExpHtml3(.F.) })
		
		// exibe os alertas da consulta na tela
		makeText(aaBuffer, displayData(aAux))
		
		if valType(aoXmlMetaDados) == "O"
			oAlerta := InitTable(TAB_ALERT)
			oAlerta:Seek(2, { oCons:ID() })
			while !oAlerta:Eof() .and. oAlerta:value("id_cons") == oCons:ID()
				if ascan(aAlertId, oAlerta:value("id")) > 0
  					aoXmlMetaDados:addQAlertSel("T")
				else
					aoXmlMetaDados:addQAlertSel(OBJ_CUBE)
				endif
				aoXmlMetaDados:addQAlertExpression(oAlerta:value("expressao",.t.))
				
				aTemp := {}
				if alID
					aEval(oAlerta:Record(7, { "id*"}), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
				else
					aEval(oAlerta:Record(7, { }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aTemp, {x[1], x[2]}),nil) })
				endif
				aoXmlMetaDados:addQAlertProperty(aTemp)
			
				oAlerta:_Next()
			enddo
		endif

 	endif

	// recupera a documentação da consulta
	if aoConsulta:value("id_docto") > 0 .and. valType(aoXmlMetaDados) == "O"
	    aTemp := dwToken(strTran(aoConsulta:value("docto"), LF, ""), CR, .F.)
		aoXmlMetaDados:addQDoc(aTemp)			
		aTemp := {}
		aTemp := dwToken(strTran(DWTxt2Html(nil, aoConsulta:value("docto")), LF, ""), CR, .F.)
		aoXmlMetaDados:addQDocHtml(aTemp)
	else
		aoXmlMetaDados:clearDoc()                                                          
		aoXmlMetaDados:clearHTMLDoc()
	endif
	
 	// adiciona a consulta ao arquivo xml final
 	if valType(aoXmlMetaDados) == "O"
		aoXmlMetaDados:addQuery()
	endif

return

/*
--------------------------------------------------------------------------------------
Monta/exibe uma representação de um gráfico ou tabela de uma consultas escolhidas pelo usuário.
Args: aaBuffer, array, array contendo a montagem dos camos a serem exibidas
		aoCons, objeto, contendo uma consulta
Ret: array, contendo os nodes que deverão ser adicionados ao objeto de xml
--------------------------------------------------------------------------------------
*/
static function buildComponent(aaBuffer, aoCons, aaProp, aaDimX, aaDimY, aaInd, alID)
  	local nInd
	local aAux 		:= {{}, {}}
	local aRanking 	:= {}
	local aAuxRank 	:= {}
	local cRank, cNome
	local oFactFields	:= InitTable(TAB_FACTFIELDS)
	
	makeText(aaBuffer, "<!-- buildComponent --!>")
	makeText(aaBuffer, "<blockquote><table width='90%' cellspacing='1' cellpadding='1' class='zebra'>" + ;
	"<tr><td width='30%'>&nbsp;</td><td class='zebraOn'><b>" + STR0028 + "<b></td></tr>" + ; //"Eixo X"
	"<tr class=zebraOff><td width='30%' valign='bottom'><b>" + STR0029 + "</b></td><td class=zebraOn>") //"Eixo Y"
	
	aAuxRank := aClone(aoCons:RankDef())
	for nInd := 1 to len(aAuxRank)
		if aAuxRank[nInd, 1] > 0 .and. oFactFields:Seek(1, { aAuxRank[nInd, 1] } )
			aAuxRank[nInd, 1] := oFactFields:value("NOME")
			aAdd(aRanking, DWConcatWSep(";", aAuxRank[nInd]))
		endif
	next
	
	aAdd(aaProp, {"rankStyle", aoCons:rankStyle()})
	aAdd(aaProp, {"rankDef", DWConcatWSep("|", aRanking)})
	aAdd(aaProp, {"curvaABC", dwStr(aoCons:curvaAbc(), .t.)})
	aAdd(aaProp, {"recLimit", DwStr(oSigaDW:RecLimit())})
	aAdd(aaProp, {"fatorEscala", aoCons:FatorEscala()})
	aAdd(aaProp, {"indSobrePosto", aoCons:IndSobrePosto()})
	aAdd(aaProp, {"emptyCell", aoCons:EmptyCell()})
	aAdd(aaProp, {"alertOn", aoCons:AlertOn()})
	aAdd(aaProp, {"hintOn", aoCons:HintOn()})
	aAdd(aaProp, {"Filtered", aoCons:Filtered()})
	aAdd(aaProp, {"Total", aoCons:Total()})
	aAdd(aaProp, {"RankOn", aoCons:RankOn()})
	aAdd(aaProp, {"RankOu", aoCons:RankOutros()})
	aAdd(aaProp, {"RankSubTotal", aoCons:RankSubTotal()})
	aAdd(aaProp, {"RankTotal", aoCons:RankTotal()})
	
	aEval(aoCons:DimFieldsX(), { |x| aAdd(aAux[1], { x:DimName() + "->" + x:Desc(), "" }), ;
	aAdd(aAux[2], { x:DimName() , x:Name(), "("+DWStr(x:Temporal())+"|"+x:GraphColor()+")"+iif(x:DrillDown(), "*", "") })})
	if len(aAux) > 0
		makeText(aaBuffer, dwConcatWSep("<br>", aAux[1]))
		aaDimX := aAux[2]
	else
		makeText(aaBuffer, "&nbsp;")
	endif
	makeText(aaBuffer, "</td><tr class=zebraOff><td>")
	
	aAux := {{}, {}}
	aEval(aoCons:DimFieldsY(), { |x| aAdd(aAux[1], { x:DimName() + "->" + x:Desc(), "" }), ;
	aAdd(aAux[2], { x:DimName() , x:Name(), "("+DWStr(x:Temporal())+"|"+x:GraphColor()+")"+iif(x:DrillDown(), "*", "") })})
	if len(aAux) > 0
		makeText(aaBuffer, dwConcatWSep("<br>", aAux[1]))
		aaDimY := aAux[2]
	else
		makeText(aaBuffer, "&nbsp;")
	endif
	makeText(aaBuffer, "</td><td>")
	aAux := {{}, {}}
	
	aEval(aoCons:Indicadores(), { |x| aAdd(aAux[1], { x:AggTit(x:AggFunc(), x:Desc(), .t.) }), ;
	aAdd(aAux[2], { x:Name(), dwStr(x:AggFunc())+";"+dwStr(x:Ordem())+";"+dwStr(x:GraphColor()) })})
	
	if len(aAux) > 0
		makeText(aaBuffer, dwConcatWSep("<br>", aAux[1]))
		aaInd := aAux[2]
	else
		makeText(aaBuffer, "&nbsp;")
	endif
	makeText(aaBuffer, "</td></td></tr></table></blockquote>")

return

/*
--------------------------------------------------------------------------------------
Monta/exibe a descrição de um filtro
Args: acTipo, string, contem o tipo de filtro
		aaFiltros, array, contendo os filtros
		aoCons, objeto, contendo a consulta
--------------------------------------------------------------------------------------
*/
static function buildFilters(acTipo, aaFiltros, aoCons, aoXmlMetaDados, alID)

	local nInd, i
	local aAux := aaFiltros, aTypeCons := {}
	local oWhere, oWhereCond
	local aTitle := { STR0030, STR0031, STR0032 } //"Filtros Opcionais"###"Filtros Obrigatórios"###"Filtros Segmentação"
	local cReturn := ""
	local nTypeCons
	local aFltrProp := {}, aFltrExpr := {}

	default alID := .t.
	
	if len(aAux) > 0
		for nInd := 1 to len(aAux)
			if acTipo == aAux[nInd]:tipo()
				aAux[nInd] := aAux[nInd]:ExpHtml3()
				aAux[nInd, 2] := strTran(aAux[nInd, 2], CRLF+"<", "<")
			else
				aAux[nInd] := nil
			endif
		next     
		aAux := packArray(aAux)
		if len(aAux) > 0
			cReturn += makeSubTitle(NIL, aTitle[dwval(acTipo)+1])
			// exibe os filtros da consulta na tela
			cReturn += displayData(aAux, 2, { STR0033, STR0034 }) //"Nome"###"Expressão"
		endif
	endif
	
	if valType(aoXmlMetaDados) == "O"
		oWhere := InitTable(TAB_WHERE)
		oWhereCond := InitTable(TAB_WHERE_COND)
		oWhereCons := InitTable(TAB_CONS_WHE)
		oConsType := InitTable(TAB_CONSTYPE)
		
		oWhere:Seek(2, { aoCons:ID() })
		while !oWhere:Eof() .and. oWhere:value("id_cons") == aoCons:ID()
			if acTipo == oWhere:value("tipo")
			
				// preara os atributos de filtro da consulta no objeto xml
				aFltrProp := {}
				if alID
					aEval(oWhere:Record(7, { "id*"}), { |x| iif(.t. .or. !empty(x[2]), aAdd(aFltrProp, {x[1], x[2]}),nil) })
				else
					aEval(oWhere:Record(7, { }), { |x| iif(.t. .or. !empty(x[2]), aAdd(aFltrProp, {x[1], x[2]}),nil) })
				endif
							
				aTypeCons := {{TYPE_TABLE,"FilterSelT"},{TYPE_GRAPH,"FilterSelG"}}
											
				for i := 1 to len(aTypeCons)
						
					If oConsType:seek(2, {oWhere:value("id_cons"), aTypeCons[i,1]})
						nTypeCons := oConsType:value("id")
					endif
					
					if oWhereCons:seek(2, {nTypeCons, oWhere:value("id")}) .or. oWhere:value("tipo") == FILTER_SECURE .or. oWhere:value("tipo") == FILTER_SEGTO
						aAdd(aFltrProp, {aTypeCons[i,2], "T"})
					else
						aAdd(aFltrProp, {aTypeCons[i,2], "F"})
					endif
					
				next
				
				if oWhere:value("id_expr") == 0
					aFltrExpr := {}
					oWhereCond:Seek(2, { oWhere:value("id") })
					while !oWhereCond:eof() .and. oWhereCond:value("id_where") == oWhere:value("id")
						
						// prepara os campos de expression
						aAdd(aFltrExpr, {"sequence", oWhereCond:value("seq")})
						aAdd(aFltrExpr, {"dimension", oWhereCond:value("dimname")})
						if !empty(oWhereCond:value("fieldname"))
							aAdd(aFltrExpr, {"field", oWhereCond:value("fieldname")})
						else
							aAdd(aFltrExpr, {"field", oWhereCond:value("indName")})
						endif
						
						// identifica que esta é uma subexpression do node de expression
						aAdd(aFltrExpr, {aoXmlMetaDados:getTypeSubExpression(), { oWhereCond:value("qbe"), oWhereCond:value("last_value") } })
						
						oWhereCond:_Next()
					enddo
				else
					// prepara os campos de expression
					aFltrExpr := {aoXmlMetaDados:getTypeSubExpression(), oWhere:value("expressao") }
				endif
				aoXmlMetaDados:addQFilter(aFltrProp, aFltrExpr)
			endif
			oWhere:_Next()
		enddo
	endif
		
return cReturn
  
/*
--------------------------------------------------------------------------------------
Exporta um DW especifico, gravando os dados em arquivo texto
Args: acFilename, string, nome do arquivo destino
--------------------------------------------------------------------------------------
*/
function DWMetadados(acFileName)
	local oXmlMetaDados := TDWXmlMetaDado():New()
	local aBuffer := {}
	
	buildDimension(aBuffer, oXmlMetaDados, .t., .t.)
	buildCube(aBuffer, oXmlMetaDados, .t., .t.)
	buildQuery(aBuffer, QUERY_PREDEF, oXmlMetaDados, .t., .t.)
	buildQuery(aBuffer, QUERY_USER, oXmlMetaDados, .t., .t.)

	oXmlMetaDados:SaveFile(acFileName)
	oXmlMetaDados:Free()
	
return

static function sendBuffer(aaBuffer)
  
  httpSend(buildPrint(aaBuffer, {}, .f.))
  aaBuffer := {}
  
return

static function arrPosDim(aaDrawCmds, anDimTop, anDimLeft, anServerTop, anServerLeft)
	local nInd, nHeight
  local nDesloc := ATT_HEIGHT + ATT_MARGIN_BOTTOM
  local nServerHeight := 0
	
	for nInd := 1 to len(aaDrawCmds)
		if aaDrawCmds[nInd, 3] == OBJ_DIMENSION
			nHeight := DIM_HEIGHT + aaDrawCmds[nInd, 4] * nDesloc + nDesloc
		elseif aaDrawCmds[nInd, 3] == OBJ_CONNECTION
			nServerHeight += DSN_DESLOC
		endif
	next

	nHeight := int((nHeight - nServerHeight) / 2)
	if nHeight < 0
		anDimTop := abs(nHeight)
	else
		anServerTop := nHeight
	endif

return

static function arrPosCube(aaDrawCmds, anCubeTop, anCubeLeft, anDimTop, anDimLeft, anServerTop, anServerLeft)
	local nInd, nHeight
  local nDesloc := ATT_HEIGHT + ATT_MARGIN_BOTTOM
	local nDimHeight := 0, nServerHeight := 0, nCubeHeight := 0
	
	for nInd := 1 to len(aaDrawCmds)
		if aaDrawCmds[nInd, 3] == OBJ_DIMENSION
			nDimHeight += DIM_HEIGHT + aaDrawCmds[nInd, 4] * nDesloc + nDesloc
		elseif aaDrawCmds[nInd, 3] == OBJ_CONNECTION
			nServerHeight += DSN_DESLOC
		elseif aaDrawCmds[nInd, 3] == OBJ_CUBE
			nCubeHeight += CUB_HEIGHT + aaDrawCmds[nInd, 4] * nDesloc + nDesloc
		endif
	next

	nHeight := max(max(nDimHeight, nServerHeight), nCubeHeight)
	anDimTop := int((nHeight - nDimHeight) / 2)
	anServerTop := int((nHeight - nServerHeight) / 2)
	anCubeTop := int((nHeight - nCubeHeight) / 2)

return

static function prepStx(acObjType, anID, acStrTxt, aaDrawCmds)
	local cTxt := acStrTxt
	local cTxt1 := "", cTxt2 := ""
	local cCmdDraw := "", nInd
	local nPos := at('[schema]', cTxt)
	local nDimTop := 0, nDimLeft := 0, nServerTop := 0, nServerLeft := 0
	local nCubeTop := 0, nCubeLeft := 0 
		
	if nPos == 0     
		cTxt1 := cTxt + CRLF + "[showSchemaBegin]" + CRLF
	else
		cTxt1 := substr(cTxt, 1, nPos - 1) + "[showSchemaBegin]" + CRLF
		cTxt2 := substr(cTxt, nPos + 7)
	endif

	cTxt2 := "[showSchemaEnd Obj_"+ OBJ_ID(acObjType, anID)+"]" + CRLF +cTxt2

	for nInd := 1 to len(aaDrawCmds)
		cCmdDraw += aaDrawCmds[nInd,2 ]+CRLF
	next

	if acObjType == OBJ_DIMENSION
		arrPosDim(aaDrawCmds, @nDimTop, @nDimLeft, @nServerTop, @nServerLeft)
	else
		arrPosCube(aaDrawCmds, @nCubeTop, @nCubeLeft, @nDimTop, @nDimLeft, @nServerTop, @nServerLeft)
	endif
			
	cCmdDraw += "var SERVER_TOP = "+dwStr(nServerTop)+";"+ CRLF
	cCmdDraw += "var SERVER_LEFT = "+dwStr(nServerLeft)+";"+ CRLF
	cCmdDraw += "var DIM_TOP = "+dwStr(nDimTop)+";"+ CRLF
	cCmdDraw += "var DIM_LEFT = "+dwStr(nDimLeft)+";"+ CRLF
	cCmdDraw += "var CUBE_TOP = "+dwStr(nCubeTop)+";"+ CRLF 
	cCmdDraw += "var CUBE_LEFT = "+dwStr(nCubeLeft)+";"+ CRLF
	
	cCmdDraw += "function drawRoutines()" + CRLF
	cCmdDraw += "{" + CRLF
	cCmdDraw += "  clearInterval(oControl);" + CRLF
	cCmdDraw += "  setCurrentContext('canObj_" + OBJ_ID(acObjType, anID)+"');" + CRLF

	for nInd := 1 to len(aaDrawCmds)
		cCmdDraw += aaDrawCmds[nInd,1 ]+"();"+CRLF
	next
	
	cCmdDraw += "drawLinks();"+CRLF
	cCmdDraw += "drawAlign('canObj_" + OBJ_ID(acObjType, anID)+"');"+CRLF

	cCmdDraw += "}"+CRLF
	
return dwTxt2Html(nil, dwToken(strTran(cTxt1 + cCmdDraw + cTxt2, LF, ""), CR, .f.))

static function drawDim(aoDS, aaKeys, aaAtts)
	local aRet := {}, aLinks := {}
	Local oDimFields	:= InitTable(TAB_DIM_FIELDS)
	
	aSort(aaKeys,,, { |x,y| x[2] < y[2]})
	
	aAdd(aRet , "function drawObj_" +OBJ_ID(OBJ_DIMENSION, aoDS:value("id")) + "()")
	aAdd(aRet , "{")
	aAdd(aRet , "  var aKeys = new Array();")
	aAdd(aRet , "  var aAtts = new Array();")
	aEval(aaKeys, { |x| aAdd(aRet , "  aKeys.push('"+x[1]+"');") } )
	aEval(aaAtts, { |x| aAdd(aRet , "  aAtts.push('"+x+"');") } )
	aAdd(aRet , "  drawDimension('"+OBJ_ID(OBJ_DIMENSION, aoDS:value("id"))+"', DIM_LEFT+10, DIM_TOP+10, '"+aoDS:value("nome")+"', '"+aoDS:value("descricao")+"', aKeys, aAtts);")
	aAdd(aRet , "}")
	
return { "drawObj_" + OBJ_ID(OBJ_DIMENSION, aoDS:value("id")), dwConcatWSep(CRLF, aRet), OBJ_DIMENSION, len(aaKeys) + len(aaAtts) }

static function drawDim2(anX, anY, anID, acDimName, aaKeys, acLinkID)
	local aRet := {}, aLinks := {}

	aAdd(aRet , "function drawObj_" +OBJ_ID(OBJ_DIMENSION, anID) + "()")
	aAdd(aRet , "{")
	aAdd(aRet , "  var aKeys = new Array();")
	aAdd(aRet , "  var aAtts = new Array();")
	aEval(aaKeys, { |x| aAdd(aRet , "  aKeys.push('"+x+"');") } )
	aAdd(aRet , "  drawDimension('"+OBJ_ID(OBJ_DIMENSION, anID)+"', DIM_LEFT+"+dwStr(anX)+",DIM_TOP+"+dwStr(anY)+", '"+acDimName+"', '', aKeys, aAtts, DIM_IN_CUBE_COLOR);")
	aAdd(aRet , "  linkTo('" + OBJ_ID(OBJ_DIMENSION, anID)+"','"+acLinkID+"');")
	aAdd(aRet , "}")
	
return { "drawObj_" + OBJ_ID(OBJ_DIMENSION, anID), dwConcatWSep(CRLF, aRet), OBJ_DIMENSION, len(aaKeys) }

static function drawCube(aoDS, aaInds, aaVirts)
	local aRet := {}, aLinks := {}
	Local oDimFields	:= InitTable(TAB_DIM_FIELDS)

	aAdd(aRet , "function drawObj_" +OBJ_ID(OBJ_CUBE, aoDS:value("id")) + "()")
	aAdd(aRet , "{")
	aAdd(aRet , "  var aVirts = new Array();")
	aAdd(aRet , "  var aInds = new Array();")
	aEval(aaVirts, { |x| aAdd(aRet , "  aVirts.push('"+x+"');") } )
	aEval(aaInds , { |x| aAdd(aRet , "  aInds.push('"+x+"');") } )
	aAdd(aRet , "  drawCube('"+OBJ_ID(OBJ_CUBE, aoDS:value("id"))+"', CUBE_LEFT+250, CUBE_TOP, '"+aoDS:value("nome")+"', '"+aoDS:value("descricao")+"', aInds, aVirts);")
	aAdd(aRet , "}")
	
return { "drawObj_" + OBJ_ID(OBJ_CUBE, aoDS:value("id")), dwConcatWSep(CRLF, aRet), OBJ_CUBE, len(aaInds) + len(aaVirts) }

static function drawServer(aoDS, anX, anY, acLinkID)
	local aRet := {}

	default acLinkID := ""
		
	aAdd(aRet , "function drawObj_" + OBJ_ID("S", aoDS:value("id")) + "()")
	aAdd(aRet , "{")
	aAdd(aRet , "  drawServer('" + OBJ_ID("S", aoDS:value("id"))+"', SERVER_LEFT+"+dwStr(anX)+", SERVER_TOP+"+dwStr(anY)+", '"+aoDS:value("connector")+"', '"+aoDS:value("server")+"');")
	aAdd(aRet , "  linkTo('" + OBJ_ID("S", aoDS:value("id"))+"','"+acLinkID+"');")
	aAdd(aRet , "}")

return { "drawObj_" + OBJ_ID("S", aoDS:value("id")), dwConcatWSep(CRLF, aRet), OBJ_CONNECTION}

static function OBJ_ID(cObjType, nObjID)

return cObjType + int2Hex(nObjID, 3)

%>