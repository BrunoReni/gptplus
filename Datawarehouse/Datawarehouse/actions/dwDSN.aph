<%
// ######################################################################################
// Projeto: DATA WAREHOUSE
// Modulo : Actions
// Fonte  : dwDSN - Manutenção de DSN
// ---------+-------------------+--------------------------------------------------------
// Data     | Autor             | Descricao
// ---------+-------------------+--------------------------------------------------------
// 06.12.05 | 0548-Alan Candido | Versão 3
// --------------------------------------------------------------------------------------

#include "dwincs.ch" 
#include "dwDSN.ch"

#define PROCINV_LIST    {{ STR0046, PROCINV_ALL }, { STR0047, PROCINV_IGNORE_INVALID }, { STR0048, PROCINV_IGNORE_ALL }} //###"Aceita registros invalidos"###"Rejeita registros invalidos"###"Ignorar todos os registros"

#define UPDMET_LIST     {{ STR0049, UPDMET_DEFAULT }, { STR0050, UPDMET_INSERT  }, { STR0051, UPDMET_UPDATE  } } //###"Padrão"###"Inserção"###"Atualização"

local cCaptionObj, cTitle := STR0008 //'Fonte de Dados'
local oObj, nAux, aFields := {}
local aValues, lCLose := .f., lSubmit := .f., lProcessOK := .T. 
local aCols, aItens
local cAction := HttpGet->action
local lEdit := .T.
local aButtons := {}
local oConexao := oSigaDW:Connections()

private oDSN := initTable(TAB_DSN)

if cAction == AC_DSN_DIM_MANUT .or. cAction == AC_CUB_DSN_RECMAN
	if cAction == AC_DSN_DIM_MANUT
		DWSetProp("Tipo", OBJ_DIMENSION)
	else
		DWSetProp("Tipo", OBJ_CUBE)
	endif	

	HttpGet->dw_step := dwVal(HttpGet->dw_step)
	
	if HttpGet->dw_step == 0
	    DWSetProp("ID_WIZARD", 0)
		if DWGetProp("Tipo") == OBJ_DIMENSION
			DWSetProp("ID_Table", DWGetProp("IDDim", "h_dwdimds"))
		else
			DWSetProp("ID_Table", DWGetProp("IDCube", "h_dwcubeds"))
			
			// verifica privilégio para dar manutenção (CASO não seja administrador)
			lEdit := checkPermission(DwVal(DWGetProp("IDCube", "h_dwcubeds")))
			if !lEdit
				makeButtons(aButtons, BT_PREVIOUS)
			endif
		endif	
	endif

	HttpSession->dw_step := HttpGet->dw_step + 1
	
	if DWGetProp("Tipo") == OBJ_DIMENSION
		oObj := initTable(TAB_DIMENSAO)
		cCaptionObj := STR0001 //"Dimensão"
	else
		oObj := initTable(TAB_CUBESLIST)
		cCaptionObj := STR0002 //"Cubo"
	endif
                       
	if !oObj:Seek(1, { DWGetProp("ID_Table") } )
		dwRaise(ERR_005, SOL_003, cCaptionObj + ' ID=' + dwStr(nAux))
	endif

	makeShow(aFields, 'edObjDesc',cCaptionObj, oObj:value("nome") + '-' + oObj:value("descricao"))
	
	// operações básicas: alteração e exclusão
	HttpGet->Oper := DwVal(HttpGet->Oper)
	
	// ação de "anterior" na página de indicadores
	if HttpGet->Oper == OP_REC_STEPS
		nID := dwVal(HttpGet->ID)
	  lOperSubmit 		 := .F.
	  lClose				 := .F.
	  HttpSession->subOper := OP_REC_STEPS
	  HttpGet->Oper 		 := OP_REC_EDIT
	elseif HttpGet->Oper == OP_REC_EDIT .or. HttpGet->Oper == OP_REC_DEL
		oDSN:Seek(1, { dwVal(HttpGet->Id) })
		procStep0(oDSN:value("id"), aFields)
		makeHidden(aFields, 'edID', HttpGet->ID)
		lSubmit := .T.
		HttpSession->subOper := HttpGet->Oper
	// submissão da alteração ou exclusão
	elseif HttpGet->Oper == OP_SUBMIT .and. oDSN:Seek(1, { HttpPost->edID })
		// alteração
		if HttpSession->subOper == OP_REC_EDIT
			lProcessOK := oDSN:Update(oDSN:fromPost(HttpPost->APost))
		// exclusão
		elseif HttpSession->subOper == OP_REC_DEL
			lProcessOK := oDSN:Delete()
		endif
		if !lProcessOK
			DWRaise(ERR_002, SOL_000, oDSN:Msg(.t.))
		endif
		
		lClose := .T.
		procStep0(0, aFields)
	elseif HttpGet->dw_step == 0 // inicio do processo
		procStep0(0, aFields)
	elseif HttpGet->dw_step == 1  // insere a fonte de dados e solicita demais dados
		aValues := {}

		aAdd(aValues, { "tipo"      , DWGetProp("Tipo") })
		aAdd(aValues, { "id_table"  , DWGetProp("id_table") })
		aAdd(aValues, { "id_connect", dwVal(HttpPost->edId_connect) })
		aAdd(aValues, { "nome"      , HttpPost->edNome })
		aAdd(aValues, { "descricao" , HttpPost->edDescricao })
		aAdd(aValues, { "UpdMethod" , httpPost->edUpdMethod })
		aAdd(aValues, { "ProcInv"   , httpPost->edProcInv })
		aAdd(aValues, { "RptInval"  , httpPost->edRptInval })
		aAdd(aValues, { "embedsql"  , dwVal(httpPost->edEmbedSQL) == 1 })
		
		if !(isnull(httpPost->edProcCons))
			aAdd(aValues, { "ProcCons"  , dwVal(httpPost->edProcCons) == 1 })
		endif
		 
		// Verifica de onde vem a chamada
		if DWGetProp("ID_WIZARD") <> 0
	  	   oDSN:seek(1, { DWGetProp("ID_WIZARD") }, .T.)
	  		if !oDsn:update(aValues)
				DWRaise(ERR_002, SOL_000, oDSN:Msg(.t.))					
			endif
		elseif !oDSN:Append(aValues)
			DWRaise(ERR_002, SOL_000, oDSN:Msg(.t.))
		else
		   	DWSetProp("ID_WIZARD", oDSN:Value("ID"))
		    
			httpSession->EDT_PARAM_DSN := .T.
			httpSession->ID_DSN := oDSN:Value("ID")
		endif
		
		prepProc(oDSN:value("id"))
		procStep1(oDSN:value("id"), aFields)
	elseif HttpGet->dw_step == 2 // grava os dados princiapis e prepara eventos
		if !oDSN:seek(1, { dwGetProp("id") } )
			dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwGetProp("id")) //'Fonte de Dados'
		endif
		
		makeShow(aFields, 'edDSDesc',STR0003, oDSN:value("nome") + '-' + oDSN:value("descricao")) //"Fonte"
		makeShow(aFields, 'edDSConector',STR0004, oDSN:value("connector")+'('+oDSN:value("tipo_text")+')') //"Conexão"
                             
		aValues := {}
		aAdd(aValues, { "id_filter" , dwVal(httpPost->edID_Filter) })
		aAdd(aValues, { "ID_ForZap" , dwVal(httpPost->edID_ForZap) })

		if oDSN:value("tipo_conn") == TC_TOP_CONNECT
			aAdd(aValues, { "id_sqlStru" , dwVal(httpPost->edID_SQLStru) })
			aAdd(aValues, { "id_sql", dwVal(httpPost->edID_SQL) })
			aAdd(aValues, { "optimizer", httpPost->edOptimizer == CHKBOX_ON })
		else
			oConexao:Seek(1, { oDSN:value("id_connect") })
			if oConexao:EoF() .OR. !(oConexao:value("id") == oDSN:value("id_connect"))
				dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwStr(oDSN:value("id_connect"))) //'Fonte de Dados'
			endif
			aAdd(aValues, { "empfil", httpPost->edEmpFil })
			if oDSN:value("tipo_conn") == TC_AP_SX
				aAdd(aValues, { "id_sql", dwVal(httpPost->edID_SQL) })
				aAdd(aValues, { "embedsql"  , dwVal(httpPost->edEmbedSQL) == 1 })
				aAdd(aValues, { "alias", httpPost->edAlias })
			else
				aAdd(aValues, { "caminho", httpPost->edCaminho })
				aAdd(aValues, { "arquivo", httpPost->edArquivo })
			endif
		endif

		oDSN:update( aValues )

		if oDSN:value("tipo_conn") == TC_TOP_CONNECT
			makeShow(aFields, 'edDSServer'  , STR0007, oConexao:value("server") + "/" + oConexao:value("banco_srv") + "/" + oConexao:value("alias")) //'Banco/Alias'
		else
			oConexao:Seek(1, { oDSN:value("id_connect") })
			if oDSN:value("tipo_conn") == TC_AP_SX
				makeShow(aFields, 'edDSAmbiente', STR0009, oConexao:value("server") + "/" + oConexao:value("ambiente")) //'Servidor/Ambiente'
				makeShow(aFields, 'edEmpFil' , STR0010, oDSN:value("empFil")) //'Empresa/Filial'
				makeShow(aFields, 'edAlias'    , STR0011, oDSN:value("alias")) //'Alias'
			else
				makeShow(aFields, 'edDSAmbiente', STR0009, oConexao:value("server") + "/" + oConexao:value("ambiente")) //'Servidor/Ambiente'
				makeShow(aFields, 'edEmpFil'    , STR0010, oDSN:value("empfil")) //'Empresa/filial'
				makeShow(aFields, 'edCaminho'   , STR0012, oDSN:value("caminho")) //'Caminho'
				makeShow(aFields, 'edArquivo'   , STR0013, oDSN:value("arquivo")) //'Arquivo'
			endif
		endif

		procStep2(oDSN:value("id"), aFields)

	elseif HttpGet->dw_step == 3 // grava os dados de eventos e monta roteiro
		if !oDSN:seek(1, { dwGetProp("id") } )
			dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwGetProp("id")) //'Fonte de Dados'
		endif

		makeShow(aFields, 'edDSDesc',STR0003, oDSN:value("nome") + '-' + oDSN:value("descricao")) //'Fonte'
		makeShow(aFields, 'edDSConector',STR0004, oDSN:value("connector")+'('+oDSN:value("tipo_text")+')') //'Conexão'

		if !oDSN:seek(1, { dwGetProp("id") } )
			dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwGetProp("id")) //'Fonte de Dados'
		endif

		aValues := {}
		aAdd(aValues, { "reclimit" , dwVal(httpPost->edRecLimit) })
		aAdd(aValues, { "id_b_exec" , dwVal(httpPost->edID_B_Exec) })
		aAdd(aValues, { "id_a_exec" , dwVal(httpPost->edID_a_Exec) })
		aAdd(aValues, { "id_valida" , dwVal(httpPost->edID_Valida) })
		oDSN:update( aValues )

		aCols:= {}
		aItens := {}
		procStep3(oDSN:value("id"), aCols, aItens)
	elseif HttpGet->dw_step == 4 // grava os campos "fontes" 
		if !oDSN:seek(1, { dwGetProp("id") } )
			dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwGetProp("id")) //'Fonte de Dados'
		endif
		saveStep4()
	endif%>
	<%if HttpGet->dw_step < 3 .and. !lSubmit%>
		<%=buildForm('frmDSN', cTitle, cAction, iif (lEdit, OP_STEP, OP_NONE), aButtons, aFields, lEdit)%>
		<%if HttpGet->dw_step == 1%>
			<%= procStep1a() %>
		<%elseif HttpGet->dw_step == 2%>
			<%= procStep2a() %>
		<%endif%>
		</script>
	<%elseif HttpGet->dw_step == 3%>
		<%=buildFormBrowse('frmRoteiro', cTitle + " <small>" + STR0029 + "</small>", cAction, iif (lEdit, OP_STEP, OP_NONE), aButtons, aCols, aItens, lEdit)%> <%= /*"Roteiro"*/ %>
	<%else /* fim do processo */%>
		<% lClose := .t. %>
	<%endif
elseif cAction == AC_DSN_DIM_PARAM
	if isNull(HttpGet->id)
		HttpGet->id := dwGetProp("id")
	else
		HttpGet->id := dwVal(HttpGet->id)
	endif
	HttpGet->id := dwVal(HttpGet->id)
	prepProc(HttpGet->id)  
	
	if DWGetProp("Tipo") == OBJ_CUBE
		// verifica privilégio para dar manutenção (CASO não seja administrador)
		lEdit := checkPermission(DWGetProp("ID_Table"))
		if !lEdit
			makeButtons(aButtons, BT_PREVIOUS)
		endif
	endif
	
	if dwVal(httpget->Oper) = OP_SUBMIT
		aValues := {}
		if !empty(httpPost->edAlias)
			aAdd(aValues, { "alias" , httpPost->edAlias })
		endif
		if !empty(httpPost->edArquivo)
			aAdd(aValues, { "arquivo" , httpPost->edArquivo })
		endif
		if !empty(httpPost->edEmpfil)
			aAdd(aValues, { "empfil" , httpPost->edEmpfil })
		endif
		if !empty(httpPost->edCaminho)
			aAdd(aValues, { "caminho" , httpPost->edCaminho })
		endif
		aAdd(aValues, { "id_filter" , dwVal(httpPost->edID_Filter) })
		aAdd(aValues, { "ID_ForZap" , dwVal(httpPost->edID_ForZap) })
		aAdd(aValues, { "id_sqlStru" , dwVal(httpPost->edID_SQLStru) })
		aAdd(aValues, { "id_sql", dwVal(httpPost->edID_SQL) })
		aAdd(aValues, { "embedsql"  , dwVal(httpPost->edEmbedSQL) == 1 })
		aAdd(aValues, { "optimizer", httpPost->edOptimizer == CHKBOX_ON })
		if !(valType(httpPost->edDSEmpFil) == "U")
			aAdd(aValues, { "empfil" , httpPost->edDSEmpFil })
		endif
		oDSN:update( aValues )
		lCLose := .t.
	else
		procStep1(HttpGet->id, aFields)
		<%=buildForm('frmDSN', cTitle, cAction, iif (lEdit, OP_SUBMIT, OP_NONE), aButtons, aFields, lEdit)%>
		<%=procStep1b()%>
		<%=procStep1a()%>
	endif
elseif cAction == AC_DSN_DIM_EVENT
	if isNull(HttpGet->id)
		HttpGet->id := dwGetProp("id")
	else
		HttpGet->id := dwVal(HttpGet->id)
	endif
	HttpGet->id := dwVal(HttpGet->id)
	prepProc(HttpGet->id)  
	
	if DWGetProp("Tipo") == OBJ_CUBE
		// verifica privilégio para dar manutenção (CASO não seja administrador)
		lEdit := checkPermission(DWGetProp("ID_Table"))
		if !lEdit
			makeButtons(aButtons, BT_PREVIOUS)
		endif
	endif
	
	if dwVal(httpget->Oper) = OP_SUBMIT
		aValues := {}
		aAdd(aValues, { "reclimit" , dwVal(httpPost->edRecLimit) })
		aAdd(aValues, { "id_b_exec" , dwVal(httpPost->edID_B_Exec) })
		aAdd(aValues, { "id_a_exec" , dwVal(httpPost->edID_a_Exec) })
		aAdd(aValues, { "id_valida" , dwVal(httpPost->edID_Valida) })
		oDSN:update( aValues )
		lCLose := .t.
	else
		procStep2(HttpGet->id, aFields)
		<%=buildForm('frmDSN', cTitle, cAction, iif (lEdit, OP_SUBMIT, OP_NONE), aButtons, aFields, lEdit)%>
		<%=procStep2a()%>
	endif
elseif cAction == AC_DSN_DIM_ROTEIRO
  if isNull(HttpGet->id)
		HttpGet->id := dwGetProp("id")
	endif

	if DWGetProp("Tipo") == OBJ_CUBE
		// verifica privilégio para dar manutenção (CASO não seja administrador)
		lEdit := checkPermission(DWGetProp("ID_Table"))
		if !lEdit
			makeButtons(aButtons, BT_PREVIOUS)
		endif
	endif

	HttpGet->id := dwVal(HttpGet->id)
	prepProc(HttpGet->id)  
	if dwVal(httpget->Oper) = OP_SUBMIT
		saveStep4()
		lCLose := .t.
	else
		aCols := {}
		aItens := {}
		procStep3(HttpGet->id, aCols, aItens)
		%>
		<%=buildFormBrowse('frmRoteiro', cTitle + " <small>" + STR0029 + "</small>", cAction, iif (lEdit, OP_SUBMIT, OP_NONE), aButtons, aCols, aItens, lEdit)%> <%= /*"Roteiro"*/ %>
<% endif
endif%>
<%= tagJS() %>
function u_setWindowPosSize()
{
	  setWindowSize(650, 600);
}

function edRoteiro_dot(oSender)
{
	var cID = getAllElements(getParentElement(oSender))[0].id;
  cID = cID.substring(cID.length-4);
  //###"Roteiro"
  doEditAdvpl('<%= STR0029 %>: ' + getObject('edCpo' + cID).value, 
                    getObject('edIDRoteiro' + cID).value, -1, 
                    'edIDRoteiro' + cID, 'edRoteiro' + cID, 
                    '<%=DWGetProp("Tipo")%>', <%=dwGetProp("ID_Table", "h_dwdsn")%>);
}

function frmDSN_valid(oSender) {
	// realiza a validação de seleção de uma consulta para cópia OU um cubo
	var cAlias = getElement('edAlias').value;
	var lEmbedded = getElement('edEmbedSQL').checked;
 	var lRet = true;                                                       
 	
	if ( (!lEmbedded && (cAlias == ''))) {
	  	defineFieldMessage(getElement('edAlias')   , '<%= STR0043 %>'); //"Por favor, informe o alias e/ou selecione Embedded SQL"
	  	defineFieldError(getElement('edAlias'));
	  	lRet = false;
		}
	  return lRet;
	}
</script>

<%if lSubmit %>
	<%=buildForm('frmDSN', cTitle, HttpGet->Action, iif (lEdit, OP_SUBMIT, OP_NONE), aButtons, aFields,lEdit)%>
<% elseif lCLose
	if DWGetProp("Tipo") == OBJ_DIMENSION %>
		<%=buildAutoAction(AC_DIM_DS, { {"id", DWGetProp("ID_Table") } })%>
    <% else %>
		<%=buildAutoAction(AC_DSN_CUB_RECMAN, { {"id", DWGetProp("ID_Table") } })%>
    <%endif
endif

return __Response

static function rotStruct(poDSN)
	local aRet := {}, aParams := {}, cSQLField, cSQL
	local oConexao := oSigaDW:Connections()
	local cMask 
	              
	oConexao:Seek(1, { poDSN:value("id_connect") })
 	aAdd(aParams, 111)  // lista de campos
	if poDSN:value("tipo_conn") == TC_TOP_CONNECT
		if poDSN:value("id_sqlstru") != 0
			cSQLField := "sqlstruc"
		else
			cSQLField := "sql"
		endif                
		cSQL := poDSN:value(cSQLField, .t.)
		if !empty(cSQL)
			aAdd(aParams, oConexao:value("server", .t.))
			aAdd(aParams, oConexao:value("conex_srv", .t.))
			aAdd(aParams, oConexao:value("banco_srv", .t.))
			aAdd(aParams, oConexao:value("alias", .t.))
			aAdd(aParams, cSQL)
			aAdd(aParams, .f.)
			aRet := DWWaitJob(JOB_BASETOP, aParams)
		endif
	elseif poDSN:Value("tipo_conn") == TC_AP_SX .and. !empty(poDSN:value("alias")) .and. !poDSN:value("embedsql")
		aAdd(aParams, oConexao:value("server"))
		aAdd(aParams, oConexao:value("ambiente"))
		if empty(oDSN:value("empFil"))
			aAdd(aParams, oConexao:value("empresa"))
			aAdd(aParams, oConexao:value("filial"))
		else
			aAdd(aParams, dwEmpresa( poDSN:value("empFil")))
			aAdd(aParams, dwFilial( poDSN:value("empFil")))
		endif
		aAdd(aParams, poDSN:value("alias"))
		aRet := DWWaitJob(JOB_BASESXS, aParams, , .t.)
	elseif poDSN:Value("tipo_conn") == TC_AP_SX .and. poDSN:value("embedsql")
		aParams := {}
		aAdd(aParams, oConexao:value("server"))
		aAdd(aParams, oConexao:value("ambiente"))
		if empty(oDSN:value("empFil"))
			aAdd(aParams, oConexao:value("empresa"))
			aAdd(aParams, oConexao:value("filial"))
		else
			aAdd(aParams, dwEmpresa(poDSN:value("empFil")))
			aAdd(aParams, dwFilial(poDSN:value("empFil")))
		endif
		aAdd(aParams, poDSN:value("alias"))
		aAdd(aParams, {})
		if poDSN:value("id_sqlstru") != 0
			aAdd(aParams, {1, "embedsql:"+poDSN:value("sqlstruc")})
		else
			aAdd(aParams, {1, "embedsql:"+poDSN:value("sql")})
		endif
		aAdd(aParams, {})
		aAdd(aParams, {})
		aAdd(aParams, DWDSTmpArq())
		aRet := DWWaitJob(JOB_IMPORTSIGA, aParams, , .t.)
	elseif poDSN:Value("tipo_conn") == TC_AP_DIRETO
		aAdd(aParams, oConexao:value("server", .t.))
		aAdd(aParams, oConexao:value("ambiente", .t.))
		
		if empty(poDSN:value("caminho"))
			aAdd(aParams, strTran(oConexao:value("caminho",.t.), "/", "\"))
		else
			aAdd(aParams, strTran(poDSN:value("caminho",.t.), "/", "\"))
		endif 

		aAdd(aParams, ParsePath(strTran(poDSN:value("arquivo",.t.), "/", "\"), "FILE"))		                     
		
		if empty(poDSN:value("empFil"))
			aAdd(aParams, oConexao:value("empresa"))
			aAdd(aParams, oConexao:value("filial"))
		else
			aAdd(aParams, dwEmpresa(poDSN:value("empFil")))
			aAdd(aParams, dwFilial(poDSN:value("empFil")))
		endif 
		
		aRet := DWWaitJob(JOB_BASEDIR, aParams,, .t.)
	endif

	if valtype(aRet) != "A" .or. valtype(atail(aRet)) != "A"
		aRet := {}
	endif

return aSort(aRet,,, { |x,y| x[1] < y[1] })

static function prepProc(anID)
	if anID != 0
		if !oDSN:seek(1, { anID } )
			dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwStr(anID)) //'Fonte de Dados'
		endif
		dwSetProp("id", anID, "h_dwdsn")
		dwSetProp("Tipo", oDSN:value("tipo"), "h_dwdsn")
		dwSetProp("ID_Table", oDSN:value("id_table"), "h_dwdsn")
	else
		dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwStr(anID)) //'Fonte de Dados'
	endif

return

static function procStep0(anID, aaFields)
	local oConexao := oSigaDW:Connections()
	local cNome := "", cDescricao := ""
	local aConexoes, cTipoOld, nConexao
	local cUpdMethod, cProcInv, cRptInval, cProcCons, lEmbedsql, lOptimizer
	local oDim := initTable(TAB_DIMENSAO) 
	local oCub := initTable(TAB_CUBESLIST)           
	
	if !(anID == 0)
		
		if !oDSN:seek(1, { anID } )
			dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwStr(anID)) //'Fonte de Dados'
		endif
		
		cNome        := oDSN:value("nome")
		cDescricao   := oDSN:value("descricao")
		cUpdMethod   := oDSN:value("updMethod")
		cProcInv     := oDSN:value("procInv")
		cRptInval    := oDSN:value("rptInval")
		nConexao     := oDSN:value("id_connect")
		cProcCons    := oDSN:value("procCons")
    	lEmbedsql    := oDSN:value("embedsql")
    	lOptimizer  := oDSN:value("optimizer")
		dwSetProp("id", anID)
		dwSetProp("Tipo", DwStr(oDSN:value("tipo")))
		dwSetProp("ID_Table", DwStr(oDSN:value("id_table")))
	else                    
		cNome      := ""
		cDescricao := ""
		cUpdMethod := UPDMET_DEFAULT
		cProcInv   := PROCINV_ALL
		cRptInval  := RPTINVAL_NONE
        lEmbedsql  := .f.
        lOptimizer := .f.
		if 	DWGetProp("Tipo") == OBJ_DIMENSION
			nConexao   := oDim:value("impCon")
		else
			nConexao   := oCub:value("impCon")			
		endif
		if HttpGet->action == AC_DSN_DIM_MANUT
			cProcCons  := .F.
		else
			cProcCons  := .T.
		endif          
	endif
	
	aConexoes := {}
	oConexao:Seek(2)
	while !oConexao:Eof() .and. oConexao:value("id_dw") == oSigaDW:DWCurrID()
		if !(cTipoOld == oConexao:value("TIPO"))
			cTipoOld := oConexao:value("TIPO")
			if cTipoOld == TC_AP_DIRETO
				aAdd(aConexoes, { STR0030, 0}) //"-Direto"
			elseif cTipoOld == TC_TOP_CONNECT
				aAdd(aConexoes, {"-Top-Connect", 0})
			else
				aAdd(aConexoes, { "-SX", 0})
			endif
		endif
		aAdd(aConexoes, { oConexao:value("nome"), oConexao:value("id") })
		oConexao:_Next()
	enddo
	                                                    
	makeHidden(aaFields, 'edEmbedsql'    , lEmbedsql)
	makeHidden(aaFields, 'edOptimizer'   , lOptimizer)
	makeField(aaFields, 'edNome'         , STR0014, .t., 'C', 12, 0,,cNome, .t.) //'Nome'
	makeField(aaFields, 'edDescricao'    , STR0015, .t., 'C', 80, 0,,cDescricao) //'Descriçã'
	makeCombo(aaFields, 'edId_connect'   , STR0004, .T., aConexoes,, nConexao) // 'Conexão'
	makeCombo(aaFields, 'edUpdMethod'    , STR0016, .T., UPDMET_LIST,, oDSN:value("UpdMethod")) //'Método Atualização'
	makeCombo(aaFields, 'edProcInv'      , STR0017, .T., PROCINV_LIST,, oDSN:value("ProcInv")) //'Proc. Inválidos'
	makeCombo(aaFields, 'edRptInval'     , STR0018, .T., dwComboOptions(RPTINV_OPTIONS),, oDSN:value("RptInval")) //'Rel. Inválidos'
	makeField(aaFields, 'edProcCons'     , STR0038, .T., 'L', 1, 0,, cProcCons)
return

static function procStep1(anID, aaFields)
	local aFields 	:= aaFields
	local oConexao	:= oSigaDW:Connections()
	
	makeShow(aFields, 'edDSDesc',STR0003, oDSN:value("nome") + '-' + oDSN:value("descricao")) //'Fonte'
	makeShow(aFields, 'edDSConector',STR0004, oDSN:value("connector")+'('+oDSN:value("tipo_text")+')') //'Conexão'

	if oDSN:value("tipo_conn") == TC_TOP_CONNECT
		makeShow(aFields, 'edDSServer'  , STR0007, oDSN:value("server") + "/" + oDSN:value("banco_srv") + "/" + oDSN:value("aliastop")) //'Banco/Alias'
		makeHidden(aFields, "edID_SQL", oDSN:value("id_sql"))
		makeDotField(aFields, "edSQL", STR0005, .t., "M", 4, iif(isNull(HttpGet->dw_step), 0,25),, oDSN:value("sql")) //"SQL (dados)"
		makeHidden(aFields, "edID_SQLStru", oDSN:value("id_sqlStru"))
		makeDotField(aFields, "edSQLStruc", STR0006, .f., "M", 4, iif(isNull(HttpGet->dw_step), 0,25),, oDSN:value("sqlstruc")) //"SQL (estrutura)"
		if (oDSN:value("banco_srv") == DB_ORACLE .AND. DWTopDB() == DB_ORACLE) .or. ;
		   (oDSN:value("banco_srv") == DB_INFORMIX .AND. DWTopDB() == DB_INFORMIX)
			makeField(aFields, "edOptimizer", STR0039+"*", .F., 'L', 1, 0,, oDSN:value("Optimizer"))
		  if (oDSN:value("banco_srv") == DB_ORACLE .AND. DWTopDB() == DB_ORACLE)
			  makeText(aFields, "*"+STR0042)
		else
			  makeText(aFields, "*"+STR0045) //"ATENÇÃO: Para que esta operação seja concluída com sucesso é necessário <br>que a tabela origem possa ser acessar através de uma 'view' ou outro artifício e a sua estruta seja a mesma da table origem."
		endif
	else
			makeHidden(aFields, "edOptimizer", CHKBOX_OFF)
		endif
	else
		makeHidden(aFields, "edOptimizer", CHKBOX_OFF)
		oConexao:Seek(1, { oDSN:value("id_connect") })
		if oConexao:EoF() .OR. !(oConexao:value("id") == oDSN:value("id_connect"))
			dwRaise(ERR_005, SOL_003, STR0008 + ' ID=' + dwStr(oDSN:value("id_connect"))) //'Fonte de Dados'
		endif
		
		if oDSN:value("tipo_conn") == TC_AP_SX    
			makeShow(aFields, 'edDSAmbiente', STR0009, oConexao:value("server") + "/" + oConexao:value("ambiente")) //'Servidor/Ambiente'
		
			if empty(oDSN:value("empFil"))
#ifdef VER_P10
				makeField(aFields, 'edEmpFil' , STR0010, .T., 'C', 5, 0,,oConexao:value("empresa")+"/"+oConexao:value("filial")) //'Empresa/Filial'
#else
				makeField(aFields, 'edEmpFil' , STR0010, .T., 'C', 15, 0,,oConexao:value("empresa")+"/"+oConexao:value("filial")) //'Empresa/Filial'
#endif
			else
#ifdef VER_P10
				makeField(aFields, 'edEmpFil' , STR0010, .T., 'C', 5, 0,,oDSN:value("empFil")) //'Empresa/Filial'
#else
				makeField(aFields, 'edEmpFil' , STR0010, .T., 'C', 15, 0,,oDSN:value("empFil")) //'Empresa/Filial'
#endif
			endif

			makeField(aFields, 'edAlias'    , STR0011, .F., 'C', 3, 0,, oDSN:value("alias")) //'Alias'
			makeField(aFields, 'edEmbedSQL', STR0052, .F., 'L', 1, 0,, oDSN:value("embedsql")) //"Embedded SQL"
			makeHidden(aFields, "edID_SQL", oDSN:value("id_sql"))
			makeDotField(aFields, "edSQL", STR0053, .t., "M", 4, iif(isNull(HttpGet->dw_step), 0,25),, oDSN:value("sql")) //"Comando Embedded SQL"
		else
			makeShow(aFields , 'edDSAmbiente', STR0009, oConexao:value("server") + "/" + oConexao:value("ambiente")) //'Servidor/Ambiente'

			//##P11
			if empty(oDSN:value("empFil"))
#ifdef VER_P10
				makeField(aFields, 'edEmpFil' , STR0010, .T., 'C', 5, 0,,oConexao:value("empresa")+"/"+oConexao:value("filial")) //'Empresa/Filial'
#else
				makeField(aFields, 'edEmpFil' , STR0010, .T., 'C', 15, 0,,oConexao:value("empresa")+"/"+oConexao:value("filial")) //'Empresa/Filial'
#endif
			else
#ifdef VER_P10
				makeField(aFields, 'edEmpFil' , STR0010, .T., 'C', 5, 0,,oDSN:value("empFil")) //'Empresa/Filial'
#else
				makeField(aFields, 'edEmpFil' , STR0010, .T., 'C', 15, 0,,oDSN:value("empFil")) //'Empresa/Filial'
#endif
			endif
			makeField(aFields, 'edCaminho'   , STR0012, .t., "C",120, 0, , iif(!empty(oDSN:value("caminho")), oDSN:value("caminho"), oConexao:value("caminho"))) //'Caminho'
			makeField(aFields, 'edArquivo'   , STR0013, .T., 'C', 15, 0,,oDSN:value("arquivo")) //'Arquivo'
		endif
	endif

	makeHidden(aFields, "edID_Filter", oDSN:value("id_filter"))
	makeDotField(aFields, "edFilter", STR0021, .f., "M", 4, iif(isNull(HttpGet->dw_step), 0,25),, oDSN:value("filter")) //"Filtro"
	makeHidden(aFields, "edID_ForZap", oDSN:value("id_forZap"))
	makeDotField(aFields, "edForZap", STR0031, .f., "M", 4, iif(isNull(HttpGet->dw_step), 0,25),, oDSN:value("forZap")) //"Cond.Limpeza"

return

static function procStep1a()
	local aBuffer := {}
	
	if !(DwVal(httpGet->ID) == 0)
		httpSession->EDT_PARAM_DSN := .T.
		httpSession->ID_DSN := httpGet->ID
	endif
	aAdd(aBuffer, procStep1b())
	aAdd(aBuffer, tagJS())
	aAdd(aBuffer, "function edSQL_dot(oSender)")
	aAdd(aBuffer, "{")
	if oDSN:value("tipo_conn") == TC_AP_SX
		aAdd(aBuffer, "  var cAlias = getElement('edAlias').value;")
		aAdd(aBuffer, "  var lEmbedded = getElement('edEmbedSQL').checked;")
		aAdd(aBuffer, "  var cEmpFil = getElement('edEmpFil').value;")
		aAdd(aBuffer, "  if (lEmbedded) ")
		aAdd(aBuffer, "  		edSQL_exec('" + STR0019 + "', getObject('edID_SQL').value, -1, 'edID_SQL', 'edSQL', lEmbedded, cAlias, cEmpFil,'"+CHKBOX_ON+"');") //"SQL de dados"
		aAdd(aBuffer, "  else ")
		aAdd(aBuffer, "     alert('" + STR0044 + "') ") //"Edição habilitada somente quando o check box Embedded SQL estiver selecionado."
  else
		aAdd(aBuffer, "  edSQL_exec('" + STR0019 + "', getObject('edID_SQL').value, -1, 'edID_SQL', 'edSQL');") //"SQL de dados"
	endif
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "function edSQLStruc_dot(oSender)")
	aAdd(aBuffer, "{")
	aAdd(aBuffer, "	  edSQL_exec('" + STR0020 + "', getObject('edID_SQLStru').value, getObject('edID_SQL').value, 'edID_SQLStru', 'edSQLStruc');") //"SQL de estrutura"
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "function edFilter_dot(oSender)")
	aAdd(aBuffer, "{")
	if oDSN:value("tipo_conn") == TC_TOP_CONNECT
		aAdd(aBuffer, "edSQL_exec('" + STR0021 + "', getObject('edID_Filter').value, 0, 'edID_Filter', 'edFilter');") // "Filtro"
	else
		aAdd(aBuffer, "edADVPL_exec('" + STR0021 + "', getObject('edID_Filter').value, 0, 'edID_Filter', 'edFilter');") //"Filtro"
	endif
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "function edForZap_dot(oSender)")
	aAdd(aBuffer, "{")
	aAdd(aBuffer, "	edSQL_exec('" + STR0022 + "', getObject('edID_ForZap').value, 0, 'edID_ForZap', 'edForZap');") //"Condição de limpeza"
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "</script>")

return dwConcatWSep(CRLF, aBuffer)

static function procStep1b()
	local aBuffer := {}
	
	aAdd(aBuffer, tagJS())
	aAdd(aBuffer, "function edSQL_exec(acCaption, anIDSQL, anIDSQLBase, acTargetID, acTargetText, alEmbedded, acAlias, acEmpFil, acSample)")
	aAdd(aBuffer, "{")
	aAdd(aBuffer, "  doEditSQL(acCaption, anIDSQL, anIDSQLBase, acTargetID, acTargetText, "+dwStr(DWGetProp("Tipo", "h_dwdsn"), .t.)+","+dwStr(DWGetProp("id_table", "h_dwdsn"))+",alEmbedded, acAlias, acEmpFil, acSample);")
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "function edADVPL_exec(acCaption, anIDSQL, anIDSQLBase, acTargetID, acTargetText)")
	aAdd(aBuffer, "{")
	aAdd(aBuffer, "  doEditAdvpl(acCaption, anIDSQL, anIDSQLBase, acTargetID, acTargetText, "+dwStr(DWGetProp("Tipo", "h_dwdsn"), .t.)+","+dwStr(DWGetProp("id_table", "h_dwdsn"))+");")
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "</script>")

return dwConcatWSep(CRLF, aBuffer)	

static function procStep2(anID, aaFields)
	local aFields := aaFields

	makeShow(aFields, 'edDSDesc',STR0003, oDSN:value("nome") + '-' + oDSN:value("descricao")) //'Fonte'
	makeShow(aFields, 'edDSConector',STR0004, oDSN:value("connector")+'('+oDSN:value("tipo_text")+')') //'Conexão'

	makeField(aFields, 'edRecLimit'  , STR0023, .F., 'N', 8, 0,, oDSN:value("recLimit")) //"Limite Regs."
	makeHidden(aFields, "edID_B_Exec", oDSN:value("id_b_exec"))
	makeDotField(aFields, "edBeforeExec", STR0026, .f., "M", 4, iif(isNull(HttpGet->dw_step), 0,25),, oDSN:value("beforeExec")) //"Ao Iniciar"
	makeHidden(aFields, "edID_valida", oDSN:value("id_valida"))
	makeDotField(aFields, "edValida", STR0027, .f., "M", 4, iif(isNull(HttpGet->dw_step), 0,25),, oDSN:value("valida")) //"Validação"
	makeHidden(aFields, "edID_A_Exec", oDSN:value("id_a_exec"))
	makeDotField(aFields, "edAfterExec", STR0028, .f., "M", 4, iif(isNull(HttpGet->dw_step), 0,25),, oDSN:value("afterExec")) //"Ao Terminar"

return

static function procStep2a()
	local aBuffer := {}
	
	aAdd(aBuffer, procStep1b())
	aAdd(aBuffer, tagJS())
	aAdd(aBuffer, "function edBeforeExec_dot(oSender)")
	aAdd(aBuffer, "{")
	aAdd(aBuffer, "  edADVPL_exec('" + STR0026 + "', getObject('edID_B_Exec').value, 0, 'edID_B_Exec', 'edBeforeExec');") //'Evento: Ao Iniciar'
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "function edValida_dot(oSender)")
	aAdd(aBuffer, "{")
	aAdd(aBuffer, "  edADVPL_exec('" + STR0027 + "', getObject('edID_valida').value, 0, 'edID_valida', 'edValida');") //'Evento: Ao Validar'
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "function edAfterExec_dot(oSender)")
	aAdd(aBuffer, "{")
	aAdd(aBuffer, "  edADVPL_exec('" + STR0028 + "', getObject('edID_A_Exec').value, 0, 'edID_A_Exec', 'edAfterExec');") //"Evento: Ao Terminar"
	aAdd(aBuffer, "}")
	aAdd(aBuffer, "</script>")

return dwConcatWSep(CRLF, aBuffer)

static function procStep3(anID, aaCols, aaItens)
	local aCols := aaCols
	local aItens := aaItens
	local oQuery, aFromList, aFromList2, aOrigField := {}
	local nInd
	local aCandFields
	
	if oDSN:value("tipo") == OBJ_DIMENSION 
		oQuery := InitQuery(SEL_DSNCONF)
	else
		oQuery := InitQuery(SEL_DSNCONF2)
	endif
	oQuery:params(1, oDSN:value("ID_Table"))
	oQuery:params(2, oDSN:value("ID"))
	oQuery:Open()

	aFromList := rotStruct(oDSN)
	
	while !oQuery:eof()     
		aItem := array(6)
		aItem[5] := oQuery:value("id_dsnconf")
		aItem[6] := oQuery:value("id_field")
		aItem[1] := oQuery:value("nome")
		if oDSN:value("tipo") == OBJ_DIMENSION 
			aItem[1] += iif(oQuery:value("keyseq")>0, "("+dwStr(oQuery:value("keyseq"))+")","")
		endif
		aItem[1] += "[" + oQuery:value("tipo") + ", " + dwStr(oQuery:value("tam")) + "." + dwStr(oQuery:value("ndec")) + " ]"
		aItem[2] := iif(!empty(oQuery:value("cpoOrig")), oQuery:value("cpoOrig"), oQuery:value("nome"))
		
		aFromList2 := {}
		aAdd(aFromList2, { "", STR0035 }) /*"Favor selecionar"*/
 		aAdd(aFromList2, { STR0036, "" }) /*"-Candidatos"*/
		
		aCandFields := {}
		aCandFields := findCandidateFields(aFromList, oQuery:value("nome"))
		for nInd := 1 to len(aCandFields)
			nPos := aScan(aFromList, {|aElem| aElem[2] == aCandFields[nInd, 1]})
			if nPos > 0
			 	aAdd(aFromList2, { aCandFields[nInd, 1]+ "[" + dwStr(aFromList[nPos, 4]) + ;
						", " + dwStr(aFromList[nPos,5]) + "." + dwStr(aFromList[nPos, 6]) + " ]", aFromList[nPos][1] })
			endif
		next
		
		aAdd(aFromList2, { STR0037, "" }) /*"-Campos"*/
		for nInd := 1 to len(aFromList)        
			aAdd(aFromList2, { aFromList[nInd, 2]+ "[" + aFromList[nInd,4] + ;
								   ", " + dwStr(aFromList[nInd,5]) + "." + dwStr(aFromList[nInd,6]) + " ]", aFromList[nInd, 1]})
		next
		                                   
		if oDSN:value("tipo") == OBJ_DIMENSION 
	        if ( oQuery:value("keyseq")>0 ) 
    	    	nPos := ascan(aFromList2, { |x| substr(x[1], 1,at("[", trim(x[1]))-1)== aItem[2]})
        	else
        		nPos := ascan(aFromList2, { |x| substr(x[1], 1,at("[", trim(x[1]))-1)== aItem[2]})
	        endif
	 	else
			nPos := ascan(aFromList2, { |x| substr(x[1], 1,at("[", trim(x[1]))-1)== aItem[2]})	 		
		endif

		if nPos <> 0
			aItem[2] := aFromList2[nPos,2]
		else        
			aItem[2] := ""
		endif
		aItem[3] := oQuery:value("roteiro")
		if len(aItem[3]) > 20
		  aItem[3] := substr(aItem[3], 1, 20) + "..."
		endif
		aItem[4] := oQuery:value("id_roteiro")
				
		aAdd(aItens, aItem)
		
		// elimina elementos duplicados entre os campos candidatos e os demais campos
	   	DplArray(aFromList2, .T.)
		
		aAdd(aOrigField, aClone(aFromList2))
		
		oQuery:_Next()
	enddo        
	oQuery:Close()

	makeEditCol(aCols, EDT_SHOW     , "edCpo"     , STR0032, .t., "C", 30, 0) //"Campo (Chave)[Tipo]"
	makeEditCol(aCols, EDT_COMBO    , "edCpoOrig" , STR0033, .F., "P", 20, 0, aOrigField) //"Campo origem" 
	makeEditCol(aCols, EDT_EDIT     , "edRoteiro" , STR0029, .F., "C", 20, 0, , .T.) //"Roteiro"
	makeEditCol(aCols, EDT_HIDDEN   , "edIDRoteiro")
	makeEditCol(aCols, EDT_HIDDEN   , "edIDDSNConf")
	makeEditCol(aCols, EDT_HIDDEN   , "edIDField")
	
return

static function saveStep4()
	local aFromList := rotStruct(oDSN)
	local aFromList2 := {}, cAux
	local nInd, oDSNConf, nPos
	local nIDField, nIDDSNConf, nIDRoteiro
	
	for nInd := 1 to len(aFromList)
		aAdd(aFromList2, { aFromList[nInd, 2], aFromList[nInd, 1] })
	next

	//if oDSN:value("tipo") == OBJ_DIMENSION 
	//	oQuery := InitQuery(SEL_DSNCONF)
	//else
	//	oQuery := InitQuery(SEL_DSNCONF2)
	//endif
	
	//oQuery:params(1, oDSN:value("ID_Table"))
	//oQuery:params(2, oDSN:value("ID"))
	//oQuery:Open()
	oDSNConf := InitTable(TAB_DSNCONF)
                                        
    httpPost->_rowCount := dwVal(httpPost->_rowCount)
	for nInd := 1 to httpPost->_rowCount
		cAux := "httpPost->edIDDSNConf" + dwInt2Hex(nInd, 4)
		nIDDSNConf := dwVal(&(cAux))
		cAux := "httpPost->edIDField" + dwInt2Hex(nInd, 4)
		nIDField := dwVal(&(cAux))
		cAux := "httpPost->edIDRoteiro" + dwInt2Hex(nInd, 4)
		nIDRoteiro := dwVal(&(cAux))
		cAux := "httpPost->edCpoOrig" + dwInt2Hex(nInd, 4)
		cAux := &(cAux)         
		nPos := ascan(aFromList2, { |x| DWStr(x[2]) == cAux })
		if !oDSNConf:Seek(1,  { nIDDSNConf })
			if !(nIDRoteiro == 0) .or. !(aFromList2[nPos, 1] == oDSNConf:value("field"))
				oDSNConf:Append({ { "id_dsn", oDSN:value("ID") }, ;
									{ "id_field", nIDField }, ;
									{ "cpoorig", aFromList2[nPos, 1] } ,;
									{ "id_expr", nIDRoteiro } } )
			endif
        else
			if nIDRoteiro == 0 .and. aFromList2[nPos, 1] == oDSNConf:value("field")
				oDSNConf:Delete()
			else
				oDSNConf:Update({ { "cpoorig", aFromList2[nPos, 1] }, { "id_expr", nIDRoteiro } } )
			endif
		endif
    next
/*    

	while !oQuery:eof()
		if !oDSNConf:Seek(1,  { oQuery:value("id_dsnconf") })
			if !(aFromList2[nPos, 1] == oQuery:value("nome"))
				oDSNConf:Append({ { "id_dsn", oDSN:value("ID") }, ;
								{ "id_field", oQuery:value("ID_Field") }, ;
								{ "cpoorig", aFromList2[nPos, 1] } } )
			endif
		else
			if (aFromList2[nPos, 1] == oQuery:value("nome"))
				oDSNConf:Delete()
			else
				oDSNConf:Update({ { "cpoorig", aFromList2[nPos, 1] } } )
			endif
		endif
		nInd++
		oQuery:_Next()
	enddo
	oQuery:Close()
*/
	
return

/*
--------------------------------------------------------------------------------------
Verifica campos candidatos para um determinado campo. Candidatos serão aqueles campos 
que tiverem equivalência semântica ou sintática.

Equivalência sintática ocorrerá quando o campo candidato tiver uma determinada sequência
de letras em semelhança ao campo de comparação/origem. Essa sequência de
caracteres deverá ser de no mínimo 2 caracteres ou na totalidade de caracteres 
para ocorrer a equivalência entre o campo candidato e o campo de comparação/origem.

Equivalência semántica ocorrerá quando o campo candidato tiver uma determinada sequência
de letras em semelhança ao campo de comparação/origem. Essa sequência de caracteres
poderá ser de consoantes ou de vogais. Ex: codigo e cd (são equivalentes).
Essa sequência de caracteres deverá ser de no mínimo 2 caracteres ou na totalidade de caracteres 
para ocorrer a equivalência entre o campo candidato e o campo de comparação/origem.

Args: 	aaSourceList, array, contendo a lista de campos candidatos a serem comparados
		acFieldName, caracter, campo de comparação/origem
--------------------------------------------------------------------------------------
*/

#define CAND_EQUIV_100 		"EQ100"
#define CAND_EQUIV_2		"EQ002"
#define CAND_EQUIV_3		"EQ003"
#define CAND_EQUIV_4		"EQ004"
#define CAND_EQUIV_GREATER 	"EQ005"

static function findCandidateFields(aaSourceList, acFieldName)
	
	Local aDefCandList 	:= {}
	Local nInd, nInd2
	Local aVogal := { "A", "E", "I", "O", "U" }
	Local cFieldName
	Local aSourceList := aClone(aaSourceList)
	Local aAux := {}, nPos
	
	findSintaticCandidates(aDefCandList, aaSourceList, acFieldName)
	findSemanticCandidates(aDefCandList, aaSourceList, acFieldName)
	
	for nInd := 1 to len(aSourceList)
		// retira todas as consoantes para realizar a busca sintática equivalente por vogais
	 	cFieldAux := ""
	 	cFieldName := ""
		for nInd2 := 1 to len(acFieldName)
			if aScan(aVogal, {|cVogal| cVogal == substr(aSourceList[nInd][2], nInd2, 1)}) == 0
				cFieldName += substr(aSourceList[nInd][2], nInd2, 1)
			endif
		next
		aSourceList[nInd][3] := aSourceList[nInd][2]
		aSourceList[nInd][2] := cFieldName
	next
 	findSintaticCandidates(aAux, aSourceList, acFieldName)
 	findSemanticCandidates(aAux, aSourceList, acFieldName)
 	
 	for nInd := 1 to len(aAux)
 		nPos := aScan(aSourceList, { |aSrcElem| aSrcElem[2] == aAux[nInd][1] })
 		aAdd(aDefCandList, { aSourceList[nPos][3], aAux[nInd][2] })
 	next
	
 	DplArray(aDefCandList, .T.)
 	
 	// ordena o resultada da lista de candidatos pela 
 	aSort(aDefCandList, , , { |elem1, elem2| elem1[2] > elem2[2] })
 	
return aDefCandList

/*
--------------------------------------------------------------------------------------
Verifica campos candidatos para um determinado campo, considerando a sintática dos campos.
Equivalência sintática ocorrerá quando o campo candidato tiver uma determinada sequência
de letras em semelhança ao campo de comparação/origem. Essa sequência de
caracteres deverá ser de no mínimo 2 caracteres ou na totalidade de caracteres 
para ocorrer a equivalência entre o campo candidato e o campo de comparação/origem.

Args: 	aaDefCandList, array, contém a lista final definida com os campos candidatos
		aaSourceList, array, contendo a lista de campos candidatos a serem comparados
		acFieldName, caracter, campo de comparação/origem
--------------------------------------------------------------------------------------
*/
static function findSintaticCandidates(aaDefCandList, aaSourceList, acFieldName)
	
	Local nInd
	
	Local cCand
	Local cFieldName := upper(acFieldName)
	
	// separa os nomes dos campos que poderão ser considerados campos candidatos
	// realiza a lógica para descobrir os campos candidatos
	for nInd := 1 to len(aaSourceList)
		cCand := upper(aaSourceList[nInd][2])
		if cFieldName == cCand
			aAdd(aaDefCandList, { cCand, CAND_EQUIV_100 })
		else
			findEquivCandidate(aaDefCandList, cCand, cFieldName)
			findEquivCandidate(aaDefCandList, cFieldName, cCand, .t.)
		endif
 	next
 	
return

/*
--------------------------------------------------------------------------------------
Verifica a equivalência de um campo candidato para um determinado campo de origem,
considerando a sintática dos campos. Equivalência sintática ocorrerá quando o campo
candidato tiver uma determinada sequência de letras em semelhança ao campo de comparação/origem.
Essa sequência de caracteres deverá ser de no mínimo 2 caracteres ou na totalidade de caracteres 
para ocorrer a equivalência entre o campo candidato e o campo de comparação/origem.

Args: 	aaDefCandList, array, contém a lista final definida com os campos candidatos
		acCand, string, contém o campo candidato a ser verificado
		acFieldName, string, campo de comparação/origem
		alInvert, lógico, sinaliza qual dos campos deve-se colocar na lista final.
			TRUE para colocar o CAMPO DE ORIGEM na lista e FALSE para colocar o campo CANDIDATO
--------------------------------------------------------------------------------------
*/
static function findEquivCandidate(aaDefCandList, acCand, acFieldName, alInvert)
	Local nInd2, nInd3, nInd4
	Local cChar
	Local aSintEquiv
	
	default alInvert := .F.
	
	for nInd2 := 1 to len(acCand)
		nInd3 := nInd2
		cChar := ''
		
		aSintEquiv := {}
		for nInd4 := 1 to len(acFieldName)
			if !(substr(acCand, nInd3, 1) == "_" .OR. substr(acFieldName, nInd4, 1) == "_")
				if substr(acCand, nInd3, 1) == substr(acFieldName, nInd4, 1)
					cChar += substr(acCand, nInd3, 1)
				else
					Do Case
						Case len(cChar) == 3
							aAdd(aSintEquiv, CAND_EQUIV_3)
						Case len(cChar) == 4
							aAdd(aSintEquiv, CAND_EQUIV_4)
						Case len(cChar) > 4
							aAdd(aSintEquiv, CAND_EQUIV_GREATER)
					EndCase
					cChar := ''
					EXIT
				endif
			endif
			nInd3++
		next

		Do Case
			Case len(cChar) == 3
				aAdd(aSintEquiv, CAND_EQUIV_3)
			Case len(cChar) == 4
				aAdd(aSintEquiv, CAND_EQUIV_4)
			Case len(cChar) > 4
				aAdd(aSintEquiv, CAND_EQUIV_GREATER)
		EndCase
		
		if len(aSintEquiv) > 0
			aAdd(aaDefCandList, { iif(alInvert, acFieldName, acCand), DwConcatWSep(",", aSintEquiv) })
		endif
	next
return

/*
--------------------------------------------------------------------------------------
Verifica campos candidatos para um determinado campo, considerando a semântica dos campos.
Equivalência semántica ocorrerá quando o campo candidato tiver uma determinada sequência
de letras em semelhança ao campo de comparação/origem. Essa sequência de caracteres
poderá ser de consoantes ou de vogais. Ex: codigo e cd (são equivalentes).
Essa sequência de caracteres deverá ser de no mínimo 2 caracteres ou na totalidade de caracteres 
para ocorrer a equivalência entre o campo candidato e o campo de comparação/origem.

Args: 	aaDefCandList, array, contém a lista final definida com os campos candidatos
		aaSourceList, array, contendo a lista de campos candidatos a serem comparados
		acFieldName, caracter, campo de comparação/origem
--------------------------------------------------------------------------------------
*/
static function findSemanticCandidadtes(aaDefCandList, aaSourceList, acFieldName)
    
    Local nInd
    Local aVogal := { "A", "E", "I", "O", "U" }
    Local aNotConsoant := { "A", "E", "I", "U" }
    Local cFieldAux := ""
    Local cFieldName := upper(acFieldName)
    Local nPos
    
	// retira todas as vogais para realizar a busca sintática equivalente por consoantes. Exemplo Codigo fica CD
	cFieldAux := ""
	for nInd := 1 to len(cFieldName)
		if aScan(aVogal, {|cVogal| cVogal == substr(cFieldName, nInd, 1)}) == 0
			cFieldAux += substr(cFieldName, nInd, 1)
		endif
	next
	findSintaticCandidates(aaDefCandList, aaSourceList, cFieldAux)
	
	// retira todas as consoantes para realizar a busca sintática equivalente por vogais
 	cFieldAux := ""
	for nInd := 1 to len(cFieldName)
		if aScan(aVogal, {|cVogal| cVogal == substr(cFieldName, nInd, 1)}) > 0
			cFieldAux += substr(cFieldName, nInd, 1)
		endif
	next
	findSintaticCandidates(aaDefCandList, aaSourceList, cFieldAux)
	
return 

/*
--------------------------------------------------------------------------------------
Verifica a permissão de acesso do usuário logado à um determinado cubo.

Args: anCubeID, numérico, contém o id do cubo
Ret:  .T., caso tenha permissão, .F. caso contrário
--------------------------------------------------------------------------------------
*/
static function checkPermission(anCubeID)

	Local lEdit := .T.

	// verifica privilégio para dar manutenção (CASO não seja administrador)
	if !oUserDW:UserIsAdm()
		lEdit := oUserDW:GetCubMaintPerm(HttpSession->CurrentDW, anCubeID)
		// exibe msg de que o usuário não possui permissão
		if !lEdit
			HttpSession->DWErrMsg := STR0034 //"Atenção: usuário não possui privilégio de manutenção deste cubo."
		endif
	endif
			
return lEdit