<%
// ######################################################################################
// Projeto: DATA WAREHOUSE
// Modulo : Actions
// Fonte  : dwToolClean - Limpeza do Datawarehouse
// ---------+-------------------+--------------------------------------------------------
// Data     | Autor             | Descricao
// ---------+-------------------+--------------------------------------------------------
// 18.11.05 |2481-Paulo R Vieira| Migração para novo layout Fase 3
// 17.04.08 |0548-Alan Cândido  | BOPS 1444476 - correção na chamada de função para geração
//          |                   | do código de confirmação (de "buildConfirmationCode" para
//          |                   | "buildConfCode")
// --------------------------------------------------------------------------------------

#include "dwincs.ch"
#include "dwToolClean.ch"

#define PREFIX_DW_PACK			    "cPackDW"
#define PREFIX_DIM_CONTENTS		  "cDC"
#define PREFIX_DIM_DEFINTION	  "cDD"
#define PREFIX_CUB_CONTENTS		  "cCC"
#define PREFIX_CUB_DEFINTION	  "cCD"
#define PREFIX_QRY_PREDEF_TABLE	"cPT"
#define PREFIX_QRY_PREDEF_GRAPH	"cPG"
#define PREFIX_QRY_USER_TABLE	  "cUT"
#define PREFIX_QRY_USER_GRAPH   "cUG"

local lDimensao := HttpSession->Dimensions
local lCubo 		:= HttpSession->Cubes
local lConsulta := HttpSession->Queries

<%= buildTCleanInSteps(lDimensao, lCubo, lConsulta) %>

<%
/*
--------------------------------------------------------------------------------------
Monta a página de ferramentas com passo a passo para limpeza do data warehouse
Args: alDimensao, booleano, contendo se deve ou não exibir as dimensões
		alCubo, booleano, contendo se deve ou não exibir os cubos
		alConsulta, booleano, contendo se deve ou não exibir as consultas
--------------------------------------------------------------------------------------
*/
static function buildTCleanInSteps(alDimensao, alCubo, alConsulta)

	Local cFunctionReturn
	Local nStep := iif (!(valType(HttpPost->dw_step) == "C"), 1, DWVal(HttpPost->dw_step))
	Local nConfCode	:= randByTime() // Gera um código aleatório de confirmação.
	Local cMsgAttention := ""

	cMsgAttention := STR0023 + "<br>" + STR0024 + buildConfCode(nConfCode) //'ATENÇÂO: Ao acionar "próximo", lhe será solicitado um código de confirmação.'###'O Código de confirmação é '

	Do Case
		Case nStep == 1
			cFunctionReturn := buildTCFirstStep(alDimensao, alCubo, alConsulta, nConfCode)
			cFunctionReturn += makeAttention(, cMsgAttention) // Adiciona a mensagem ao formulário.
		Case nStep == 2
			cFunctionReturn := buildTCSecondStep(nConfCode)			
			cFunctionReturn += makeAttention(, cMsgAttention) // Adiciona a mensagem ao formulário.
		Case nStep == 3
			cFunctionReturn := buildTCThirdStep()
	EndCase

return cFunctionReturn

/*
--------------------------------------------------------------------------------------
Monta a página de exibição da limpeza do data warehouse
Args: alDimensao, booleano, contendo se deve ou não exibir as dimensões
		alCubo, booleano, contendo se deve ou não exibir os cubos
		alConsulta, booleano, contendo se deve ou não exibir as consultas
		nConfCode, numérico, número aleatório para deleção.
--------------------------------------------------------------------------------------
*/
function buildTCFirstStep(alDimensao, alCubo, alConsulta, nConfCode)
	
	Local aBuffer 		:= {}
	Local aButtons		:= {}
	Local oQuery, lHaveTable, lHaveGraph
	Local nIDSel 		:= 0
	Local aChecksOnSubmit
	Local bJavaScript
	Local cTitle
	Local aTemp
	Local aTableHeader
	Local cMsgNotFound := STR0001 //"Não existem dados para serem visualizados"
	Local lShowNotFound := .T.
	Local lDisplQueryTitle
	Local cID
	Local cOper 		:= OP_STEP
	Local cHtml
	Local aAux, nInd

	Default nConfCode := ""
	
	// título da página
	cTitle := STR0002	 //"Limpeza do Datawarehouse"
	
	makeBlankRow(aBuffer)
	
	makeText(aBuffer, STR0003) //"Selecione cubos, dimensões, fatos e definições a serem removidas"
	
	makeBlankRow(aBuffer)
	
	// Apresenta o Datawarehouse e a opção compactação do DW
	aTemp := {}
	if alDimensao .and. alCubo .and. alConsulta
		makeTitle(aBuffer, STR0004) //"Datawarehouse"
		aTableHeader := { makeHCheckField(NIL, PREFIX_DW_PACK + "All", STR0005+"<br>"+STR0027+"<br>"+STR0028, .F., .F.) } //"Compactar"###"ESTA OPÇÂO ELIMINA OS REGISTROS FISICAMENTE, FAÇA UMA CÓPIA DE SEGURANÇA DA BASE DE DADOS DO SIGADW PRIMEIRO."###"Habilite a chave 'doCompact', para o procedimento ser executado."
    	aAdd(aTemp, { makeHCheckField(NIL, PREFIX_DW_PACK + DwStr(oSigaDW:DWCurr()[1]), DwStr(oSigaDW:DWCurr()[1]) + " - " + oSigaDW:DWCurr()[2], .F., NIL, oSigaDW:DWCurr()[1])  } )
		makeText(aBuffer, displayData( aTemp, 1, aTableHeader ))
	endif
	
	// Apresenta Dimensões
	if alDimensao
		aAux := DWDetail(TAB_DIMENSAO, -1, { || { alltrim(descricao) + " ( " + alltrim(nome)+ " )", id, nome }}, NIL, 5, oSigaDw:DWCurrID())
		aAux := aSort(aAux,,, { |x,y| x[1] < y[1]})
		
		if valType(aAux) == "A" .AND. len(aAux) > 0
			lShowNotFound := .F.
			makeTitle(aBuffer, STR0006) //"Dimensões"

			// cabeçalho
			aTableHeader := { makeHCheckField(NIL, "cDCAll", STR0007, .F., .F.), ; //"Conteúdos"
                        makeHCheckField(NIL, "cDDAll", STR0008, .F., .F.), "" } //"Definições"
			aTemp := {}
			for nInd := 1 to len(aAux)
				cID := DwStr(aAux[nInd][2])
				aAdd(aTemp, { makeHCheckField(NIL, PREFIX_DIM_CONTENTS + cID, "", .F., .T., NIL, cID), ;
								makeHCheckField(NIL, PREFIX_DIM_DEFINTION + cID, "", .F., .T., NIL, cID), ;
								 cID + " " + aAux[nInd][1] })
			next
			
			// exibe na página
			makeText(aBuffer, displayData(aTemp, 3, aTableHeader, , {0.15, 0.15, 0.7} ))
		endif
	endif
	     
	// Apresenta Cubos
	if alCubo
		aAux := DWDetail(TAB_CUBESLIST, -1, { || { alltrim(descricao) + " ( " + alltrim(nome)+ " )", id, nome }}, NIL, 5, oSigaDw:DWCurrID())
		aAux := aSort(aAux,,, { |x,y| x[1] < y[1]})
		if valType(aAux) == "A" .AND. len(aAux) > 0
			lShowNotFound := .F.
			makeTitle(aBuffer, STR0009) //"Cubos"
			
			// cabeçalho
			aTableHeader := { makeHCheckField(NIL, "cCCAll", STR0007, .F., .F.), ; //"Conteúdos"
										makeHCheckField(NIL, "cCDAll", STR0008, .F., .F.), "" } //"Definições"
			aTemp := {}
			
			for nInd := 1 to len(aAux)
				cID := DwStr(aAux[nInd][2])
				aAdd(aTemp, { makeHCheckField(NIL, PREFIX_CUB_CONTENTS + cID, "", .F., .T., NIL, cID), ;
								makeHCheckField(NIL, PREFIX_CUB_DEFINTION + cID, "", .F., .T., NIL, cID), ;
								cID + " " + aAux[nInd][1] })
			next
			
			// exibe na página
			makeText(aBuffer, displayData(aTemp, 3, aTableHeader, , {0.15, 0.15, 0.7}))
		endif
	endif
	
	// Apresenta Consultas
	if alConsulta
		aTemp := {}
		lDisplQueryTitle := .F.
		
		// itera pelas consultas, verificando para cada consulta o privilégio do usuário
		aAux := DWDetail(TAB_CONSULTAS, QUERY_PREDEF, { || { DwStr(id) + " " + alltrim(descricao) + " ( " + alltrim(nome)+ " )", id, nome }}, "tipo", 5, oSigaDw:DWCurrID())
		aAux := aSort(aAux,,, { |x,y| x[1] < y[1]})
 		for nInd := 1 to len(aAux)
			lShowNotFound 		:= .F.
			lDisplQueryTitle 	:= .T.
			cID := DwStr(aAux[nInd][2])
			
			aAdd(aTemp, { makeHCheckField(NIL, PREFIX_QRY_PREDEF_TABLE + cID, "", .F., .T., NIL, cID), ;
							makeHCheckField(NIL, PREFIX_QRY_PREDEF_GRAPH + cID, "", .F., .T., NIL, cID), ;
								aAux[nInd][1] })
		next
		
		if lDisplQueryTitle
			makeTitle(aBuffer, STR0010) //"Consultas Pre-definidas"
			// cabeçalho
			aTableHeader := { makeHCheckField(NIL, "cPTAll", STR0011, .F., .F.), ; //"Tabelas"
										makeHCheckField(NIL, "cPGAll", STR0012, .F., .F.), "" } //"Gráficos"
			// exibe na página
			makeText(aBuffer, displayData(aTemp, 3, aTableHeader, , {0.15, 0.15, 0.7}))
		endif

		aTemp := {}
	 	lDisplQueryTitle := .F.
		aAux := DWDetail(TAB_CONSULTAS, QUERY_USER, { || { DwStr(id) + " " + alltrim(descricao) + " ( " + alltrim(nome)+ " )", id, nome }}, "tipo", 5, oSigaDw:DWCurrID())
		aAux := aSort(aAux,,, { |x,y| x[1] < y[1]})
 		for nInd := 1 to len(aAux)
			lDisplQueryTitle := .T.
			lShowNotFound := .F.
			cID := DwStr(aAux[nInd][2])
			
			aAdd(aTemp, { makeHCheckField(NIL, PREFIX_QRY_USER_TABLE + cID, "", .F., .T., NIL, cID), ;
								makeHCheckField(NIL, PREFIX_QRY_USER_GRAPH + cID, "", .F., .T., NIL, cID), ;
									aAux[nInd][1] })
		next

		if lDisplQueryTitle
			makeTitle(aBuffer, STR0013) //"Consultas de Usuários"
			// cabeçalho
			aTableHeader := { makeHCheckField(NIL, "cUTAll", STR0011, .F., .F.), ; //"Tabelas"
										makeHCheckField(NIL, "cUGAll", STR0012, .F., .F.), "" } //"Gráficos"
			// exibe na página
			makeText(aBuffer, displayData(aTemp, 3, aTableHeader, , {0.15, 0.15, 0.7}))
		endif
		
	endif

	makeHidden(aBuffer, "dw_step", "2")
   
	// monta a função JavaScript para validar a seleção de algum checkbox e validar o código de confirmação
	aChecksOnSubmit := {}
	aAdd(aChecksOnSubmit, 'var lCheckSelected = false;')
	aAdd(aChecksOnSubmit, 'var oElements = getElement("frmTools").elements;')
	aAdd(aChecksOnSubmit, 'for (var nInd = 0; nInd < oElements.length; nInd++) {')
	aAdd(aChecksOnSubmit, '	if (oElements[nInd].type == "checkbox" && oElements[nInd].checked) {')
	aAdd(aChecksOnSubmit, '		lCheckSelected = true;')
 	aAdd(aChecksOnSubmit, '	}')
	aAdd(aChecksOnSubmit, '}')
 	aAdd(aChecksOnSubmit, 'if (!lCheckSelected) {')
 	aAdd(aChecksOnSubmit, '	defineMessage("' + STR0014 + '");') //"Por favor, selecione pelo menos uma das opções"
 	aAdd(aChecksOnSubmit, '	return false;')
 	aAdd(aChecksOnSubmit, '}')
	aAdd(aChecksOnSubmit, 'if (!checkConfirmationCode("' + nConfCode + '")) {')
	aAdd(aChecksOnSubmit, '	return false;')
	aAdd(aChecksOnSubmit, '}')
   
	// verifica se existem dados para serem exibidos
	if lShowNotFound
		aBuffer 	:= {}
		aButtons	:= {}
		cOper		:= ""
		aChecksOnSubmit := { 'defineMessage("' + cMsgNotFound + '"); return false;' }
		makeTitle(aBuffer, cMsgNotFound)
	endif

   // define a blockcode que será utilizado na submissão do form
   bJavaScript		:= {|aBuffer, aaParams, alEdit| aAdd(aBuffer, dwConcatWSep(CRLF, aChecksOnSubmit))}

   // realiza a construção do código html de retorno entre divs de 80% de largura
   cHtml := buildCheckList('frmTools', cTitle, AC_TOOLS_CLEAN, cOper, aButtons, aBuffer, , , bJavaScript)
	
return cHtml

/*
--------------------------------------------------------------------------------------
Monta a página de confirmação da limpeza do data warehouse
Args:
--------------------------------------------------------------------------------------
*/
static function buildTCSecondStep(nConfCode)
	
	Local aBuffer 		:= {}
	Local aChecksOnSubmit
	Local aButtons		:= {}
	Local bJavaScript
	Local cTitle
	Local aTemp
	Local aTableHeader
	Local cPostName, cPostValue
	Local cContent, cDefinition
	Local oDWClean 	:= TDWClean():New()
	Local aMsgs
	Local aAux, nInd

	Default nConfCode := ""
	
	// título da página
	cTitle := STR0015 //"Confirmação de Limpeza do Datawarehouse"

	// cabeçalho
	aTableHeader := { STR0007, STR0008, "" } //"Conteúdos"###"Definições"

	makeBlankRow(aBuffer)
	
	makeText(aBuffer, STR0016) //"Confirme ou não o processamento. Uma vez executado, näo ha como desfazer os procedimentos."
	
	makeBlankRow(aBuffer)
	
	makeWarning(aBuffer, STR0025 + STR0026) //"Antes de confirmar a execucäo deste procedimento, recomendamos que seja efetuado uma copia"###"de seguranca da base de dados."
	
	makeBlankRow(aBuffer)
	
	aTemp := {}	
	// Apresenta o Datawarehouse escolhido para a compactação (caso tenha sido escolhida a opção)
  cPostName	:= PREFIX_DW_PACK + DwStr(oSigaDW:DWCurr()[1])
	cPostValue 	:= &("HttpPost->" + cPostName)
	makeTitle(aBuffer, STR0004) //"Datawarehouse"
	if valType(cPostValue) == "C"
		aAdd(aTemp, { STR0018 + " " + DwStr(oSigaDW:DWCurr()[1]) + " - " + oSigaDW:DWCurr()[2] }) //"Sim"
		makeHidden(aBuffer, cPostName, cPostValue)
	endif
  
  makeText(aBuffer, displayData( aTemp, 1, {STR0005+"<br>"+STR0027 } )) //"Compactar"###"ESTA OPÇÂO ELIMINA OS REGISTROS FISICAMENTE, FAÇA UMA CÓPIA DE SEGURANÇA DA BASE DE DADOS DO SIGADW PRIMEIRO."
	
	// Apresenta DIMENSÕES escolhidas para a limpeza (caso tenha sido escolhida a opção)
	aTemp := {}
	aAux := DWDetail(TAB_DIMENSAO, -1, { || { DwStr(id) + " " + alltrim(descricao) + " ( " + alltrim(nome) + " )", id, nome }}, NIL, 5, oSigaDw:DWCurrID())
	aAux := aSort(aAux,,, { |x,y| x[1] < y[1]})
	
	for nInd := 1 to len(aAux)
	   	cContent 	:= NIL
	   	cDefinition 	:= NIL
	   
	   	// verifica a opção de limpeza de conteúdo/dados de dimensão
	   	cPostName	:= PREFIX_DIM_CONTENTS + DwStr(aAux[nInd][2])
		cPostValue 	:= &("HttpPost->" + cPostName)
		if !(valType(cPostValue) == "U")
			// define o label que aparecerá na página
			cContent := STR0018 //"Sim"
			
			// cria a variável como hidden
			makeHidden(aBuffer, PREFIX_DIM_CONTENTS, cPostValue)
		endif
		
		// verifica a opção de limpeza de definição/tabela de dimensão
	   	cPostName	:= PREFIX_DIM_DEFINTION + DwStr(aAux[nInd][2])
		cPostValue 	:= &("HttpPost->" + cPostName)
		if !(valType(cPostValue) == "U")
			// define o label que aparecerá na página
			cDefinition := STR0018 //"Sim"
			
			// cria a variável como hidden
			makeHidden(aBuffer, PREFIX_DIM_DEFINTION, cPostValue)
		endif
		
		// acrescenta no array de exibição caso tenha sido escolhida alguma opção para esta dimensão
		if valType(cContent) == "C" .or. valType(cDefinition) == "C"
			aAdd(aTemp, { cContent, cDefinition, aAux[nInd][1] })
			aMsgs := {}
			oDWClean:checkCubesImpacts(aAux[nInd][2], { |text| aAdd(aMsgs, "<li>" + text + "</li>") } )
			if len(aMsgs) > 0
				aAdd(aTemp, { STR0019 + "<ul>" + DwConcat(aMsgs) + "</ul>" }) //"Os seguintes Cubos serão afetados: "
			endif
		endif
	next
	
	if len(aTemp) > 0
		makeTitle(aBuffer, STR0006) //"Dimensões"
		
		// exibe na página
		makeText(aBuffer, displayData(aTemp, 3, aTableHeader, , {0.15, 0.15, 0.7}))
	endif
	
	// Apresenta CUBOS escolhidos para a limpeza (caso tenha sido escolhida a opção)
	aTemp := {}
	aAux := DWDetail(TAB_CUBESLIST, -1, { || { DwStr(id) + " " + alltrim(descricao) + " ( " + alltrim(nome) + " )", id, nome }}, NIL, 5, oSigaDw:DWCurrID())
	aAux := aSort(aAux,,, { |x,y| x[1] < y[1]})
	
	for nInd := 1 to len(aAux)
	   cContent 	:= NIL
	   cDefinition := NIL
	   
	   // verifica a opção de limpeza de conteúdo/dados de cubo
	   cPostName	:= PREFIX_CUB_CONTENTS + DwStr(aAux[nInd][2])
		cPostValue 	:= &("HttpPost->" + cPostName)
		if !(valType(cPostValue) == "U")
			// define o label que aparecerá na página
			cContent := STR0018 //"Sim"
			
			// cria a variável como hidden
			makeHidden(aBuffer, PREFIX_CUB_CONTENTS, cPostValue)
		endif
   	
		// verifica a opção de limpeza de definição/tabela de cubo
	   cPostName	:= PREFIX_CUB_DEFINTION + DwStr(aAux[nInd][2])
		cPostValue 	:= &("HttpPost->" + cPostName)
		if !(valType(cPostValue) == "U")
			// define o label que aparecerá na página
			cDefinition := STR0018 //"Sim"
			
			// cria a variável como hidden
			makeHidden(aBuffer, PREFIX_CUB_DEFINTION, cPostValue)
		endif
		
		// acrescenta ao array de exibição caso tenha sido escolhida alguma opção para este cubo específico
		if valType(cContent) == "C" .or. valType(cDefinition) == "C"
			aAdd(aTemp, { cContent, cDefinition, aAux[nInd][1] })
			aMsgs := {}
			oDWClean:checkQuerysImpacts(aAux[nInd][2], { |text| aAdd(aMsgs, "<li>" + text + "</li>") } )
			if len(aMsgs) > 0
				aAdd(aTemp, { STR0020 + "<ul>" + DwConcat(aMsgs) + "</ul>" }) //"As seguintes Consultas serão afetadas: "
			endif
		endif
	next
	
	if len(aTemp) > 0
		makeTitle(aBuffer, STR0009) //"Cubos"
		
		// exibe na página
		makeText(aBuffer, displayData(aTemp, 3, aTableHeader, , {0.15, 0.15, 0.7}))
	endif
	
	// Apresenta CONSULTAS PRÉ-DEFINIDAS escolhidas para a limpeza (caso tenha sido escolhida a opção)
	aTemp := {}
	aAux := DWDetail(TAB_CONSULTAS, QUERY_PREDEF, { || { DwStr(id) + " " + alltrim(descricao) + " ( " + alltrim(nome)+ " )", id, nome }}, "tipo", 5, oSigaDw:DWCurrID())
	aAux := aSort(aAux,,, { |x,y| x[1] < y[1]})
	for nInd := 1 to len(aAux)
		cContent 	:= NIL
	   	cDefinition := NIL
	   
	   	// verifica a opção de limpeza de tabela para consultas do tipo pré-definidas
	   	cPostName	:= PREFIX_QRY_PREDEF_TABLE + DwStr(aAux[nInd][2])
		cPostValue 	:= &("HttpPost->" + cPostName)
		if !(valType(cPostValue) == "U")
			// define o label que aparecerá na página
			cContent := STR0018 //"Sim"
			
			// cria a variável como hidden
			makeHidden(aBuffer, PREFIX_QRY_PREDEF_TABLE, cPostValue)
		endif
		
		// verifica a opção de limpeza de gráfico para consultas do tipo pré-definidas
	    cPostName	:= PREFIX_QRY_PREDEF_GRAPH + DwStr(aAux[nInd][2])
		cPostValue 	:= &("HttpPost->" + cPostName)
		if !(valType(cPostValue) == "U")
			// define o label que aparecerá na página
			cDefinition := STR0018 //"Sim"
			
			// cria a variável como hidden
			makeHidden(aBuffer, PREFIX_QRY_PREDEF_GRAPH, cPostValue)
		endif
	  	
	  	// acrescenta ao array de exibição caso tenha sido escolhida uma opção para este consulta específica
		if valType(cContent) == "C" .or. valType(cDefinition) == "C"
			aAdd(aTemp, { cContent, cDefinition, aAux[nInd][1] })
		endif
	next
	
	if len(aTemp) > 0
			makeTitle(aBuffer, STR0010) //"Consultas Pre-definidas"

			// exibe na página
			makeText(aBuffer, displayData(aTemp, 3, aTableHeader, , {0.15, 0.15, 0.7}))
	endif
	
	// Apresenta CONSULTAS DE USUÁRIOS escolhidas para a limpeza (caso tenha sido escolhida a opção)
	aTemp := {}	
	aAux := DWDetail(TAB_CONSULTAS, QUERY_USER, { || { DwStr(id) + " " + alltrim(descricao) + " ( " + alltrim(nome)+ " )", id, nome }}, "tipo", 5, oSigaDw:DWCurrID())
	aAux := aSort(aAux,,, { |x,y| x[1] < y[1]})
	for nInd := 1 to len(aAux)
		cContent 	:= NIL
	   	cDefinition := NIL
	   
	   	// verifica a opção de limpeza de tabela para consultas do tipo usuários
	   	cPostName	:= PREFIX_QRY_USER_TABLE + DwStr(aAux[nInd][2])
		cPostValue 	:= &("HttpPost->" + cPostName)
		if !(valType(cPostValue) == "U")
			// define o label que aparecerá na página
			cContent := STR0018 //"Sim"
			
			// cria a variável como hidden
			makeHidden(aBuffer, PREFIX_QRY_USER_TABLE, cPostValue)
		endif
		
		// verifica a opção de limpeza de gráfico para consultas do tipo usuários
	    cPostName	:= PREFIX_QRY_USER_GRAPH + DwStr(aAux[nInd][2])
		cPostValue 	:= &("HttpPost->" + cPostName)
		if !(valType(cPostValue) == "U")
			// define o label que aparecerá na página
			cDefinition := STR0018 //"Sim"
			
			// cria a variável como hidden
			makeHidden(aBuffer, PREFIX_QRY_USER_GRAPH, cPostValue)
		endif
	   
  	  	// acrescenta ao array de exibição caso tenha sido escolhida uma opção para este consulta específica
		if valType(cContent) == "C" .or. valType(cDefinition) == "C"
			aAdd(aTemp, { cContent, cDefinition, aAux[nInd][1] })
		endif
	next
	
	if len(aTemp) > 0
		makeTitle(aBuffer, STR0013) //"Consultas de Usuários"

		// exibe na página
		makeText(aBuffer, displayData(aTemp, 3, aTableHeader), , {0.15, 0.15, 0.7})
	endif
	
	makeHidden(aBuffer, "dw_step", "3")
   
	// monta a função JavaScript para validar o código de confirmação
	aChecksOnSubmit := {}
	aAdd(aChecksOnSubmit, 'if (!checkConfirmationCode("' + nConfCode + '")) {')
	aAdd(aChecksOnSubmit, '	return false;')
	aAdd(aChecksOnSubmit, '}')
   
   // define a blockcode que será utilizado na submissão do form
   bJavaScript		:= {|aBuffer, aaParams, alEdit| aAdd(aBuffer, dwConcatWSep(CRLF, aChecksOnSubmit))}
	
return buildCheckList('frmTools', cTitle, AC_TOOLS_CLEAN, OP_STEP, aButtons, aBuffer, , , bJavaScript)

/*
--------------------------------------------------------------------------------------
Monta a página de ferramentas de limpeza do data warehouse
Args:
--------------------------------------------------------------------------------------
*/
static function buildTCThirdStep()
	local aBuffer := {}, aButtons := {}
	local cTitle, cPostName, cPostValue
	local oDWClean := TDWClean():New()
	local bFormatMsg := {|text| makeText(aBuffer, text)}
	local aToken, nInd
	
	// título da página
	cTitle := STR0021 //"Processando Limpeza do Datawarehouse"
	
	// exclusão de dados das dimensões
	// as dimensões virão concatenadas com ',' num único campo
	cPostName	:= PREFIX_DIM_CONTENTS
	cPostValue 	:= &("HttpPost->" + cPostName)
	if !(valType(cPostValue) == "U")
		// tokeniza a string com as dimensões
		aToken := DwToken(cPostValue, ",", .F., .T.)
		
		if !(valType(aToken) == "U") .and. len(aToken) > 0
			// itera pelo array, adicionando as dimensões ao objeto que excluirá os dados
			for nInd := 1 to len(aToken)
				oDWClean:addDimContents(DwVal(aToken[nInd]))
			next
			// exclui os conteúdos
			oDWClean:deleteDimContents(bFormatMsg)
		endif
	endif
	
	// exclusão da definição das dimensões
	// as dimensões virão concatenadas com ',' num único campo
	cPostName	:= PREFIX_DIM_DEFINTION
	cPostValue 	:= &("HttpPost->" + cPostName)
	if !(valType(cPostValue) == "U")
		// tokeniza a string com as dimensões
		aToken := DwToken(cPostValue, ",", .F., .T.)
		
		if !(valType(aToken) == "U") .and. len(aToken) > 0
			// itera pelo array, adicionando as dimensões ao objeto que excluirá as definições
			for nInd := 1 to len(aToken)
				oDWClean:addDimDefinitions(DwVal(aToken[nInd]))
			next
			// exclui as definições
			oDWClean:dropDimDefinitions(bFormatMsg)
		endif
	endif
	
	// exclusão de dados de cubos
	// os cubos virão concatenadas com ',' num único campo
	cPostName	:= PREFIX_CUB_CONTENTS
	cPostValue 	:= &("HttpPost->" + cPostName)
	if !(valType(cPostValue) == "U")
		// tokeniza a string com os cubos
		aToken := DwToken(cPostValue, ",", .F., .T.)
		
		if !(valType(aToken) == "U") .and. len(aToken) > 0
			// itera pelo array, adicionando as dimensões ao objeto que excluirá os dados
			for nInd := 1 to len(aToken)
				oDWClean:addCubContents(DwVal(aToken[nInd]))
			next
			
			// exclui os conteúdos
			oDWClean:deleteCubContents(bFormatMsg)
		endif
	endif
	
	// exclusão da definição de cubos
	// os cubos virão concatenadas com ',' num único campo
	cPostName	:= PREFIX_CUB_DEFINTION
	cPostValue 	:= &("HttpPost->" + cPostName)
	if !(valType(cPostValue) == "U")
		// tokeniza a string com os cubos
		aToken := DwToken(cPostValue, ",", .F., .T.)
		
		if !(valType(aToken) == "U") .and. len(aToken) > 0
			// itera pelo array, adicionando os cubos ao objeto que excluirá as definições
			for nInd := 1 to len(aToken)
				oDWClean:addCubDefinitions(DwVal(aToken[nInd]))
			next
			
			// exclui as definições
			oDWClean:dropCubDefinitions(bFormatMsg)
		endif
	endif
	
	// exclusão da tabela de consultas pré-definidas
	// as consultas virão concatenadas com ',' num único campo
	cPostName	:= PREFIX_QRY_PREDEF_TABLE
	cPostValue 	:= &("HttpPost->" + cPostName)
	if !(valType(cPostValue) == "U")
		// tokeniza a string com as consultas
		aToken := DwToken(cPostValue, ",", .F., .T.)
		
		if !(valType(aToken) == "U") .and. len(aToken) > 0
			// itera pelo array, adicionando as consultas ao objeto que excluirá a tabela
			for nInd := 1 to len(aToken)
				oDWClean:addQueryToClean(DwVal(aToken[nInd]))
			next
			
			// exclui a tabela
			oDWClean:dropTableQuery(QUERY_PREDEF, bFormatMsg)
		endif
	endif
	     
	// exclusão do gráfico de consultas pré-definidas
	// as consultas virão concatenadas com ',' num único campo
	cPostName	:= PREFIX_QRY_PREDEF_GRAPH
	cPostValue 	:= &("HttpPost->" + cPostName)
	if !(valType(cPostValue) == "U")
		// tokeniza a string com as consultas
		aToken := DwToken(cPostValue, ",", .F., .T.)
		
		if !(valType(aToken) == "U") .and. len(aToken) > 0
			// itera pelo array, adicionando as consultas ao objeto que excluirá a tabela
			for nInd := 1 to len(aToken)
				oDWClean:addQueryToClean(DwVal(aToken[nInd]))
			next
			
			// exclui o gráfico
			oDWClean:dropGraphQuery(QUERY_PREDEF, bFormatMsg)
		endif
	endif
	
	// exclusão da tabela de consultas de usuários
	// as consultas virão concatenadas com ',' num único campo
	cPostName	:= PREFIX_QRY_USER_TABLE
	cPostValue 	:= &("HttpPost->" + cPostName)
	if !(valType(cPostValue) == "U")
		// tokeniza a string com as consultas
		aToken := DwToken(cPostValue, ",", .F., .T.)
		
		if !(valType(aToken) == "U") .and. len(aToken) > 0
			// itera pelo array, adicionando as consultas ao objeto que excluirá a tabela
			for nInd := 1 to len(aToken)
				oDWClean:addQueryToClean(DwVal(aToken[nInd]))
			next
			
			// exclui a tabela
			oDWClean:dropTableQuery(QUERY_USER, bFormatMsg)
		endif
	endif
	     
	// exclusão do gráfico de consultas usuários
	// as consultas virão concatenadas com ',' num único campo
	cPostName	:= PREFIX_QRY_USER_GRAPH
	cPostValue 	:= &("HttpPost->" + cPostName)
	if !(valType(cPostValue) == "U")
		// tokeniza a string com as consultas
		aToken := DwToken(cPostValue, ",", .F., .T.)
		
		if !(valType(aToken) == "U") .and. len(aToken) > 0
			// itera pelo array, adicionando as consultas ao objeto que excluirá a tabela
			for nInd := 1 to len(aToken)
				oDWClean:addQueryToClean(DwVal(aToken[nInd]))
			next
			
			// exclui o gráfico
			oDWClean:dropGraphQuery(QUERY_USER, bFormatMsg)
		endif
	endif
	
	// verifica se deve compactar o DW
 	cPostName := PREFIX_DW_PACK + dwStr(oSigaDW:DWCurr()[1])
	cPostValue := &("HttpPost->" + cPostName)
	if valType(cPostValue) == "C" 
 	  cPostName := PREFIX_DW_PACK + dwStr(oSigaDW:DWCurr()[1])
	  cPostValue := &("HttpPost->" + cPostName)
    if DWDoCompact()
		  oDWClean:packDW(bFormatMsg, .t.)
		  DWDoCompact(.f.)
		else
		  eval(bFormatMsg, "<b>" + STR0029 + "</b>") //###"ATENÇÂO"
		  eval(bFormatMsg, STR0030) //###"Foi solicitado a compactação da base de dados do SigaDW, porém a chave 'doCompact' não foi ativada."
		  eval(bFormatMsg, STR0031) //###"Ative-a, reinicie o serviço do SigaDW e efetue uma nova solicitação."
		endif
	endif

	makeWarning(aBuffer, STR0022) //"Processo Finalizado"

return buildCheckList('frmTools', cTitle, AC_TOOLS_CLEAN, , aButtons, aBuffer)
%>